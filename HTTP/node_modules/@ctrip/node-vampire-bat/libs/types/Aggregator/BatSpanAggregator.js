"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.batSpanAggregator = void 0;
const node_vampire_util_1 = __importDefault(require("@ctrip/node-vampire-util"));
const console_1 = require("../../utils/console");
const const_1 = require("../../utils/const");
const BaseAggregator_1 = require("./BaseAggregator");
/**
 * 聚合Tree,无需关联上下文
 */
class BatSpanAggregator extends BaseAggregator_1.Aggregator {
    constructor() {
        super();
        this.aggregatorRules = {};
        this.StatData = SpanData;
    }
    /**
     * 根据自定义规则聚合数据
     * @param param0
     * @returns
     */
    aggregateFilter({ type, name }) {
        if (this.aggregatorRules[type]) {
            const rules = this.aggregatorRules[type];
            if (rules && node_vampire_util_1.default.type(rules) === 'array') {
                for (const { rule, aggregateName } of rules) {
                    if (rule && node_vampire_util_1.default.type(rule) === 'regexp' && rule.test(name))
                        return {
                            type,
                            name: name.replace(rule, aggregateName || const_1.CAT_TREE_AGGREGATOR)
                        };
                    if (rule && node_vampire_util_1.default.type(rule) === 'function') {
                        const _name = rule(name);
                        return {
                            type,
                            name: _name || const_1.CAT_TREE_AGGREGATOR
                        };
                    }
                }
            }
            else {
                (0, console_1.log)('aggregatorRules invalid,rules must be in array format.');
            }
        }
        return {
            type,
            name
        };
    }
}
exports.batSpanAggregator = new BatSpanAggregator();
function SpanData(type, name) {
    this.type = type;
    this.name = name;
    this.count = 0;
    this.sum = 0;
    this.max = {
        messageId: '',
        value: -1
    };
    this.min = 2147483647;
    this.self = 0;
    this.fail = 0;
    this.messageId = null;
    this.durations = new Map();
    this.distribution = new Map();
}
SpanData.prototype.add = function (span) {
    const messageId = span.__messageId;
    this.count++;
    (messageId && !this.messageId) && (this.messageId = messageId);
    const duration = parseInt(((span.duration || 0) / 1000));
    this.sum = this.sum + duration;
    const oneDuration = parseInt((duration / this.count)) || 0;
    if (oneDuration < this.min) {
        this.min = oneDuration;
    }
    if (span.status == 'ERROR' && !span.type.includes('infoSec-')) {
        this.fail++;
    }
    if (oneDuration >= this.max.value) {
        this.max.value = oneDuration;
        this.max.messageId = span.__messageId || null;
    }
    const durations_count = this.adgetOrCreateCountd(this.durations, this.computeDuration(oneDuration));
    this.durations.set(this.computeDuration(oneDuration), durations_count + this.count);
    const distribution_count = this.adgetOrCreateCountd(this.distribution, this.computeDistribution(oneDuration));
    this.distribution.set(this.computeDistribution(oneDuration), distribution_count + this.count);
};
SpanData.prototype.adgetOrCreateCountd = function (durations, position) {
    let count = durations.get(position);
    if (count == null) {
        count = 0;
        durations.set(position, count);
    }
    return count;
};
SpanData.prototype.computeDuration = function (duration) {
    if (duration < 20) {
        return duration;
    }
    else if (duration < 200) {
        return duration - duration % 5;
    }
    else if (duration < 2000) {
        return duration - duration % 50;
    }
    else {
        return duration - duration % 500;
    }
};
SpanData.prototype.computeDistribution = function (duration) {
    let dk = 1;
    if (duration > 65536) {
        dk = 65536;
    }
    else {
        while (dk < duration) {
            dk = dk << 1;
        }
    }
    return dk;
};
SpanData.prototype.MapToString = function (map) {
    const str = [];
    map.forEach((value, key) => {
        str.push(key + ',' + value);
    });
    return str.join('|');
};
