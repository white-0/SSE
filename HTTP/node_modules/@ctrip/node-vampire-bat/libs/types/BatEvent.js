"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BatEvent = void 0;
const context_1 = require("./context");
const messageId_1 = require("../utils/messageId");
const BaseScope_1 = require("./BaseScope");
const const_1 = require("../utils/const");
const node_vampire_util_1 = __importDefault(require("@ctrip/node-vampire-util"));
const BatEventAggregator_1 = require("./Aggregator/BatEventAggregator");
class BatEvent extends BaseScope_1.BaseScope {
    constructor(...args) {
        super(...args);
        let isEndTree = false;
        if (!(0, context_1.getData)()) {
            isEndTree = true;
        }
        const _context = (0, context_1.appendToContext)(this, isEndTree);
        if (args[0] === 'ERROR') {
            const err = this.createError(args[1], args[2]);
            this.name = err.message || "Unknown Name";
            this.data = err.stack || "Unknown Data";
            this.type = 'Error';
            this.__type = const_1.TYPES.ERROR;
            this.status = const_1.STATUS[this.__type];
            _context.children.length && (_context.children[0].status = this.status);
        }
        else {
            this.__type = const_1.TYPES.EVENT;
            this.status = const_1.STATUS[this.__type];
        }
        let scope = (0, context_1.getActiveScope)();
        this.__messageId = scope && scope.__messageId || messageId_1.messageId.getMessageId();
    }
    beforeSend() {
        if (this.__close)
            return;
        this.baseBeforeSend();
        BatEventAggregator_1.batEventAggregator.aggregate(this);
    }
    createError(err, stack) {
        let message = "Error Unknown";
        stack = stack || "";
        let messages, stacks;
        if (node_vampire_util_1.default.type(stack) != "string") {
            stack = JSON.stringify(stack);
        }
        if (err === null) {
            message = "Error Null";
        }
        else if (err === void 0) {
            message = "Error Undefined";
        }
        else {
            switch (node_vampire_util_1.default.type(err)) {
                case "error":
                    message = "" + err.message;
                    stack = (stack ? stack + " ||| " : "") + err.stack;
                    break;
                case "string":
                case "number":
                    message = "" + err;
                    stack = (stack ? stack + " ||| " : "") + err;
                    break;
                case "array":
                    messages = ["Error Array"];
                    stacks = [];
                    err.map((item) => this.createError(item)).forEach((err) => {
                        messages.push("" + err.message);
                        stacks.push("[" + err.message + "] " + err.stack);
                    });
                    message = messages.join(" ||| ");
                    stack = (stack ? stack + " ||| " : "") + stacks.join(" ||| ");
                    break;
                case "object":
                    messages = ["Error Object"];
                    stacks = [];
                    try {
                        for (let key in err) {
                            if (Object.prototype.hasOwnProperty.call(err, key)) {
                                let subErr = this.createError(err[key]);
                                if (node_vampire_util_1.default.type(err[key]) == "error") {
                                    messages.push("" + subErr.message);
                                }
                                stacks.push("[" + subErr.message + "] " + subErr.stack);
                            }
                        }
                    }
                    catch (e) {
                        //empty
                    }
                    message = messages.join(" ||| ");
                    stack = (stack ? stack + " ||| " : "") + stacks.join(" ||| ");
                    break;
                case "date":
                    message = "Error Date";
                    stack = (stack ? stack + " ||| " : "") + err.toLocaleString();
                    break;
                default:
                    message = "" + err;
                    stack = (stack ? stack + " ||| " : "") + err;
                    break;
            }
        }
        if (message.length > 100) {
            message = message.slice(0, 97) + "...";
        }
        let newErr = new Error(message);
        try {
            newErr.type = message;
            newErr.stack = stack;
        }
        catch (e) {
            // empty
        }
        return newErr;
    }
}
exports.BatEvent = BatEvent;
