"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Context = exports.appendToContext = exports.getData = exports.getActiveRootScope = exports.getActiveScope = exports.getActiveContext = void 0;
const storage_1 = require("../utils/storage");
const const_1 = require("../utils/const");
const messageId_1 = require("../utils/messageId");
const queue_1 = require("../servlet/queue");
const MergeTree_1 = require("./MergeTree");
const TraceContext_1 = require("./TraceContext");
const BaseScope_1 = require("./BaseScope");
const node_vampire_console_1 = __importDefault(require("@ctrip/node-vampire-console"));
const console = (0, node_vampire_console_1.default)('vampire:bat');
const node_vampire_appconfig_1 = __importDefault(require("@ctrip/node-vampire-appconfig"));
const node_vampire_util_1 = __importDefault(require("@ctrip/node-vampire-util"));
// 保存上下文信息
const ContextObj = {};
// 保存originStore
const originStore = new WeakMap();
// 保存run的store,兼容多次run的情况(e.g.云函数)
const runStore = new WeakMap();
/*
 * 当前上下文树, 复用
 * @param {Number} seq context树的序号，序号为 0 时表示为初始树，例如 URL span，当初始树发送后，seq 会自增，产生一颗新的异步树
 * @param {Array} children 叶子节点
 * @param {function} clock 超时定时器
 */
class Context {
    constructor() {
        this.__inheritValue = {};
        this.infoSecPrefix = null;
        this.isFromInfoSec = false;
        this.isOriginatedFromInfoSec = false;
        this.__traceContext = new TraceContext_1.TraceContext(); //traceContext
        this.seq = 0;
        this.children = [];
        this.clock = null;
    }
    // 发送定时器，加入任何叶子节点都会触发定时器
    setTimeout(isEndTree) {
        if (this.clock) {
            return;
        }
        this.clock = setTimeout(() => {
            this.clock = null;
            this.children.length > 0 && this.send(true);
        }, isEndTree ? 500 : (global._SPAN_TIMEOUT || const_1.SPAN_TIMEOUT)).unref();
    }
    buildStore(scope = null, data = {}) {
        return {
            // 上下文 span
            scope,
            // 上下文数据
            data: Object.assign({}, getData(), data),
            // 当前上下文树
            context: this,
        };
    }
    enter(scope = null) {
        originStore.set(scope, storage_1.storage.getStore());
        storage_1.storage.enterWith(this.buildStore(scope, null));
    }
    /*
     * 避免并列异步的span,被串联到一个span上,详见changelog
     */
    resetEnter(scope = null) {
        const _originStore = originStore.get(scope);
        _originStore && storage_1.storage.enterWith(_originStore);
    }
    exit(scope = null) {
        scope && (scope.duration = node_vampire_util_1.default.getMicroSeconds() - scope.__startMicroSeconds);
        storage_1.storage.enterWith(originStore.get(scope));
        this.end(scope);
    }
    /**
     * 在当前上下文内运行一个异步函数，绑定合并上下文数据
     * @param scope 上下文span
     * @param fn 应用fn(支持Promise,callback)
     * @param data 参数(rootmessageid等信息)
     * @returns
     */
    async runAsync(scope = null, fn, data = {}) {
        let ret;
        try {
            ret = await storage_1.storage.run(this.buildStore(scope, data), wrap(fn));
        }
        finally {
            this.exit(scope);
        }
        return ret;
    }
    run(scope = null, fn, data = {}) {
        let _store = this.buildStore(scope, data);
        if (!scope.isRun) { //兼容多次run的情况(e.g.云函数)
            scope.isRun = true;
            runStore.set(scope, _store);
        }
        else {
            _store = runStore.get(scope);
        }
        let ret = storage_1.storage.run(_store, fn, () => {
            this.exit(scope);
        });
        return ret;
    }
    /**
     *
     */
    end(scope = null) {
        // 如果为初始树，且当前 span 为根节点，发送当前树
        if (this.seq == 0 && scope && (this.children[0] === scope)) {
            this.send();
        }
    }
    /**
     * 发送当前上下文树
     * */
    send(isTimeout) {
        let fn = (child) => {
            !child.duration && (child.duration = node_vampire_util_1.default.getMicroSeconds() - child.__startMicroSeconds);
            //信息安全的爬虫请求
            (this.infoSecPrefix && child.type != 'RemoteCall') && (child.type = this.infoSecPrefix + child.type);
            if (child.beforeSend) {
                child.beforeSend();
            }
        };
        if (!(this.children.length == 1 && this.children[0].__type === 'span' && this.seq == 0)) {
            /** 0.1 root tree 关闭之后的节点 需要封装一层__CatMergeTree */
            fn = this.catMergeTree(fn);
        }
        else if (isTimeout) {
            /** 0.0 当Root Tree 超时关闭时记录Error */
            let _baseScope = new BaseScope_1.BaseScope('ERROR', 'TIMEOUT', '');
            _baseScope.__type = const_1.TYPES.EVENT;
            _baseScope.status = const_1.STATUS[_baseScope.__type];
            this.children[0].status = const_1.TYPES.ERROR;
            this.children[0].__children.push(_baseScope);
        }
        /** 1.当Root Tree 关闭的时候，设置 =查看更多 */
        this.setRemoteCall();
        /** 2.触发所有叶子节点的 beforeSend,并随父节点一起发送 */
        enumChildren(this.children, fn);
        /** 3.发送当前树 */
        queue_1.queue.addSendQueue(this.children[0]);
        if (node_vampire_appconfig_1.default.debug || process.env.TCONSOLE_DEBUG) {
            console.debug(this.debug());
        }
        /** 4.清理当前上下文树，生成新异步树 */
        if (this.clock) {
            clearTimeout(this.clock);
            this.clock = null;
        }
        this.seq++;
        this.children = [];
    }
    /**
     * 合并当前上下文树
     * 如果当前树不是未关闭的root tree,那么需要封装一层__CatMergeTree
     */
    catMergeTree(fn) {
        let _mergeTree = new MergeTree_1.MergeTree(const_1.CAT_MERGE_TREE, const_1.CAT_MERGE_TREE, this.__outerIds);
        _mergeTree.__children = this.children.slice(0);
        _mergeTree.__startMicroSeconds = _mergeTree.__children[0].__startMicroSeconds; //时间点非常重要
        _mergeTree.__startTime = _mergeTree.__children[0].__startTime; //时间点非常重要，范围不对日志不展示
        _mergeTree.__properties = Object.assign({}, _mergeTree.__properties, _mergeTree.__children[0].__properties);
        this.children = [_mergeTree];
        return (child) => {
            child.__messageId = _mergeTree.__messageId;
            fn(child);
        };
    }
    /**
     * 当 Tree 关闭的时候，设置 =查看更多
     */
    setRemoteCall() {
        let msgId = messageId_1.messageId.getMessageId();
        this.updateIds({
            "isRemoteCall": "true",
            "x-cat-id": msgId,
            "x-cat-parent-id": this.children[0].__messageId,
            "x-cat-root-id": this.children[0]?.__outerIds?.["x-cat-root-id"] || this.children[0].__messageId,
            "x-cat-trace-mode": "true",
        });
        let _baseScope = new BaseScope_1.BaseScope("RemoteCall", "RunAway", `${msgId}=查看更多 ::当下游无日志时，显示加载失败`);
        _baseScope.__type = const_1.TYPES.EVENT;
        _baseScope.status = const_1.STATUS[_baseScope.__type];
        this.children[0].__children.push(_baseScope);
    }
    // 打印当前上下文树
    debug() {
        let texts = ["━━ CONTEXT"];
        enumChildren(this.children, (child, { prefix, index, length }) => {
            let subPrefix = prefix;
            if (index == length - 1) {
                prefix += "└─";
                subPrefix += "  ";
            }
            else {
                prefix += "├─";
                subPrefix += "│ ";
            }
            texts.push(`${prefix} ${child.debug()}`);
            return subPrefix;
        }, 0, "  ");
        return texts.join("\n");
    }
    //设置可继承的属性；用于串联traceContext
    setInheritValue(key, req, infoSec) {
        this.__inheritValue[key] = req;
        this.infoSecPrefix = infoSec.infoSecPrefix;
        this.isFromInfoSec = infoSec.isFromInfoSec;
        this.isOriginatedFromInfoSec = infoSec.isOriginatedFromInfoSec;
        if (key == "reqEntity") {
            const headers = req['headers'];
            this.__traceContext.restoreTraceContext(headers); //如果设置的request内容，那么需要更新一下traceContext
            this.updateIds(headers); //根据头部信息，决定是否更新messageId, parentId, rootId
        }
    }
    /**
     * 初始化messageId, parentId 和 rootId(根据header中的X-CAT-TRACE-MODE来判断是否需要从头部获取相关id)
    * @param {object} headers 头部信息
    */
    updateIds(headers) {
        if (headers &&
            "" + headers["x-cat-trace-mode"] === "true") {
            this.setUpdateIds(headers);
        }
    }
    setUpdateIds(headers) {
        /**
            * 需要从调用方获取cat的messageid，将整条链路串联起来
            * 判断header['x-cat-id']是否存在，如果不存在则不做替换 x-cat-parent-id和x-cat-root-id做过兼容处理，这边可以不用判断
            * */
        if (headers["x-cat-id"] && headers["x-cat-id"].length > 0) {
            this.__outerIds = {
                "x-cat-id": headers["x-cat-id"],
                "x-cat-parent-id": headers["x-cat-parent-id"],
                "x-cat-root-id": headers["x-cat-root-id"],
            };
            if (!headers['isRemoteCall'] && this.children[0]) {
                this.children[0].__messageId = headers["x-cat-id"];
                this.children[0].__outerIds = this.__outerIds;
            }
        }
    }
}
exports.Context = Context;
//处理 callback类型方法和async方法
function wrap(fn) {
    return async () => {
        if (fn.length) {
            return new Promise((reslove) => fn(reslove));
        }
        else {
            return await fn();
        }
    };
}
// 枚举叶子节点
function enumChildren(children, fn, indent = 0, prefix = "") {
    let length = children.length;
    children.forEach((child, index) => {
        delete ContextObj[child._uid];
        let subPrefix = fn(child, {
            indent,
            prefix,
            index,
            length,
        });
        if (child.__children) {
            enumChildren(child.__children, fn, indent + 1, subPrefix);
        }
    });
}
// 获取当前上下文树
function getActiveContext(forceCreate = false, node) {
    let context = null;
    let store = storage_1.storage.getStore();
    if (store && store.context) {
        context = store.context;
    }
    else if (node && ContextObj[node._uid]) {
        return ContextObj[node._uid];
    }
    else if (forceCreate) {
        context = new Context();
        ContextObj[node._uid] = context;
    }
    return context;
}
exports.getActiveContext = getActiveContext;
// 获取当前上下文未发送的 span
function getActiveScope() {
    let store = storage_1.storage.getStore();
    if (store &&
        store.context &&
        store.scope &&
        // 如果当前父 span 的 seq 与当前上下文树的 seq 相同，表示当前 span 未发送(发送之后context.seq会++)
        store.context.seq == store.scope.seq) {
        return store.scope;
    }
    return null;
}
exports.getActiveScope = getActiveScope;
// 获取当前上下文未发送的 根span
function getActiveRootScope() {
    let store = storage_1.storage.getStore();
    if (store &&
        store.context &&
        store.scope &&
        // 如果当前父 span 的 seq 与当前上下文树的 seq 相同，表示当前 span 未发送(发送之后context.seq会++)
        store.context.seq == store.scope.seq) {
        return store.context.children[0];
    }
    return null;
}
exports.getActiveRootScope = getActiveRootScope;
// 获取当前上下文数据
function getData(key) {
    let store = storage_1.storage.getStore();
    if (store && store.data) {
        return key ? store.data[key] : store.data;
    }
    return null;
}
exports.getData = getData;
// 将叶子节点绑定到当前上下文树,todo:这里的any 应该是event或span
function appendToContext(node, isEndTree) {
    // 如果当前上下文树不存在，创建一个新的上下文树
    let context = getActiveContext(true, node);
    // 开启上下文树发送定时器
    context.setTimeout(isEndTree);
    if (node && node.__type != const_1.TYPES.TAGS) { //tags 不需要放到tree里
        // 获取当前上下文未发送的 span
        let scope = getActiveScope();
        if (scope) {
            // 将当前叶子节点加入到 span 的子节点中
            scope.__children.push(node);
        }
        else {
            // 将当前叶子节点加入到上下文树中
            context.children.push(node);
        }
    }
    // 绑定当前上下文树序号
    node.seq = context.seq;
    return context;
}
exports.appendToContext = appendToContext;
