"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.sender = void 0;
const net_1 = __importDefault(require("net"));
const fetchServerConfig_1 = require("./fetchServerConfig");
const appConfig_1 = require("../appConfig");
const const_1 = require("../utils/const");
const createRaw_1 = require("../protocols/createRaw");
const queue_1 = require("./queue");
const console_1 = require("../utils/console");
class Sender {
    constructor() {
        this.available = false;
        this.isSending = false; //是否正在发送
        this.sendBytes = 0; //发送的字节数
        this.catConn = Connector.getInstance('cat'); //连接
        this.esConn = Connector.getInstance('tags'); //ES连接
        this.retrySendClock = null; //重试发送的定时器
        this.highWaterMarkSwitch = false; //是否已经触发了高水位线事件
        this.senderReady();
        (0, console_1.log)('sender init');
    }
    //发送数据
    async sendPackage() {
        if (!this.available) {
            (0, console_1.log)('server is unavailable');
            return;
        }
        if (this.isSending) {
            //log('logs is sending');
            return;
        }
        if (this.retrySendClock) {
            clearTimeout(this.retrySendClock);
            this.retrySendClock = null;
        }
        this.isSending = true;
        const item = queue_1.queue.consumeFromQueue();
        if (!item) {
            this.isSending = false;
            return Promise.resolve();
        }
        let _conn = null;
        if (item.__type === 'tags') {
            _conn = this.esConn;
        }
        else {
            _conn = this.catConn;
        }
        if (!await _conn.isReady()) {
            queue_1.queue.restoreToSendQueue(item);
            this.retrySendClock = setTimeout(this.sendPackage.bind(this), 10000).unref();
            this.isSending = false;
            return Promise.resolve('conn is not ready');
        }
        let raw = (0, createRaw_1.createRaw)(item);
        //sendRaw
        let socketConn = null;
        try {
            socketConn = await _conn.prepareConn();
            if (!this.highWaterMarkSwitch || socketConn.writableLength < const_1.CONNECT_SET.lowWaterMark) {
                this.sendBytes += raw.length;
                socketConn.write(raw);
                this.highWaterMarkSwitch = socketConn.writableLength > const_1.CONNECT_SET.highWaterMark;
            }
            else {
                (0, console_1.log)(`Send Cat Package Failed.The writableLength is ${socketConn.writableLength} and rawBytes is ${raw.length}`);
                raw = null;
            }
            this.isSending = false;
            process.nextTick(this.sendPackage.bind(this));
        }
        catch (e) {
            // empty
            this.isSending = false;
            queue_1.queue.restoreToSendQueue(item);
            socketConn && await _conn.destoryConn(socketConn);
            // this.retrySendClock = setTimeout(this.sendPackage.bind(this), 10000).unref();
        }
        return Promise.resolve();
    }
    senderReady() {
        (0, fetchServerConfig_1.fetchServerConfig)()
            .then(() => {
            this.available = true;
            (0, console_1.log)("Sender Ready");
            queue_1.queue.emit('senderReady');
            this.sendPackage();
            queue_1.queue.on("exceed", this.sendPackage.bind(this));
        })
            .catch((err) => {
            (0, console_1.log)("Sender Not Ready: " + err.message);
            setTimeout(this.senderReady.bind(this), 10000).unref();
        });
    }
    getSendBytes() {
        return this.sendBytes;
    }
}
let ConnectorObj = {
    'tags': null,
    'cat': null
};
class Connector {
    constructor(type) {
        this.serverLists = null;
        this.currentServerLists = null;
        this.typeName = null;
        this.conn = null; //连接
        this.type = null;
        this.timer = null;
        this.type = type;
    }
    static getInstance(type) {
        if (ConnectorObj[type]) {
            return ConnectorObj[type];
        }
        return ConnectorObj[type] = new Connector(type);
    }
    // 判断连接串是否获取成功
    async isReady() {
        if (this.type === "tags" &&
            appConfig_1.appConfig["esServer"] &&
            appConfig_1.appConfig["es.bizLogEnable"]) {
            this.typeName = "ES";
            this.serverLists = appConfig_1.appConfig["esServer"];
        }
        else if (this.type != "tags" &&
            appConfig_1.appConfig["CatServer"] &&
            appConfig_1.appConfig["cat.enable"]) {
            this.typeName = "CAT";
            this.serverLists = appConfig_1.appConfig["CatServer"];
        }
        if (!this.serverLists) {
            return false;
        }
        const _currentServerLists = this.currentServerLists;
        // 当ip变更或连接断开
        if (_currentServerLists != this.serverLists.toString()) {
            let connCopy = this.conn;
            try {
                //仅当连接未被更换时，才置空
                const socketConn = connCopy && await connCopy;
                if (this.conn === connCopy) {
                    this.conn = null;
                }
                this.currentServerLists = this.serverLists.toString();
                this.destoryConn(socketConn);
            }
            catch (e) {
                (0, console_1.log)(e);
                if (this.conn === connCopy) {
                    this.conn = null;
                }
            }
        }
        return true;
    }
    /**
     * 准备连接
     * @param serverList
     */
    async prepareConn() {
        if (!this.conn) {
            let servers = this.serverLists.slice(0); //copy
            this.conn = this.tryConnectServer(servers);
        }
        return await this.conn;
    }
    tryConnectServer(servers) {
        (0, console_1.log)(`${this.typeName} Server List: ` + servers);
        let server = servers.shift();
        if (server) {
            return this.connect(server).catch(() => {
                return this.tryConnectServer(servers);
            });
        }
        else {
            return Promise.reject(new Error(`None Available ${this.typeName} Server`));
        }
    }
    connect(server) {
        let arr = server.split(":");
        let host = arr[0];
        let port = parseInt(arr[1], 10);
        let newConn = net_1.default.connect(port, host).unref();
        newConn['isConnected'] = false;
        return new Promise((resolve, reject) => {
            newConn.on("error", (err) => {
                this.destoryConn(newConn);
                if (newConn.isConnected) {
                    (0, console_1.log)(`Connection Lost, ${this.typeName} Server: ` + server);
                }
                else {
                    (0, console_1.log)(`Connect To ${this.typeName} Server Error: ${server}; ${err}`);
                }
                reject();
            });
            newConn.on("connect", () => {
                newConn.isConnected = true;
                (0, console_1.log)(`Connect To ${this.typeName} Server Success: ` + server);
                this.timer = setTimeout(() => {
                    //连接超过五分钟时：重新建连
                    (0, console_1.log)(`[ Vampire-CAT ] ${this.typeName} connected for more than five minutes: ` + const_1.CONNECT_SET.CONN_TIMEOUT);
                    this.destoryConn(newConn);
                }, const_1.CONNECT_SET.CONN_TIMEOUT).unref();
                return resolve(newConn);
            });
            newConn.on("end", () => {
                this.destoryConn(newConn);
                (0, console_1.log)(`Connection Closed, ${this.typeName} Server: ` + server);
                reject();
            });
        });
    }
    //销毁连接
    async destoryConn(socketConn) {
        if (!socketConn)
            return;
        this.timer && clearTimeout(this.timer);
        let connCopy = this.conn;
        try {
            //仅当连接未被更换时，才置空
            let socketCopy = await connCopy;
            if (socketCopy === socketConn && this.conn === connCopy) {
                this.conn = null;
            }
        }
        catch (err) {
            if (this.conn === connCopy) {
                this.conn = null;
            }
        }
        try {
            socketConn.end();
        }
        catch (e) {
            // empty
        }
        try {
            socketConn.destroy();
        }
        catch (e) {
            // empty
        }
    }
}
exports.sender = new Sender();
