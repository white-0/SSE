"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.queue = void 0;
const events_1 = require("events");
const fs = __importStar(require("fs"));
const storage_1 = require("../utils/storage");
const node_vampire_appconfig_1 = __importDefault(require("@ctrip/node-vampire-appconfig"));
const const_1 = require("../utils/const");
const console_1 = require("../utils/console");
const BatEvent_1 = require("../types/BatEvent");
const BatSpan_1 = require("../types/BatSpan");
const createRaw_1 = require("../protocols/createRaw");
/**
 * 发送队列
 */
class Queue extends events_1.EventEmitter {
    constructor() {
        super();
        this.sendQueue = [];
        this.__batchUpdate = false;
        this.dropMessageCount = 0;
    }
    async addSendQueue(item) {
        this.sendQueue.push(item);
        (0, storage_1.runInGlobalContext)(() => {
            if (this.sendQueue.length > const_1.QUEUE_LENGTH) {
                let overflowQueue = this.sendQueue.splice(0, const_1.OVERFLOW_QUEUE_LENGTH);
                this.countMessage(overflowQueue, (count, total) => {
                    (0, console_1.log)("Drop Cat " + count + " Messages (" + total + ")");
                    this.dropMessageCount += count;
                    if (!node_vampire_appconfig_1.default["isIgnoreDropMsgsError"]) {
                        let error = null;
                        new BatSpan_1.BatSpan('Drop Messages', 'Drop Messages').run((done) => {
                            error = new BatEvent_1.BatEvent("ERROR", "Drop Messages", "Total: " + total);
                            error.__overCount = count;
                            done();
                        });
                    }
                });
            }
            else if (!this.__batchUpdate) {
                this.emit("exceed");
            }
        });
    }
    countMessage(items, callback) {
        let count = 0;
        let total = 0;
        items.forEach((item) => {
            switch (item.__type) {
                case "span":
                    count++;
                    total++;
                    this.countMessage(item.__children, (subCount, subTotal) => {
                        count += subCount;
                        total += subTotal;
                    });
                    break;
                case "statMessage":
                    count++;
                    total++;
                    break;
                case "event":
                    count++;
                    total++;
                    break;
                case "error":
                    count += item.__overCount ? 0 : 1;
                    total += item.__overCount || 1;
                    break;
                default:
                    break;
            }
        });
        callback(count, total);
        return count;
    }
    restoreToSendQueue(item) {
        this.sendQueue.unshift(item);
    }
    consumeFromQueue() {
        let item = null;
        if (!this.__batchUpdate) {
            item = this.sendQueue.shift();
            if (!item) {
                this.emit("idle"); //标记队列空置
            }
        }
        return item;
    }
    getDropMessageCount() {
        return this.dropMessageCount;
    }
    /**
     * 进程退出时将日志保存到指定的文件,并返回保存的日志条数
     */
    saveToDisk(queueFile) {
        let ret = 0;
        if (this.sendQueue.length > 0) {
            let content = [];
            this.sendQueue.forEach((item) => {
                if (item.__type != "tags") {
                    content.push((0, createRaw_1.createRaw)(item));
                }
            });
            try {
                fs.writeFileSync(queueFile, JSON.stringify(content));
                ret = this.sendQueue.length;
            }
            catch (e) {
                // empty
            }
        }
        return ret;
    }
    deserialize(content) {
        let ret = [];
        let tmpQueue = null;
        try {
            tmpQueue = JSON.parse(content);
        }
        catch (e) {
            // empty
        }
        if (tmpQueue) {
            tmpQueue.forEach(function (item) {
                ret.push(Buffer.from(item));
            });
        }
        return ret.length ? ret : null;
    }
    loadFromDisk(queueFile) {
        let ret = 0;
        try {
            let content = fs.readFileSync(queueFile).toString();
            let tmpQueue = this.deserialize(content);
            if (tmpQueue) {
                this.__batchUpdate = true;
                this.sendQueue = this.sendQueue.concat(tmpQueue);
                this.__batchUpdate = false;
                this.emit("exceed");
                ret = this.sendQueue.length;
            }
        }
        catch (e) {
            // empty
        }
        return ret;
    }
}
exports.queue = new Queue();
