"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.batHttp = exports.ucsFilter = exports.getIsInfoSec = exports.detectMode = exports.logRequestMethodInfo = exports.logRequestClientInfo = void 0;
const appConfig_1 = require("../appConfig");
const node_vampire_foundation_framework_1 = __importDefault(require("@ctrip/node-vampire-foundation-framework"));
const BatSpan_1 = require("../types/BatSpan");
const BatEvent_1 = require("../types/BatEvent");
const context_1 = require("../types/context");
const node_vampire_hook_1 = require("@ctrip/node-vampire-hook");
const console_1 = require("../utils/console");
const const_1 = require("../utils/const");
const storage_1 = require("../utils/storage");
const versionString = process.version
    .replace(/(\d+)/g, (t) => t.padStart(3, "0"))
    .replace(/[^\d]/g, "");
const const_2 = require("../utils/const");
/**generate URL.client part
 * IPS: 客户端真实IP
 * VirtualIP: remote_addr
 * Server：请求的domainName（参照Java的request.getServerName())
 * Referer:referrer 或 referer
 * Agent: user-agent
 * @param req {Object} http.IncomingMessage
 * @return {string} 用&连接的类似querystring格式的内容
 */
function logRequestClientInfo(req) {
    const ipForwarded = req.headers["x-forwarded-for"];
    const rawHeaders = req.rawHeaders;
    const index = rawHeaders.indexOf("Host");
    const serverName = index >= 0 ? rawHeaders[index + 1] : "";
    const info = [];
    info.push("IPS=" + ipForwarded); // 客户端真实IP
    info.push("VirtualIP=" + req.socket && req.socket.remoteAddress || req.headers["x-real-ip"]); // 同java一致,优先取remote_addr（可能是客户端真实ip，也可能是代理）
    info.push("Server=" + serverName);
    info.push("Referer=" + (req.headers["referrer"] || req.headers["referer"] || null));
    info.push("Agent=" + req.headers["user-agent"]);
    return info.join("&");
}
exports.logRequestClientInfo = logRequestClientInfo;
/**generate URL.method part
 * Method: HTTP/{method}
 * URL: request url(remove domainName)
 * @param req {Object} http.IncomingMessage
 * @return {string} 用&连接的类似querystring格式的内容
 */
function logRequestMethodInfo(req) {
    let info = [];
    info.push("HTTP/" + req.method);
    info.push(req.url.replace(/[?#].*$/, "") + " ");
    return info.join(" ");
}
exports.logRequestMethodInfo = logRequestMethodInfo;
/**
 * 判断上游链路中是否有source,用于全链路串联
 * @param req {Object} http.IncomingMessage
 * @return {number} 0: normal, 1: from header, 2: from container
 */
function detectMode(req) {
    let source = req.headers["x-cat-source"];
    let id = req.headers["x-cat-id"];
    if (source === "container") {
        return 2;
    }
    else if (id != null && id.length > 0) {
        return 1;
    }
    return 0;
}
exports.detectMode = detectMode;
function getIsInfoSec(req) {
    const clientIp = node_vampire_foundation_framework_1.default.getClientIp(req);
    let isFromInfoSec = false, isOriginatedFromInfoSec = false;
    if (clientIp &&
        appConfig_1.appConfig["specialSourceIpArr"] &&
        appConfig_1.appConfig["specialSourceIpArr"].includes(clientIp)) {
        isOriginatedFromInfoSec = true;
        isFromInfoSec = true;
        !req.headers[const_1.INFOSEC] &&
            (req.headers[const_1.INFOSEC] = "infoSec");
    }
    if (req.headers[const_1.INFOSEC]) {
        isOriginatedFromInfoSec = true;
    }
    let infoSecPrefix = '';
    if (isFromInfoSec) {
        infoSecPrefix = "infoSec-";
    }
    else if (isOriginatedFromInfoSec) {
        infoSecPrefix = "indirect-infoSec-";
    }
    return { isOriginatedFromInfoSec, isFromInfoSec, infoSecPrefix };
}
exports.getIsInfoSec = getIsInfoSec;
appConfig_1.appConfig
    .init()
    .then(() => {
    node_vampire_hook_1.serverHook.on("request", function (req, res, handler) {
        let tarUrl = req.url.replace(/[?#].*$/, "") + " ";
        let infoSec = getIsInfoSec(req);
        let ret = global.__setURLTranscation && global.__setURLTranscation(req) || {};
        let otherSpan = null;
        return (0, storage_1.runInGlobalContext)(() => {
            let span = new BatSpan_1.BatSpan("URL", tarUrl);
            (0, context_1.getActiveContext)(false, span).setInheritValue("reqEntity", req, infoSec);
            req.__currentURLSpan = res.__currentURLSpan = span;
            //UCS的判断
            (0, exports.ucsFilter)(req.headers);
            /* 2019/02/11 如果request中有x-cat-trace-mode为true，那么返回的header中根据mode新增字段。
                      参考自java，从header中判断response中应该返回什么cat内容
                       file source: cat/serverlet/catfilter.java
                  */
            let mode = detectMode(req);
            if (req.headers["x-cat-trace-mode"] === "true") {
                res.setHeader("X-CAT-SERVER", appConfig_1.appConfig["CatServer.Host"]);
                if (mode === 0) {
                    //request header中没有x-cat-id，则返回当前的messageId
                    res.setHeader("X-CAT-ROOT-ID", span.__messageId);
                    res.setHeader("X-CAT-ROOT-URL", appConfig_1.appConfig["CatServer.Url"] + span.__messageId);
                }
                else {
                    res.setHeader("X-CAT-ROOT-ID", req.headers["x-cat-root-id"] || '');
                    res.setHeader("X-CAT-PARENT-ID", req.headers["x-cat-parent-id"] || '');
                    res.setHeader("X-CAT-ID", req.headers["x-cat-id"] || '');
                    res.setHeader("X-CAT-ROOT-URL", appConfig_1.appConfig["CatServer.Url"] + (req.headers["x-cat-root-id"] || ''));
                }
            }
            let callback = function (done, _done) {
                if (appConfig_1.appConfig.debug) {
                    (0, console_1.log)("HTTP Request Start: " + req.url);
                }
                let cleaned = false;
                function cleanEventHandler() {
                    if (!cleaned) {
                        cleaned = true;
                        req.removeListener("error", requestErrorHandler);
                        res.removeListener("error", responseErrorHandler);
                        res.removeListener("close", logStatusCode);
                        res.removeListener("finish", logStatusCode);
                        done();
                        _done && _done();
                    }
                }
                function requestErrorHandler(err) {
                    if (err.code != "ECONNRESET") {
                        new BatEvent_1.BatEvent('ERROR', err, "Request Error");
                    }
                    else {
                        new BatEvent_1.BatEvent("URL.REQUEST", "Aborted");
                    }
                    cleanEventHandler();
                }
                function responseErrorHandler(err) {
                    new BatEvent_1.BatEvent('ERROR', err, "Response Error");
                    cleanEventHandler();
                }
                let logged = false;
                function logStatusCode() {
                    if (!logged) {
                        logged = true;
                        const fn = () => {
                            new BatEvent_1.BatEvent("URL.STATUSCODE", res.statusCode + '' || "NULL");
                            cleanEventHandler();
                        };
                        if (versionString >= const_2.ACT_MINI_VERSION) {
                            fn();
                        }
                        else {
                            process.nextTick(fn);
                        }
                    }
                }
                req.on("error", requestErrorHandler);
                res.on("error", responseErrorHandler);
                res.on("close", logStatusCode);
                res.on("finish", logStatusCode);
            };
            const _handler = (handler) => {
                res.removeListener("close", _handler);
                res.removeListener("finish", _handler);
                span.run((done) => {
                    /**新增记录url.client和url.method */
                    new BatEvent_1.BatEvent("URL", "URL.client", logRequestClientInfo(req));
                    new BatEvent_1.BatEvent("URL", "URL.method", logRequestMethodInfo(req));
                    /***************************** */
                    if (handler) {
                        if (ret.type) {
                            otherSpan = new BatSpan_1.BatSpan(ret.type, ret.name, ret.data || null);
                            otherSpan.run((_done) => {
                                callback(done, _done);
                            });
                        }
                        else {
                            callback(done, null);
                        }
                        return handler();
                    }
                    else {
                        done();
                    }
                });
            };
            res.on("close", _handler);
            res.on("finish", _handler);
            return function () {
                return _handler(handler);
            };
        });
    });
})
    .catch((err) => (0, console_1.log)("Cat http.js error: " + err));
const ucsFilter = (headers) => {
    const isZoneRequestFromHeaders = headers[const_1.TRACE_PREFIX + const_1.UCS.UCS_HEADER_IS_ZONE_REQUEST];
    const zoneFromHeaders = headers[const_1.TRACE_PREFIX + const_1.UCS.UCS_HEADER_IS_ZONE_REQUEST];
    let zoneFromFoundation = appConfig_1.appConfig && appConfig_1.appConfig.Zone;
    if (isZoneRequestFromHeaders == "true") {
        if (!zoneFromHeaders) {
            new BatEvent_1.BatEvent(const_1.UCS.UCS_CHECK_FAIL, const_1.UCS.UCS_ZONE_NOT_SET, "zoneFromHeaders : " + zoneFromHeaders);
        }
        else if (zoneFromHeaders != zoneFromFoundation) {
            new BatEvent_1.BatEvent(const_1.UCS.UCS_CHECK_FAIL, const_1.UCS.UCS_ZONE_MISMATCH, JSON.stringify({
                zoneFromHeaders,
                zoneFromFoundation,
            }));
        }
    }
};
exports.ucsFilter = ucsFilter;
const batHttp = (server) => {
    node_vampire_hook_1.serverHook.addServer(server);
};
exports.batHttp = batHttp;
