"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.bt6 = void 0;
const node_vampire_foundation_framework_1 = __importDefault(require("@ctrip/node-vampire-foundation-framework"));
const node_vampire_util_1 = __importDefault(require("@ctrip/node-vampire-util"));
const const_1 = require("../utils/const");
/**
 * 原始数据 协议
 */
let procName = process.execPath.replace(/^.*[/\\]/, '');
const CONCURRENT_MODIFIED = 'ConcurrentModified';
function createRaw(item) {
    const _context = new Context(item);
    _context.generateMapping();
    let ip = node_vampire_util_1.default.getHostIp();
    if (item.__splitProcess) {
        ip += '@@' + const_1.pm2Id;
    }
    let head = Buffer.concat([
        Buffer.from('BT6\t'),
        createVarString(node_vampire_foundation_framework_1.default.getAppID()),
        createVarString(node_vampire_util_1.default.getHostName()),
        createVarString(ip),
        createVarString(procName),
        createVarString(process.pid),
        createVarString(procName),
        createVarString(item.__messageId),
        item.__outerIds && item.__outerIds['x-cat-parent-id'] ? createVarString(item.__outerIds['x-cat-parent-id']) : node_vampire_util_1.default.varint(0),
        item.__outerIds && item.__outerIds['x-cat-root-id'] ? createVarString(item.__outerIds['x-cat-root-id']) : node_vampire_util_1.default.varint(0),
        node_vampire_util_1.default.varint(0),
        _context.encodeTokensFn(),
        _context.writeSkippableProperties(item.__properties)
    ]);
    let body = createItemRaw(_context, item);
    let size = Buffer.alloc(4);
    size.writeUIntBE(head.length + body.length, 0, 4);
    return Buffer.concat([
        Buffer.from('zcat'),
        size,
        head,
        body
    ]);
}
let itemMap = {
    'event': 'E',
    'error': 'E',
    'heartbeat': 'H'
};
function createItemRaw(_context, item) {
    let body = Buffer.alloc(0);
    if (item.__type == 'event' || item.__type == 'heartbeat' || item.__type == 'error') {
        body = Buffer.concat([
            Buffer.from(itemMap[item.__type]),
            node_vampire_util_1.default.varint(item.__startTime - _context.baseline),
            _context.writeToken(item.type),
            _context.writeToken(item.name),
            _context.writeStatus(item.status),
            createVarString(node_vampire_util_1.default.stringify(item.data))
        ]);
    }
    else if (item.__type == 'span') {
        body = Buffer.concat([
            Buffer.from('t'),
            node_vampire_util_1.default.varint(item.__startTime - _context.baseline),
            _context.writeToken(item.type),
            _context.writeToken(item.name),
            Buffer.concat(item.__children.map(function (subItem) {
                return createItemRaw(_context, subItem);
            })),
            Buffer.from('T'),
            _context.writeSkippableProperties(item.__properties),
            _context.writeStatus(item.status),
            createVarString(node_vampire_util_1.default.stringify(item.data)),
            node_vampire_util_1.default.varint(item.duration)
        ]);
    }
    return body;
}
function Context(item) {
    this.tree = item;
    this.baseline = null;
    this.encodedTokens = new Map();
}
Context.prototype.generateMapping = function () {
    const root = this.tree;
    this.baseline = root.__startTime;
    this.addEncodedToken(CONCURRENT_MODIFIED);
    this.addEncodedProperties(root.__properties);
    this.addEncodedTokens(root);
};
Context.prototype.writeStatus = function (status) {
    if (status === '0') {
        return Buffer.alloc(1);
    }
    else {
        return this.writeToken(status);
    }
};
Context.prototype.addEncodedTokens = function (msg) {
    this.addEncodedToken(msg.type);
    this.addEncodedToken(msg.name);
    if (msg.status != '0') {
        this.addEncodedToken(msg.status);
    }
    if (msg.__type === 'span') {
        this.addEncodedProperties(msg.__properties);
        for (const item of msg.__children) {
            this.addEncodedTokens(item);
        }
    }
};
Context.prototype.addEncodedProperties = function (properties) {
    if (!properties || Object.keys(properties).length === 0) {
        return;
    }
    for (const item in properties) {
        this.addEncodedToken(item);
        this.addEncodedToken(properties[item]);
    }
};
Context.prototype.addEncodedToken = function (token) {
    if (this.encodedTokens.get(token) == null) {
        this.encodedTokens.set(token, this.encodedTokens.size);
    }
};
Context.prototype.reset = function (tree) {
    this.tree = tree;
    this.encodedTokens.clear();
};
Context.prototype.encodeTokensFn = function () {
    const token_size = this.encodedTokens.size;
    let _ret = [];
    _ret.push(node_vampire_util_1.default.varint(this.baseline));
    _ret.push(node_vampire_util_1.default.varint(token_size));
    this.encodedTokens.forEach((value, key) => {
        _ret.push(createVarString(key));
    });
    return Buffer.concat(_ret);
};
//对应 cat\cat-client\src\main\java\com\dianping\cat\message\spi\codec\CodecHelper.java
Context.prototype.writeSkippableProperties = function (properties) {
    if (!properties || Object.keys(properties).length === 0) {
        return Buffer.alloc(4);
    }
    const buf_len = node_vampire_util_1.default.varint(Object.keys(properties).length);
    let encodedToken_buf = [];
    for (const item in properties) {
        encodedToken_buf.push(this.writeToken(item));
        encodedToken_buf.push(this.writeToken(properties[item]));
    }
    encodedToken_buf = Buffer.concat(encodedToken_buf);
    const payloadLen = node_vampire_util_1.default.intToBuff(buf_len.length + encodedToken_buf.length, 4);
    return Buffer.concat([payloadLen, buf_len, encodedToken_buf]);
};
Context.prototype.writeToken = function (token) {
    let index = this.encodedTokens.get(token);
    if (index == null) {
        index = this.encodedTokens.get(CONCURRENT_MODIFIED);
    }
    return node_vampire_util_1.default.varint(index);
};
function createVarString(str) {
    if (node_vampire_util_1.default.type(str) != 'string') {
        str = '' + str;
    }
    let buff = Buffer.from(str);
    return Buffer.concat([
        node_vampire_util_1.default.varint(buff.length),
        buff
    ]);
}
exports.bt6 = createRaw;
