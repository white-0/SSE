"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.activeHandles = void 0;
const util_1 = __importDefault(require("util"));
const events_1 = __importDefault(require("events"));
function ActiveHandles() { }
util_1.default.inherits(ActiveHandles, events_1.default);
ActiveHandles.prototype.dump = function () {
    let statistics = {
        count: {},
        detail: {},
    };
    let pArr = [];
    let p;
    //在node10以后getActiveResourcesInfo 才能获取到timeout
    if (process.getActiveResourcesInfo) {
        p = new Promise((resolve) => {
            const resources = process.getActiveResourcesInfo();
            resources.forEach((resource) => {
                if (resource === 'Timeout') {
                    let type = resource;
                    let detail = resource;
                    done(type, detail, statistics);
                }
            });
            resolve(void 0);
        });
        pArr.push(p);
    }
    if (process._getActiveHandles) {
        p = this._getActiveType(statistics, process._getActiveHandles());
        pArr.push(p);
    }
    if (process._getActiveRequests) {
        p = this._getActiveType(statistics, process._getActiveRequests());
        pArr.push(p);
    }
    return Promise.all(pArr).then(() => statistics).catch(() => statistics);
};
ActiveHandles.prototype._getActiveType = function (statistics, actives) {
    let pArr = [];
    let detailCount = {};
    try {
        actives.forEach((active) => {
            let type = null;
            if (active.constructor) {
                type = active.constructor.name || "Unknown";
            }
            else {
                type = "" + active || "Unknown";
            }
            let detail = null;
            let subPArr = [];
            if (!Object.prototype.hasOwnProperty.call(type)) {
                detailCount[type] = 0;
            }
            detailCount[type]++;
            //this.emit(type, active); 去除无用的逻辑
            let p, t;
            if (detailCount[type] < 100) {
                switch (type) {
                    case "Server":
                        if (active._pipeName) {
                            p = new Promise((resolve) => {
                                active.getConnections((err, count) => {
                                    detail = active._pipeName + " (" + (err ? 0 : count) + ")";
                                    resolve(void 0);
                                });
                            });
                            subPArr.push(p);
                        }
                        else {
                            t = active.address();
                            // fix: http://sentry.ubt.ctripcorp.com/share/issue/6af344ab43bd4b40aa5cdec15b6ed122/
                            if (t && t.address) {
                                p = new Promise((resolve) => {
                                    active.getConnections((err, count) => {
                                        detail =
                                            t.address + ":" + t.port + " (" + (err ? 0 : count) + ")";
                                        resolve(void 0);
                                    });
                                });
                                subPArr.push(p);
                            }
                            else {
                                detail = "idle";
                            }
                        }
                        break;
                    case "ChildProcess":
                        detail = active.spawnargs.join(" ");
                        break;
                    //case "Timer": Node.js 12.0.0及以后版本，_getActiveHandles 不再返回 Timer 对象
                    // if (!active._list) {
                    //   type = "Timer::Unknown";
                    // } else if (active._list.nextTick) {
                    //   type = "Timer::nextTick";
                    // } else if (active._list._idleNext && active._list._idleNext._repeat) {
                    //   type = "Timer::setInterval";
                    // } else {
                    //   type = "Timer::setTimeout";
                    // }
                    // t =
                    //   active._list &&
                    //   active._list._idleNext &&
                    //   active._list._idleNext._onTimeout;
                    // let tName = (t && t.name) || "anonymous";
                    // let tMSecs = active._list ? active._list.msecs || 0 : 0;
                    // detail = tName + " (" + tMSecs + ")";
                    //break;
                    case "Socket":
                        if (active.localAddress && active.remoteAddress) {
                            t = active.connecting ? " (connecting)" : "";
                            if (active.server) {
                                detail =
                                    active.remoteAddress +
                                        ":" +
                                        active.remotePort +
                                        " --> " +
                                        active.localAddress +
                                        ":" +
                                        active.localPort +
                                        t;
                            }
                            else {
                                detail =
                                    active.localAddress +
                                        ":" +
                                        active.localPort +
                                        " --> " +
                                        active.remoteAddress +
                                        ":" +
                                        active.remotePort +
                                        t;
                            }
                        }
                        else if (active.server && active.server._pipeName) {
                            detail = active.server._pipeName;
                        }
                        else {
                            detail = "idle / ipc";
                        }
                        break;
                    default:
                        break;
                }
            }
            p = Promise.all(subPArr).then(() => done(type, detail, statistics)).catch(() => done(type, detail, statistics));
            pArr.push(p);
        });
    }
    catch (e) {
        // empty
    }
    return Promise.all(pArr).then(() => statistics).catch(() => statistics);
};
function done(type, detail, statistics) {
    if (type) {
        if (!Object.prototype.hasOwnProperty.call(statistics.count, type)) {
            statistics.count[type] = 0;
        }
        statistics.count[type]++;
    }
    if (detail) {
        if (!Object.prototype.hasOwnProperty.call(statistics.detail, type)) {
            statistics.detail[type] = [];
        }
        statistics.detail[type].push(detail);
    }
}
exports.activeHandles = new ActiveHandles();
