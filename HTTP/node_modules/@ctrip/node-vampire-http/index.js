const http = require("http");
const https = require("https");
const url = require("url");
const util = require("util");
const zlib = require("zlib");
const cUtil = require("@ctrip/node-vampire-util");
const agentOptions = require("./libs/agentOptions.js");

const httpAgent = new http.Agent(agentOptions);
const httpsAgent = new https.Agent(agentOptions);
const proxyAgent = require("./libs/proxyAgent.js");

function consumeStream(stream) {
  stream.on("error", () => {});
  stream.on("data", () => {});
  stream.on("end", () => {});
  return;
}

/**gzip reference code from https://github.com/YounGoat/nodejs.htp/blob/master/htp.js */

function CustomError(name, code, message) {
  if (!this || !(this instanceof CustomError)) {
    return new CustomError(name, code, message);
  }

  this.name = name;
  this.code = code;
  this.message = message;

  //include stack trace in error object
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  }

  return this;
}

/**copy from https://github.com/RisingStack/example-http-timings/blob/master/app.js */
/**
 * Calculates HTTP timings
 * @function getTimings
 * @param {Object} eventTimes
 * @param {Number} eventTimes.startAt
 * @param {Number|undefined} eventTimes.dnsLookupAt
 * @param {Number} eventTimes.tcpConnectionAt
 * @param {Number|undefined} eventTimes.tlsHandshakeAt
 * @param {Number} eventTimes.firstByteAt
 * @param {Number} eventTimes.endAt
 * @return {Object} timings - { dnsLookup, tcpConnection, tlsHandshake, firstByte, contentTransfer, total }
 */
const NS_PER_SEC = 1e9;
const MS_PER_NS = 1e6;

function getTimings(eventTimes) {
  return {
    dnsLookup:
      eventTimes.dnsLookupAt !== undefined
        ? getHrTimeDurationInMs(eventTimes.startAt, eventTimes.dnsLookupAt)
        : undefined,
    tcpConnection: getHrTimeDurationInMs(
      eventTimes.dnsLookupAt || eventTimes.startAt,
      eventTimes.tcpConnectionAt
    ),
    tlsHandshake:
      eventTimes.tlsHandshakeAt !== undefined
        ? getHrTimeDurationInMs(
            eventTimes.tcpConnectionAt,
            eventTimes.tlsHandshakeAt
          )
        : undefined,
    firstByte: getHrTimeDurationInMs(
      eventTimes.tlsHandshakeAt || eventTimes.tcpConnectionAt,
      eventTimes.firstByteAt
    ),
    contentTransfer: getHrTimeDurationInMs(
      eventTimes.firstByteAt,
      eventTimes.endAt
    ),
    total: getHrTimeDurationInMs(eventTimes.startAt, eventTimes.endAt),
  };
}

/**
 * Get duration in milliseconds from process.hrtime()
 * @function getHrTimeDurationInMs
 * @param {Array} startTime - [seconds, nanoseconds]
 * @param {Array} endTime - [seconds, nanoseconds]
 * @return {Number} durationInMs
 */
function getHrTimeDurationInMs(startTime, endTime) {
  try {
    if (startTime !== undefined && endTime !== undefined) {
      const secondDiff = endTime[0] - startTime[0];
      const nanoSecondDiff = endTime[1] - startTime[1];
      const diffInNanoSecond = secondDiff * NS_PER_SEC + nanoSecondDiff;

      return diffInNanoSecond / MS_PER_NS;
    } else {
      return 0;
    }
  } catch (e) {
    return -1;
  }
}
/******************************************************************************** */

util.inherits(CustomError, Error);
cUtil.Error = cUtil.error = CustomError;

/*
 * SendRequest(reqUrl, [options, [postData]])
 * - reqUrl as string (请求的URL)
 * - options as object or string
 * - postData as string (POST 提交的内容)
 */
const SendRequest = function (reqUrl, options, postData) {
  let responseTimeoutClock = false;

  function clearResponseTimeout() {
    if (responseTimeoutClock) {
      clearTimeout(responseTimeoutClock);
    }
  }

  return new Promise(function (resolve, reject) {
    let timings = {
      startAt: process.hrtime(),
      dnsLookupAt: undefined,
      tcpConnectionAt: undefined,
      tlsHandshakeAt: undefined,
      firstByteAt: undefined,
      endAt: undefined,
    };

    let reqOpts = url.parse(reqUrl);

    if (options) {
      switch (cUtil.type(options)) {
        case "object":
          Object.getOwnPropertyNames(options).forEach((key) => {
            switch (key) {
              case "headers":
              case "contentType":
              case "unref":
                break;
              case "body":
                if (!postData) {
                  // 没有传递第三个参数时，body默认为要提交的数据
                  postData = options[key];
                }
                break;
              default:
                reqOpts[key] = options[key];
                break;
            }
          });
          break;
        case "string": // 当第二个参数为字符串时
        case "uint8array": // 当第二个参数为Buffer时
          if (!postData) {
            //且没有第三个参数，则默认第二个参数为要POST的数据
            postData = options;
          }
          options = {};
          break;
      }
    } else {
      options = {};
    }

    options.contentType = options.contentType || "text";

    if (postData) {
      reqOpts.method = reqOpts.method || "POST";
      reqOpts.headers = {
        "Content-Type": "application/json",
        "Content-Length": Buffer.byteLength(postData),
      };
    } else {
      reqOpts.headers = {};
    }

    if (options.gzip) {
      reqOpts.headers["Accept-Encoding"] = "gzip";
    }

    cUtil.extendMap(reqOpts.headers, options.headers);

    if (
      !Object.prototype.hasOwnProperty.call(reqOpts.headers, "Connection") &&
      !Object.prototype.hasOwnProperty.call(reqOpts.headers, "connection")
    ) {
      reqOpts.headers["Connection"] = "keep-alive";
    }

    let fetcher = null;

    if (reqOpts.proxy) {
      switch (reqOpts.protocol) {
        case "http:":
          fetcher = http;
          reqOpts.agent = reqOpts.agent || proxyAgent.httpProxyAgent;
          reqOpts.path = reqUrl;
          break;
        case "https:":
          fetcher = https;
          reqOpts.agent = reqOpts.agent || proxyAgent.httpsProxyAgent;
          break;
        default:
          reject(
            new Error(
              "Unsupported Protocol: " + (reqOpts.protocol || "(empty)")
            )
          );
          return;
      }
    } else {
      switch (reqOpts.protocol) {
        case "http:":
          fetcher = http;
          reqOpts.agent = reqOpts.agent || httpAgent;
          break;
        case "https:":
          fetcher = https;
          reqOpts.agent = reqOpts.agent || httpsAgent;
          break;
        default:
          reject(
            new Error(
              "Unsupported Protocol: " + (reqOpts.protocol || "(empty)")
            )
          );
          return;
      }
    }

    let req = fetcher.request(reqOpts, function (res) {
      let isGZip =
        res.headers["content-encoding"] &&
        res.headers["content-encoding"].toLowerCase() == "gzip" &&
        reqOpts.method != "HEAD";

      let resStream = null;
      if (isGZip) {
        resStream = zlib.createGunzip();
        res.pipe(resStream);
      } else {
        resStream = res;
      }

      if (options.contentType == "statusCode") {
        consumeStream(res);
        resolve(res.statusCode);
      } else if (options.contentType == "stream") {
        resolve(resStream);
      } else {
        let arr = [];
        if (options.time) {
          res.once("readable", () => {
            timings.firstByteAt = process.hrtime();
          });
        }

        resStream
          .on("error", function (e) {
            if (e.code == "ECONNRESET") {
              options.__retryTimes = options.__retryTimes || 0;
              options.__retryTimes++;
              if (options.__retryTimes < 3) {
                SendRequest(reqUrl, options, postData).then(resolve, reject);
              } else {
                reject(e);
              }
            } else {
              reject(e);
            }
          })
          .on("data", function (buff) {
            arr.push(buff);
          })
          .on("end", function () {
            if (options.time) {
              timings.endAt = process.hrtime();
            }

            res.body = Buffer.concat(arr);

            let ret = null;
            switch (options.contentType) {
              case "buffer":
              case "uint8array":
              case "binary":
                ret = res.body;
                break;
              case "response":
                ret = res;
                break;
              case "json":
                try {
                  ret = JSON.parse(res.body.toString());
                } catch (e) {
                  reject(e);
                  return;
                }
                break;
              case "text":
              default:
                ret = res.body.toString();
                break;
            }
            /**向下兼容，只有options.time为true才会重构返回体*/
            if (options.time) {
              if (options.contentType == "response") {
                ret.timings = getTimings(timings);
              } else {
                ret = {
                  body: ret,
                  timings: getTimings(timings),
                };
              }
            }
            resolve(ret);
          });
      }
    });

    req.on("socket", function (socket) {
      if (options.time) {
        var isConnecting = socket._connecting || socket.connecting;
        if (isConnecting) {
          const onLookupTiming = function () {
            timings.dnsLookupAt = process.hrtime();
          };

          const onConnectTiming = function () {
            timings.tcpConnectionAt = process.hrtime();
          };

          const onSecureConnectTiming = function () {
            timings.tlsHandshakeAt = process.hrtime();
          };

          socket.once("lookup", onLookupTiming);
          socket.once("connect", onConnectTiming);
          socket.once("secureConnect", onSecureConnectTiming);

          // clean up timing event listeners if needed on error
          req.once("error", function () {
            socket.removeListener("lookup", onLookupTiming);
            socket.removeListener("connect", onConnectTiming);
            socket.removeListener("secureConnect", onSecureConnectTiming);
          });
        }
      }

      if (options.unref) {
        socket.unref();
      }
    });

    req.on("error", function (e) {
      if (
        e.code == "ECONNREFUSED" ||
        (e.code == "ECONNRESET" && !req.aborted)
      ) {
        options.__retryTimes = options.__retryTimes || 0;
        options.__retryTimes++;
        if (options.__retryTimes < 3) {
          // console.log('Found ' + e.code + ', Retry ' + options.__retryTimes);
          SendRequest(reqUrl, options, postData).then(resolve, reject);
        } else {
          reject(e);
        }
      } else {
        reject(e);
      }
    });

    req.on("timeout", function () {
      req.abort();
      reject(
        cUtil.error(
          "connectTimeoutError",
          "ECONNRESET",
          "Connect time out: " + reqUrl
        )
      );
    });

    let responseTimeout = reqOpts["responseTimeout"];
    if (
      responseTimeout &&
      cUtil.type(responseTimeout) == "number" &&
      responseTimeout > 0
    ) {
      responseTimeoutClock = setTimeout(function () {
        req.abort();
        reject(
          cUtil.error(
            "responseTimeoutError",
            "ECONNRESET",
            "Request time out: " + reqUrl
          )
        );
      }, responseTimeout);
      if (options.unref) {
        responseTimeoutClock.unref();
      }
    }

    if (postData) {
      req.write(postData);
    }

    req.end();
  })
    .then((result) => {
      clearResponseTimeout();
      return result;
    })
    .catch((err) => {
      clearResponseTimeout();
      return Promise.reject(err);
    });
};

module.exports = SendRequest;
