const net = require('net');
const tls = require('tls');
const http = require('http');
const https = require('https');
const agentOptions = require('./agentOptions.js');
const appConfig = require('@ctrip/node-vampire-appconfig');

const HTTP_CONNECT_TIMEOUT = 1000;
const HTTPS_CONNECT_TIMEOUT = 2500;

appConfig.setDefaultConfigByEnv('Http.Proxy', {
  'fws': {
    host: 'ntproxy.qa.nt.ctripcorp.com',
    port: 8080
  },
  'lpt': {
    host: 'ntproxy.qa.nt.ctripcorp.com',
    port: 8080
  },
  'uat': {
    host: 'ntproxy.qa.nt.ctripcorp.com',
    port: 8080
  },
  'prod': {
    host: 'proxygate2.ctripcorp.com',
    port: 8080
  }
});

const proxyServer = appConfig['Http.Proxy'];

function createHttpProxyConnection(options, callback, retryTimes) {
  retryTimes = retryTimes || 0;
  let hasFired = false;
  let wrapCallback = (err, socket) => {
    if (callback && !hasFired) {
      hasFired = true;
      clearTimeout(timeoutClock);
      if (err) {
        retryTimes++;
        if (retryTimes > 3) {
          callback(err);
        } else {
          createHttpProxyConnection(options, callback, retryTimes);
        }
      } else {
        socket.removeListener('error', errorHandler);
        callback(null, socket);
      }
    }
  };
  let timeoutClock = setTimeout(() => {
    wrapCallback(new Error('Connect Proxy Server Timeout'));
  }, HTTP_CONNECT_TIMEOUT);
  let errorHandler = (err) => {
    wrapCallback(err);
  };
  let socket = net.createConnection(proxyServer.port, proxyServer.host, () => {
    wrapCallback(null, socket);
  });
  socket.on('error', errorHandler);
}

function createHttpsProxyConnection(options, callback, retryTimes) {
  retryTimes = retryTimes || 0;
  let rejectUnauthorized = Object.prototype.hasOwnProperty.call(options, 'rejectUnauthorized') ? options.rejectUnauthorized : true;
  let hasFired = false;
  let wrapCallback = (err, tlsSocket) => {
    if (callback && !hasFired) {
      hasFired = true;
      clearTimeout(timeoutClock);
      if (err) {
        retryTimes++;
        if (retryTimes > 3) {
          callback(err);
        } else {
          createHttpsProxyConnection(options, callback, retryTimes);
        }
      } else {
        tlsSocket.removeListener('error', errorHandler);
        callback(null, tlsSocket);
      }
    }
  };
  let timeoutClock = setTimeout(() => {
    wrapCallback(new Error('Connect Proxy Server Timeout'));
  }, HTTPS_CONNECT_TIMEOUT);
  let errorHandler = (err) => {
    wrapCallback(err);
  };
  let req = http.request({
    port: proxyServer.port,
    host: proxyServer.host,
    method: 'CONNECT',
    path: options.host + ':' + options.port,
    agent: false
  });
  let timeoutHandler = () => {
    req.abort();
    errorHandler(new Error('Connection Timeout'));
  };
  req.on('connect', (res, socket, head) => {
    socket.emit('agentRemove');

    if (res.statusCode != 200) {
      socket.destroy();
      wrapCallback(new Error(head.toString() || 'Connect To Proxy Server Error'));
      return;
    }

    req.removeListener('error', errorHandler);
    req.removeListener('timeout', timeoutHandler);

    let tlsSocket = tls.connect({
      socket,
      servername: options.host,
      rejectUnauthorized
    }, () => {
      wrapCallback(null, tlsSocket);
    });
    tlsSocket.on('error', errorHandler);
  });
  req.on('error', errorHandler);
  req.on('timeout', timeoutHandler);
  req.end();
}

const httpProxyAgent = new http.Agent(agentOptions);
httpProxyAgent.createConnection = createHttpProxyConnection;
const httpsProxyAgent = new https.Agent(agentOptions);
httpsProxyAgent.createConnection = createHttpsProxyConnection;

module.exports = {
  httpProxyAgent,
  httpsProxyAgent
};
