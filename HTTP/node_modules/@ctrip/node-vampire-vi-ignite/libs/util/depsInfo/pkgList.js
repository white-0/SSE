"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseDeps = void 0;
const child_process_1 = require("child_process");
const os = __importStar(require("os"));
function npmList(dir) {
    return new Promise((resolve, reject) => {
        let proc = (0, child_process_1.spawn)(`npm${os.platform() == "win32" ? ".cmd" : ""}`, [
            "ls",
            "-a",
            "-l",
            "--json",
            "--update-notifier=false"
        ], {
            cwd: dir
        });
        let outChunks = [], errChunks = [];
        proc.stdout.on("data", (chunk) => outChunks.push(chunk));
        proc.stderr.on("data", (chunk) => errChunks.push(chunk));
        proc.on("exit", () => {
            try {
                resolve(JSON.parse(Buffer.concat(outChunks).toString()));
            }
            catch (e) {
                reject(new Error("Invalid Stdout"));
            }
        });
        proc.on("error", reject);
    });
}
async function parseDeps(dir) {
    let root = {};
    try {
        let queue = [{
                dep: await npmList(dir),
                root,
                map: {},
            },];
        while (parseSubDeps(queue, dir)) {
            //empty
        }
        return root;
    }
    catch (err) {
        return root;
    }
}
exports.parseDeps = parseDeps;
function parseSubDeps(queue, dir) {
    let { dep, root, map } = queue.shift();
    let subRoot = {
        package: `${dep.name}@${dep.version || "latest"}`,
        path: dep.path,
        deduped: !!map[dep.path],
        version: dep.version,
        keyName: `${dep.name}`,
        dir,
        deps: [],
    };
    map[dep.path] = true;
    if (!root.deps) {
        Object.assign(root, subRoot);
    }
    else {
        root.deps.push(subRoot);
    }
    if (dep.dependencies) {
        for (let key in dep.dependencies) {
            if (Object.prototype.hasOwnProperty.call(dep.dependencies, key)) {
                queue.push({
                    root: subRoot,
                    dep: dep.dependencies[key],
                    map,
                });
            }
        }
    }
    return !!queue.length;
}
