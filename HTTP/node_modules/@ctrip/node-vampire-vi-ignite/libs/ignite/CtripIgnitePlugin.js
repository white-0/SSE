"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.isEndIgnited = exports.resetIgniteList = exports.getIgniteList = exports.CtripIgnitePlugin = void 0;
const SimpleLogger_1 = require("../util/SimpleLogger");
const LogHelper_1 = require("../util/LogHelper");
const node_vampire_util_1 = __importDefault(require("@ctrip/node-vampire-util"));
const LogFile_1 = require("../util/LogFile");
let IGNITELIST_APP = [], IGNITELIST_SDK = [];
const IGNITE_FUNCTION = ['helpUrl', 'warmUp', 'coreConfigs', 'selfCheck'];
let IS_END_IGNITED = false;
exports.CtripIgnitePlugin = {
    register: (params) => {
        if (IS_END_IGNITED) {
            (0, LogFile_1.log)('exit: No ignition during runtime');
            console.warn('\x1B[31m%s\x1B[0m', 'WARN:exit: No ignition during runtime');
            process.exit(1);
        }
        const ignite = {};
        for (const item in params) {
            if (Object.prototype.hasOwnProperty.call(params, item)) {
                if (item === 'igniteName' || item === 'igniteType') {
                    ignite[item] = params[item] + '.ignite';
                }
                else {
                    // 当参数名和类型不满足条件时会导致点火报错
                    if ((node_vampire_util_1.default.type(params[item]) === 'function' || node_vampire_util_1.default.type(params[item]) === 'asyncfunction') && IGNITE_FUNCTION.includes(item)) {
                        ignite[item] = params[item];
                    }
                }
            }
        }
        ignite.run = async function () {
            const helpUrl = ignite.helpUrl();
            helpUrl ? SimpleLogger_1.simpleLogger.info(`Help url ${helpUrl}`) : '';
            const configs = ignite.coreConfigs();
            try {
                const warmTag = 'Warm up';
                SimpleLogger_1.simpleLogger.info(LogHelper_1.LogHelper.beginBlock(warmTag));
                const warmUpResult = await ignite.warmUp();
                SimpleLogger_1.simpleLogger.info(LogHelper_1.LogHelper.endBlock(warmTag));
                if (!warmUpResult) {
                    return false;
                }
            }
            finally {
                const configTag = 'Print core configs';
                SimpleLogger_1.simpleLogger.info(LogHelper_1.LogHelper.beginBlock(configTag));
                if (configs) {
                    for (const item in configs) {
                        if (Object.prototype.hasOwnProperty.call(configs, item)) {
                            SimpleLogger_1.simpleLogger.info('Config: ' + item + " : " + configs[item]);
                        }
                    }
                }
                SimpleLogger_1.simpleLogger.info(LogHelper_1.LogHelper.endBlock(configTag));
            }
            const selfcheckTag = 'Self-check';
            SimpleLogger_1.simpleLogger.info(LogHelper_1.LogHelper.beginBlock(selfcheckTag));
            let isPass = false;
            try {
                isPass = await ignite.selfCheck();
            }
            catch (err) {
                SimpleLogger_1.simpleLogger.error(selfcheckTag + ' : ' + err);
                isPass = false;
            }
            SimpleLogger_1.simpleLogger.info(LogHelper_1.LogHelper.endBlock(selfcheckTag, ['isPass', isPass]));
            return isPass;
        };
        if (ignite.igniteType && ignite.igniteType.toLowerCase() === 'sdk.ignite') {
            IGNITELIST_SDK.push(ignite);
        }
        else {
            IGNITELIST_APP.push(ignite);
        }
    }
};
const getIgniteList = () => {
    return IGNITELIST_SDK.concat(IGNITELIST_APP);
};
exports.getIgniteList = getIgniteList;
const resetIgniteList = () => {
    IGNITELIST_SDK = [];
    IGNITELIST_APP = [];
};
exports.resetIgniteList = resetIgniteList;
const isEndIgnited = (isEndIgnited) => {
    IS_END_IGNITED = isEndIgnited;
};
exports.isEndIgnited = isEndIgnited;
