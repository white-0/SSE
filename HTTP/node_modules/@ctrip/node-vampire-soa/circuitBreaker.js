const appConfig = require('./appConfig.js');

/*
 *'circuitBreaker.enabled': 'true',// 是否启用熔断策略(如果设置force-open=true，此时设置enabled=false也会拒绝所有请求,设置force-closed=true，此时设置enabled=true也会接收所有请求)
 *'circuitBreaker.execution-count-threshold': '5',// 连续10秒内的请求数如果小于该值，即使全部失败，也不会触发短路
 *'circuitBreaker.error-percentage-threshold': '50',// 触发熔断的错误比例;连续 10 秒内的请求错误比例达到该值，即触发熔断。
 *'circuitBreaker.retry-interval': '5000',// 短路发生后，接下来的配置时间，拒绝所有请求，随后重新尝试
 *'circuitBreaker.execution-timeout': '20000',// 设置熔断的超时时间;如果请求超过此时间会进行计数，连续10s达到阈值会触发熔断(这个参数在soaWebApi中已配置)
 *'circuitBreaker.force-open': 'false', // 是否强制打开熔断;=true将拒绝所有请求
 *'circuitBreaker.force-closed': 'false'// 是否强制关闭CircuitBreaker;=true将接收所有请求，即使已触发熔断条件
 */

class CircuitBreaker {
    constructor() {
        this.state = appConfig['circuitBreaker.closed'];
        this.lastFailureTime = null;
        this.failureCount = 0;
        this.requestCount = 0
    }

    // 设置熔断器的当前状态.
    setStatus() {
        if ((Date.now() - this.lastFailureTime) <= 10000) {
            // 连续10秒内是否达到了熔断条件:错误数大于count-threshold;错误率达到50%
            if (this.failureCount > appConfig['circuitBreaker.execution-count-threshold'] && this.failureCount > appConfig['circuitBreaker.error-percentage-threshold'] * 0.01 * this.requestCount) {
                if ((Date.now() - this.lastFailureTime) > appConfig['circuitBreaker.retry-interval']) {
                    this.state = appConfig['circuitBreaker.half-open'];
                } else {
                    this.state = appConfig['circuitBreaker.open'];
                }
            } else {
                this.state = appConfig['circuitBreaker.closed'];
            }
        } else {
            this.resetStatus();
        }
    }

    //连续10s内没有达到熔断条件重置熔断器状态
    resetStatus() {
        this.failureCount = 0;
        this.requestCount = 0
        this.lastFailureTime = null;
        this.state = appConfig['circuitBreaker.closed'];
    }

    //close状态下，记录总请求数
    recordRequestCount() {
        this.requestCount += 1;
    }

    //close状态下，请求异常时返回结果
    recordFailure() {
        this.failureCount += 1;
        this.lastFailureTime = Date.now();
    }

    /*
     * 1.半闭合状态：
     * 允许执行熔断测试请求，用于检测当前是否已经从熔断状态恢复，如果这个熔断测试请求执行成功且没有超时，那么状态会从半开恢复到闭合状态，否则又会重新进入熔断状态，然后等待下一个熔断时间窗口
     * */
    recordHalfOpenTest() {
        this.lastFailureTime = Date.now();
    }

    openMeassage() {
        // 抛出熔断异常
        return 'circuit breaker open';
    }
}

module.exports = CircuitBreaker;