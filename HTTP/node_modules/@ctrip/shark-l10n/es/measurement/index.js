var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
import { Formatter } from '../base';
import { NumberFormatter } from '../number';
import { KEY_PREFERENCES_MEASUREMENT, KEY_PREFERENCES_TEMPERATURE, ROUNDING_MODE, Unit, UnitCollection } from '../types';
import { FACTOR_MAP } from './factors';
import { SYMBOL, TEMPLATE, TEMPLATE_MAP } from './keys';
var MeasurementFormatter = (function (_super) {
    __extends(MeasurementFormatter, _super);
    function MeasurementFormatter(i18n) {
        var _this = _super.call(this, i18n) || this;
        _this.nf = new NumberFormatter(i18n);
        return _this;
    }
    MeasurementFormatter.prototype.formatString = function (value, type, useGrouping, minimumFractionDigits, maximumFractionDigits, extendOption) {
        if (useGrouping === void 0) { useGrouping = true; }
        if (minimumFractionDigits === void 0) { minimumFractionDigits = 0; }
        if (maximumFractionDigits === void 0) { maximumFractionDigits = 2; }
        if (extendOption === void 0) { extendOption = {
            roundingMode: ROUNDING_MODE.HALF_EVEN,
            trimRedundantZero: true,
        }; }
        return this.convert(value, type, type, useGrouping, minimumFractionDigits, maximumFractionDigits, extendOption);
    };
    MeasurementFormatter.prototype.convert = function (value, fromType, toType, useGrouping, minimumFractionDigits, maximumFractionDigits, extendOption) {
        if (useGrouping === void 0) { useGrouping = true; }
        if (minimumFractionDigits === void 0) { minimumFractionDigits = 0; }
        if (maximumFractionDigits === void 0) { maximumFractionDigits = 2; }
        if (extendOption === void 0) { extendOption = {
            roundingMode: ROUNDING_MODE.HALF_EVEN,
            trimRedundantZero: true,
        }; }
        var template = this.get(TEMPLATE[toType]);
        var symbol = this.get(SYMBOL[toType]);
        if (fromType !== toType) {
            var funcName = "".concat(fromType, "-").concat(toType);
            if (!FACTOR_MAP[funcName]) {
                return '';
            }
            value = FACTOR_MAP[funcName](value);
        }
        var valueStr = this.nf.decimalString(value, useGrouping, minimumFractionDigits, maximumFractionDigits, extendOption);
        return this.format(symbol, valueStr, template);
    };
    MeasurementFormatter.prototype.convertToPreferences = function (value, fromType, preferencesUnit, useGrouping, minimumFractionDigits, maximumFractionDigits, extendOption) {
        if (preferencesUnit === void 0) { preferencesUnit = UnitCollection.Unknown; }
        if (useGrouping === void 0) { useGrouping = true; }
        if (minimumFractionDigits === void 0) { minimumFractionDigits = 0; }
        if (maximumFractionDigits === void 0) { maximumFractionDigits = 2; }
        if (extendOption === void 0) { extendOption = {
            roundingMode: ROUNDING_MODE.HALF_EVEN,
            trimRedundantZero: true,
        }; }
        var toType;
        if (preferencesUnit === UnitCollection.Unknown) {
            preferencesUnit = this.getDefaultPreferences('measurement');
        }
        switch (fromType) {
            case Unit.Kilometer:
            case Unit.Mile:
                toType = preferencesUnit === UnitCollection.MetricUnit
                    ? Unit.Kilometer
                    : Unit.Mile;
                break;
            case Unit.Meter:
            case Unit.Feet:
                toType = preferencesUnit === UnitCollection.MetricUnit
                    ? Unit.Meter
                    : Unit.Feet;
                break;
            case Unit.Centimeter:
            case Unit.Inch:
                toType = preferencesUnit === UnitCollection.MetricUnit
                    ? Unit.Centimeter
                    : Unit.Inch;
                break;
            case Unit.Celsius:
            case Unit.Fahrenheit:
                toType = this.getDefaultPreferences('temperature') || Unit.Celsius;
                break;
            case Unit.SquareMeter:
            case Unit.SquareFeet:
                toType = preferencesUnit === UnitCollection.MetricUnit
                    ? Unit.SquareMeter
                    : Unit.SquareFeet;
                break;
            case Unit.Kilogram:
            case Unit.Pound:
                toType = preferencesUnit === UnitCollection.MetricUnit
                    ? Unit.Kilogram
                    : Unit.Pound;
                break;
            default:
                toType = fromType;
        }
        return this.convert(value, fromType, toType, useGrouping, minimumFractionDigits, maximumFractionDigits, extendOption);
    };
    MeasurementFormatter.prototype.getDefaultPreferences = function (unitType) {
        if (unitType === 'measurement') {
            return this.get(KEY_PREFERENCES_MEASUREMENT, 'Metric') === 'Metric' ?
                UnitCollection.MetricUnit :
                UnitCollection.ImperialUnit;
        }
        return this.get(KEY_PREFERENCES_TEMPERATURE, 'Celsius') === 'Fahreheit' ?
            Unit.Fahrenheit : Unit.Celsius;
    };
    MeasurementFormatter.prototype.format = function (symbol, value, template) {
        if (TEMPLATE_MAP[template]) {
            return TEMPLATE_MAP[template](symbol, value);
        }
        return "".concat(value, " ").concat(symbol);
    };
    return MeasurementFormatter;
}(Formatter));
export { MeasurementFormatter };
