"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.MeasurementFormatter = void 0;
var base_1 = require("../base");
var number_1 = require("../number");
var types_1 = require("../types");
var factors_1 = require("./factors");
var keys_1 = require("./keys");
var MeasurementFormatter = (function (_super) {
    __extends(MeasurementFormatter, _super);
    function MeasurementFormatter(i18n) {
        var _this = _super.call(this, i18n) || this;
        _this.nf = new number_1.NumberFormatter(i18n);
        return _this;
    }
    MeasurementFormatter.prototype.formatString = function (value, type, useGrouping, minimumFractionDigits, maximumFractionDigits, extendOption) {
        if (useGrouping === void 0) { useGrouping = true; }
        if (minimumFractionDigits === void 0) { minimumFractionDigits = 0; }
        if (maximumFractionDigits === void 0) { maximumFractionDigits = 2; }
        if (extendOption === void 0) { extendOption = {
            roundingMode: types_1.ROUNDING_MODE.HALF_EVEN,
            trimRedundantZero: true,
        }; }
        return this.convert(value, type, type, useGrouping, minimumFractionDigits, maximumFractionDigits, extendOption);
    };
    MeasurementFormatter.prototype.convert = function (value, fromType, toType, useGrouping, minimumFractionDigits, maximumFractionDigits, extendOption) {
        if (useGrouping === void 0) { useGrouping = true; }
        if (minimumFractionDigits === void 0) { minimumFractionDigits = 0; }
        if (maximumFractionDigits === void 0) { maximumFractionDigits = 2; }
        if (extendOption === void 0) { extendOption = {
            roundingMode: types_1.ROUNDING_MODE.HALF_EVEN,
            trimRedundantZero: true,
        }; }
        var template = this.get(keys_1.TEMPLATE[toType]);
        var symbol = this.get(keys_1.SYMBOL[toType]);
        if (fromType !== toType) {
            var funcName = "".concat(fromType, "-").concat(toType);
            if (!factors_1.FACTOR_MAP[funcName]) {
                return '';
            }
            value = factors_1.FACTOR_MAP[funcName](value);
        }
        var valueStr = this.nf.decimalString(value, useGrouping, minimumFractionDigits, maximumFractionDigits, extendOption);
        return this.format(symbol, valueStr, template);
    };
    MeasurementFormatter.prototype.convertToPreferences = function (value, fromType, preferencesUnit, useGrouping, minimumFractionDigits, maximumFractionDigits, extendOption) {
        if (preferencesUnit === void 0) { preferencesUnit = types_1.UnitCollection.Unknown; }
        if (useGrouping === void 0) { useGrouping = true; }
        if (minimumFractionDigits === void 0) { minimumFractionDigits = 0; }
        if (maximumFractionDigits === void 0) { maximumFractionDigits = 2; }
        if (extendOption === void 0) { extendOption = {
            roundingMode: types_1.ROUNDING_MODE.HALF_EVEN,
            trimRedundantZero: true,
        }; }
        var toType;
        if (preferencesUnit === types_1.UnitCollection.Unknown) {
            preferencesUnit = this.getDefaultPreferences('measurement');
        }
        switch (fromType) {
            case types_1.Unit.Kilometer:
            case types_1.Unit.Mile:
                toType = preferencesUnit === types_1.UnitCollection.MetricUnit
                    ? types_1.Unit.Kilometer
                    : types_1.Unit.Mile;
                break;
            case types_1.Unit.Meter:
            case types_1.Unit.Feet:
                toType = preferencesUnit === types_1.UnitCollection.MetricUnit
                    ? types_1.Unit.Meter
                    : types_1.Unit.Feet;
                break;
            case types_1.Unit.Centimeter:
            case types_1.Unit.Inch:
                toType = preferencesUnit === types_1.UnitCollection.MetricUnit
                    ? types_1.Unit.Centimeter
                    : types_1.Unit.Inch;
                break;
            case types_1.Unit.Celsius:
            case types_1.Unit.Fahrenheit:
                toType = this.getDefaultPreferences('temperature') || types_1.Unit.Celsius;
                break;
            case types_1.Unit.SquareMeter:
            case types_1.Unit.SquareFeet:
                toType = preferencesUnit === types_1.UnitCollection.MetricUnit
                    ? types_1.Unit.SquareMeter
                    : types_1.Unit.SquareFeet;
                break;
            case types_1.Unit.Kilogram:
            case types_1.Unit.Pound:
                toType = preferencesUnit === types_1.UnitCollection.MetricUnit
                    ? types_1.Unit.Kilogram
                    : types_1.Unit.Pound;
                break;
            default:
                toType = fromType;
        }
        return this.convert(value, fromType, toType, useGrouping, minimumFractionDigits, maximumFractionDigits, extendOption);
    };
    MeasurementFormatter.prototype.getDefaultPreferences = function (unitType) {
        if (unitType === 'measurement') {
            return this.get(types_1.KEY_PREFERENCES_MEASUREMENT, 'Metric') === 'Metric' ?
                types_1.UnitCollection.MetricUnit :
                types_1.UnitCollection.ImperialUnit;
        }
        return this.get(types_1.KEY_PREFERENCES_TEMPERATURE, 'Celsius') === 'Fahreheit' ?
            types_1.Unit.Fahrenheit : types_1.Unit.Celsius;
    };
    MeasurementFormatter.prototype.format = function (symbol, value, template) {
        if (keys_1.TEMPLATE_MAP[template]) {
            return keys_1.TEMPLATE_MAP[template](symbol, value);
        }
        return "".concat(value, " ").concat(symbol);
    };
    return MeasurementFormatter;
}(base_1.Formatter));
exports.MeasurementFormatter = MeasurementFormatter;
