import * as CloudRpc from '@ctrip/cloud-rpc';
import * as SoaVampireExport from '@ctrip/node-vampire-soa';
import * as SoaDirectVampireExport from '@ctrip/node-vampire-soa-client';
import { QueryObject } from './shared/utils';
export declare type CloudRpcExportType = typeof CloudRpc;
export declare type SoaVampireExportType = typeof SoaVampireExport;
export declare type SoaDirectVampireExportType = typeof SoaDirectVampireExport;
export declare type UniversalRPCType = InstanceType<CloudRpcExportType['default']>;
export declare type SoaAgentType = ReturnType<SoaVampireExportType['SoaAgent']>;
export declare type SoaDirectAgentType = InstanceType<SoaDirectVampireExportType['SoaDirectApi']>;
export declare type AcceptDataTypes = 'script' | 'json' | 'document' | 'text' | 'arraybuffer' | 'blob';
export declare type RequestPromise<T> = AbortablePromise<T>;
export declare type AbortablePromise<T> = Promise<T> & {
    abort(): void;
};
export interface CacheOptions {
}
export interface RequestOptions<T extends any = any> {
    url: string;
    method?: RequestMethod;
    data?: any;
    headers?: {
        [key: string]: string;
    };
    params?: {
        [key: string]: any;
    };
    contentType?: string;
    dataType?: AcceptDataTypes;
    timeout?: number;
    withCredentials?: boolean;
    cache?: boolean | CacheOptions;
    trackError?: boolean;
    transformResponse?: (responseData: T, response: ResponseObject) => any;
}
export interface ResponseObject {
    headers: Record<string, string>;
}
export declare type RequestMethod = 'GET' | 'POST' | 'PUT' | 'DELETE' | 'OPTIONS';
export interface RequestFn {
    <T = any>(option: RequestOptions<T>): RequestPromise<T>;
}
export interface RequestStatic extends RequestFn {
    get<T = any>(url: string, opt?: Omit<RequestOptions, 'url'>): Promise<T>;
    post<T = any>(url: string, data?: any, opt?: Omit<RequestOptions, 'url' | 'data'>): Promise<T>;
    put<T = any>(url: string, data?: any, opt?: Omit<RequestOptions, 'url' | 'data'>): Promise<T>;
}
export interface JsonpOptions {
    callbackKey?: string;
    useAjax?: boolean;
    timeout?: number;
}
/** Soa */
export declare type SoaAgentModel = Record<string, [any, any]>;
export declare type IsAny<D extends any, T, F = D> = (any extends D ? true : false) extends true ? T : F;
export declare type IsNever<D extends any, T, F = D> = [D] extends [never] ? T : F;
export declare type FindSoaRequestBody<D extends SoaAgentModel = {}> = {
    [K in keyof D]: IsNever<keyof D[K][0], never, D[K][0]>;
};
export declare type FindSoaHeadKey<D extends SoaAgentModel = {}> = IsNever<keyof FindSoaRequestBody<D>, null>;
declare type GetParamType<R extends Record<string, any>, K extends any> = K extends keyof R ? R[K] : never;
declare type FindSoaMethodCommonHeadType<M extends SoaAgentModel, HeadKey extends string> = {
    [K in keyof M]: GetParamType<M[K][0], HeadKey>;
}[keyof M];
export declare type FindSoaHeadType<M extends SoaAgentModel = {}, HeadKey extends string | null = null> = HeadKey extends string ? IsNever<FindSoaMethodCommonHeadType<M, HeadKey>, any> : Record<string, any>;
export interface CreateSoaAgentOption<M extends SoaAgentModel = {}, HK extends string | null = null> {
    useDirectConnection?: boolean;
    serviceName?: string;
    soaOptions?: Record<string, any>;
    headKey?: HK extends null ? string | null : string;
    getHead?: (data?: any) => FindSoaHeadType<M, HK>;
    getRequestURL?: (serviceCode: string | number, method: string) => string;
    invalidResponse?(response: SoaResponse<{}>, method: string, params: any, opt: SoaAgentInvokeOptions, detail: {
        serviceCode: string;
    }): undefined | void | never;
    _cacheKey?: string;
}
export interface CreateSoaAgentFn {
    <M extends SoaAgentModel = {
        [method: string]: [any, any];
    }, D = any, HK extends string | null = null>(serviceCode: string | number, opt?: CreateSoaAgentOption<M, HK>): SoaAgent<M, D, HK>;
}
export interface SoaResponseStatusExtension {
    Id: string;
    Value: string;
    id: string;
    value: string;
    [key: string]: any;
}
export declare type SoaResponseStatusAck = 'Success' | 'Failure' | 'Warning' | 'PartialFailure';
export interface SoaResponseStatus {
    Timestamp?: string | number;
    Ack?: SoaResponseStatusAck;
    Errors?: any[];
    Extension?: SoaResponseStatusExtension[];
    timestamp?: string | number;
    ack?: SoaResponseStatusAck;
    errors?: any[];
    extension?: SoaResponseStatusExtension[];
    [key: string]: any;
}
export interface SoaResponseHead {
    Code?: string;
    Message?: string;
    Timestamp?: string | number;
    code?: string;
    message?: string;
    timestamp?: string | number;
    [key: string]: any;
}
export declare type SoaResponse<T = {}> = T & {
    ResponseStatus?: SoaResponseStatus;
    responseStatus?: SoaResponseStatus;
    ResponseStatusType?: SoaResponseStatus;
    responseHead?: SoaResponseHead;
    ResponseHead?: SoaResponseHead;
    'SOA.ResponseHeaders'?: Record<string, string>;
};
export interface MessageTraceID {
    CLOGGING_TRACE_ID?: string;
    RootMessageId?: string;
}
export interface SoaAgentInvokeOptions<M extends SoaAgentModel = {}, HeadKey extends string | null = null> {
    query?: QueryObject;
    timeout?: number;
    headers?: Record<string, string>;
    head?: FindSoaHeadType<M, HeadKey>;
    responseIncludeHeaders?: boolean;
}
export interface SoaAgent<M extends SoaAgentModel = SoaAgentModel, D = any, HeadKey extends string | null = null> {
    <K extends keyof M>(method: K, params?: IsAny<M[K][0], Record<string, any>>, opt?: SoaAgentInvokeOptions<M, HeadKey>): AbortablePromise<M[K][1]>;
    _data: Partial<D>;
    setData(data: Partial<D>): void;
    getData(): Partial<D>;
}
export {};
