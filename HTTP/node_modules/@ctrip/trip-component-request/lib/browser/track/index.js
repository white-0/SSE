"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.trackAjax = trackAjax;
exports.trackAjaxFail = trackAjaxFail;
exports.trackAjaxSuccess = trackAjaxSuccess;
var _metric = require("./metric");
var _constant = require("./constant");
var _errors = require("../../shared/errors");
var _constant2 = require("../constant");
var _trace = require("../../shared/trace");
var _utils = require("../utils");
// @see https://developer.mozilla.org/en-US/docs/Web/API/Performance/getEntriesByType
// @see https://developer.mozilla.org/en-US/docs/Web/API/Performance/getEntriesByName
function getEntries(url) {
  if (typeof performance.getEntriesByName === 'function') {
    return performance.getEntriesByName(url);
  } else if (typeof performance.getEntriesByType === 'function') {
    return performance.getEntriesByType('resource');
  }
  return [];
}
function findResourcePerfEntry(url) {
  var entries = getEntries(url);
  var targetEntry = null;
  var latestTimestamp = -1;
  for (var index = entries.length - 1; index >= 0; index--) {
    var entry = entries[index];
    // if is "xhr request" or "fetch"
    if (entry.initiatorType === _constant.XHR_INITIATOR_TYPE || entry.initiatorType === _constant.FETCH_INITIATOR_TYPE) {
      // if match target url
      if (entry.name === url) {
        // find latest entry
        if (entry.responseEnd > latestTimestamp) {
          latestTimestamp = entry.responseEnd;
          targetEntry = entry;
        }
      }
    }
  }
  return targetEntry;
}
function trackAjaxFail(error, detail, _xhr) {
  try {
    (0, _metric.trackAjaxError)((0, _errors.createRequestError)((0, _utils.transformEventToError)(error), detail));
  } catch (error) {
    console.warn('[track ajax] fail:', error);
  }
}
function trackAjaxSuccess(response, _ref, xhr) {
  var url = _ref.url,
    responseHeaders = _ref.responseHeaders;
  try {
    var realUrl = getCompleteUrl(url);
    var entry = findResourcePerfEntry(realUrl);
    if (!entry) {
      throw new Error("[track ajax] can't find ResourceTiming, url \"".concat(realUrl, "\" may not correct"));
    }
    var ids = (0, _trace.findMessageTraceId)(response);
    var region = responseHeaders && responseHeaders[_constant.REGION_HTTP_HEADER] || xhr && xhr.getResponseHeader(_constant.REGION_HTTP_HEADER) || '';
    var xOriginUrl = responseHeaders && responseHeaders[_constant.ORIGINATING_URL_HEADER] || xhr && xhr.getResponseHeader(_constant.ORIGINATING_URL_HEADER) || '';
    var akRegion = (0, _utils.parseXOriginUrlToAkRegion)(xOriginUrl) || '';
    var xIbuTripRegion = responseHeaders && responseHeaders[_constant.IBU_TRIP_REGION] || xhr && xhr.getResponseHeader(_constant.IBU_TRIP_REGION) || '';
    return (0, _metric.trackAjaxTiming)(entry, {
      region: region,
      'ak-region': akRegion,
      xIbuTripRegion: xIbuTripRegion
    }, ids);
  } catch (error) {
    console.warn('[track ajax] fail:', error);
    return Promise.resolve(-1);
  }
}
function trackAjax(xhr, url) {
  return new Promise(function (resolve, reject) {
    var done = function done() {
      resolve(trackAjaxSuccess({}, {
        url: url
      }, xhr));
    };
    if (xhr.readyState === _constant2.XHR_DONE) {
      return done();
    }
    var handleError = function handleError(e) {
      trackAjaxFail(e, {
        url: url
      }, xhr);
      reject(e);
    };
    var handleReadyChange = function handleReadyChange() {
      if (xhr.readyState === _constant2.XHR_DONE) {
        done();
      }
    };
    xhr.addEventListener('error', handleError);
    xhr.addEventListener('timeout', handleError);
    xhr.addEventListener('abort', handleError);
    xhr.addEventListener('readystatechange', handleReadyChange);
  });
}
function getCompleteUrl(origin) {
  var link = '';
  var _window$location = window.location,
    protocol = _window$location.protocol,
    host = _window$location.host;
  if (!origin) {
    return '';
  } else if (/^http/.test(origin)) {
    link = origin;
  } else if (/^\/\//.test(origin)) {
    link = protocol + origin;
  } else if (/^\//.test(origin)) {
    link = protocol + '//' + host + origin;
  } else {
    link = protocol + '//' + origin;
  }
  return link;
}