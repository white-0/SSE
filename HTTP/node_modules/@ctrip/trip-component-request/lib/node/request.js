"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.request = void 0;
const axios_1 = __importDefault(require("axios"));
const helper_1 = require("../helper");
const errors_1 = require("../shared/errors");
const shared_1 = require("../shared");
const default_error_handler_1 = require("../shared/default-error-handler");
const ABORT_MESSAGE = 'request abort by user';
const _request = (opt) => {
    const { dataType, contentType, headers = {}, params } = opt;
    const tokenSource = axios_1.default.CancelToken.source();
    if (contentType) {
        headers['Content-Type'] = contentType;
    }
    const axiosOptions = {
        url: opt.url,
        method: opt.method,
        data: opt.data,
        responseType: dataType === 'script' ? 'text' : dataType,
        timeout: opt.timeout,
        headers,
        cancelToken: tokenSource.token,
        params,
    };
    const promise = axios_1.default(axiosOptions).then(res => {
        if (shared_1.validStatus(res.status)) {
            return res.data;
        }
        const err = new Error(`response ${opt.url} status ${res.status} is not correct`);
        const requestError = errors_1.createRequestError(err, opt, res);
        throw requestError;
    }, (err) => {
        let realError = err;
        // for timeout error
        if (err.message.indexOf('timeout') > -1) {
            realError = new errors_1.TimeoutError(opt.timeout || 0, err.stack);
        }
        else if (err.message === ABORT_MESSAGE) {
            realError = errors_1.AbortError.MANUAL_ABORT_ERROR();
        }
        const requestError = errors_1.createRequestError(realError, opt);
        if (default_error_handler_1.defaultErrorHandler) {
            default_error_handler_1.defaultErrorHandler(requestError);
        }
        else {
            throw requestError;
        }
    });
    promise.abort = () => {
        tokenSource.cancel(ABORT_MESSAGE);
    };
    return promise;
};
const request = helper_1.bindRequestMethods(_request);
exports.request = request;
//# sourceMappingURL=request.js.map