import { trackAjaxTiming, trackAjaxError } from './metric';
import { XHR_INITIATOR_TYPE, REGION_HTTP_HEADER, FETCH_INITIATOR_TYPE, ORIGINATING_URL_HEADER, IBU_TRIP_REGION } from './constant';
import { createRequestError } from '../../shared/errors';
import { XHR_DONE } from '../constant';
import { findMessageTraceId } from '../../shared/trace';
import { parseXOriginUrlToAkRegion, transformEventToError } from '../utils';
// @see https://developer.mozilla.org/en-US/docs/Web/API/Performance/getEntriesByType
// @see https://developer.mozilla.org/en-US/docs/Web/API/Performance/getEntriesByName
function getEntries(url) {
  if (typeof performance.getEntriesByName === 'function') {
    return performance.getEntriesByName(url);
  } else if (typeof performance.getEntriesByType === 'function') {
    return performance.getEntriesByType('resource');
  }
  return [];
}
function findResourcePerfEntry(url) {
  var entries = getEntries(url);
  var targetEntry = null;
  var latestTimestamp = -1;
  for (var index = entries.length - 1; index >= 0; index--) {
    var entry = entries[index];
    // if is "xhr request" or "fetch"
    if (entry.initiatorType === XHR_INITIATOR_TYPE || entry.initiatorType === FETCH_INITIATOR_TYPE) {
      // if match target url
      if (entry.name === url) {
        // find latest entry
        if (entry.responseEnd > latestTimestamp) {
          latestTimestamp = entry.responseEnd;
          targetEntry = entry;
        }
      }
    }
  }
  return targetEntry;
}
export function trackAjaxFail(error, detail, _xhr) {
  try {
    trackAjaxError(createRequestError(transformEventToError(error), detail));
  } catch (error) {
    console.warn('[track ajax] fail:', error);
  }
}
export function trackAjaxSuccess(response, _ref, xhr) {
  var url = _ref.url,
    responseHeaders = _ref.responseHeaders;
  try {
    var realUrl = getCompleteUrl(url);
    var entry = findResourcePerfEntry(realUrl);
    if (!entry) {
      throw new Error("[track ajax] can't find ResourceTiming, url \"".concat(realUrl, "\" may not correct"));
    }
    var ids = findMessageTraceId(response);
    var region = responseHeaders && responseHeaders[REGION_HTTP_HEADER] || xhr && xhr.getResponseHeader(REGION_HTTP_HEADER) || '';
    var xOriginUrl = responseHeaders && responseHeaders[ORIGINATING_URL_HEADER] || xhr && xhr.getResponseHeader(ORIGINATING_URL_HEADER) || '';
    var akRegion = parseXOriginUrlToAkRegion(xOriginUrl) || '';
    var xIbuTripRegion = responseHeaders && responseHeaders[IBU_TRIP_REGION] || xhr && xhr.getResponseHeader(IBU_TRIP_REGION) || '';
    return trackAjaxTiming(entry, {
      region: region,
      'ak-region': akRegion,
      xIbuTripRegion: xIbuTripRegion
    }, ids);
  } catch (error) {
    console.warn('[track ajax] fail:', error);
    return Promise.resolve(-1);
  }
}
export function trackAjax(xhr, url) {
  return new Promise(function (resolve, reject) {
    var done = function done() {
      resolve(trackAjaxSuccess({}, {
        url: url
      }, xhr));
    };
    if (xhr.readyState === XHR_DONE) {
      return done();
    }
    var handleError = function handleError(e) {
      trackAjaxFail(e, {
        url: url
      }, xhr);
      reject(e);
    };
    var handleReadyChange = function handleReadyChange() {
      if (xhr.readyState === XHR_DONE) {
        done();
      }
    };
    xhr.addEventListener('error', handleError);
    xhr.addEventListener('timeout', handleError);
    xhr.addEventListener('abort', handleError);
    xhr.addEventListener('readystatechange', handleReadyChange);
  });
}
function getCompleteUrl(origin) {
  var link = '';
  var _window$location = window.location,
    protocol = _window$location.protocol,
    host = _window$location.host;
  if (!origin) {
    return '';
  } else if (/^http/.test(origin)) {
    link = origin;
  } else if (/^\/\//.test(origin)) {
    link = protocol + origin;
  } else if (/^\//.test(origin)) {
    link = protocol + '//' + host + origin;
  } else {
    link = protocol + '//' + origin;
  }
  return link;
}