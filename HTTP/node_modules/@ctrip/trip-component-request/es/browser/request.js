function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
import { getCookie } from '@ctrip/trip-component-utils/lib/browser/cookie';
import CargoBrowser from '@ctrip/cargo-nodejs/browser';
import { MIME_TYPE } from '../shared/constant';
import { buildQuery, validStatus, isAbortable } from '../shared/utils';
import { CacheManager } from '../shared/cache';
import { trackAjaxFail, trackAjaxSuccess } from './track';
import { bindRequestMethods } from '../helper';
import { createRequestError, TimeoutError, AbortError } from '../shared/errors';
import { XHR_DONE, SUB_ENV_KEY, SUB_ENV_QUERY_NAME, DEV_FORCE_HOST_KEY, HEADER_LOCALE, HEADER_CURRENCY, TRACE_ID, TRIP_TRACE_ID } from './constant';
import { defaultErrorHandler } from '../shared/default-error-handler';
import { transformEventToError } from './utils';
var WIN_KEY = '__TRIP_COMPONENT_REQUEST_CACHE__';
var cacheManager = window[WIN_KEY] = window[WIN_KEY] || new CacheManager();
function noop() {}
function getRandom(n) {
  return parseInt("".concat((Math.random() + 1) * Math.pow(10, n - 1)));
}
function getVid() {
  var ubtInfo = (getCookie('_bfa') || '').split('.');
  return ubtInfo[1] && ubtInfo[2] ? "".concat(ubtInfo[1], ".").concat(ubtInfo[2]) : '';
}
function getSubEnv() {
  try {
    if ((typeof localStorage === "undefined" ? "undefined" : _typeof(localStorage)) === 'object' && !!window.localStorage && typeof localStorage.getItem === 'function') {
      return window.localStorage.getItem(SUB_ENV_KEY);
    }
  } catch (err) {
    return null;
  }
}
function getForceHost() {
  try {
    return getCookie(DEV_FORCE_HOST_KEY);
  } catch (err) {
    return null;
  }
}
function isDevOrFat() {
  var host = window.location.host;
  return host.indexOf('.qa.nt') > -1 || host.indexOf('localhost') > -1;
}
function getResponseDataType(header) {
  if (!header) {
    return;
  }
  var mime = header.split(';', 1)[0];
  return MIME_TYPE[mime];
}
function trim(str) {
  return str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '');
}
function getResponseHeaders(xhr) {
  var headers = xhr.getAllResponseHeaders();
  var arr = trim(headers).split(/[\r\n]+/);
  var headerMap = {};
  arr.forEach(function (line) {
    var parts = line.split(': ');
    var header = parts.shift();
    var value = parts.join(': ');
    if (header) {
      headerMap[header] = value;
    }
  });
  return headerMap;
}
var decodeResponse = function decodeResponse(xhr, dataType) {
  var response;
  if (xhr.responseType === 'arraybuffer' || xhr.responseType === 'blob') {
    response = xhr.response;
  } else {
    response = xhr.responseText;
    var responseDataType = dataType || getResponseDataType(xhr.getResponseHeader('content-type'));
    if (responseDataType === 'script') {
      // tslint:disable-next-line: no-eval
      eval(response);
    } else if (responseDataType === 'json') {
      response = trim(response) === '' ? null : JSON.parse(response);
    }
  }
  return response;
};
export function _ajax(options) {
  var url = options.url,
    _options$method = options.method,
    method = _options$method === void 0 ? 'GET' : _options$method,
    params = options.params;
  var _options$data = options.data,
    data = _options$data === void 0 ? null : _options$data,
    _options$contentType = options.contentType,
    contentType = _options$contentType === void 0 ? null : _options$contentType,
    _options$dataType = options.dataType,
    dataType = _options$dataType === void 0 ? null : _options$dataType,
    _options$__success = options.__success,
    success = _options$__success === void 0 ? noop : _options$__success,
    _options$__error = options.__error,
    error = _options$__error === void 0 ? noop : _options$__error,
    _options$timeout = options.timeout,
    timeout = _options$timeout === void 0 ? 0 : _options$timeout,
    withCredentials = options.withCredentials,
    _options$headers = options.headers,
    headers = _options$headers === void 0 ? {} : _options$headers;
  method = method.toUpperCase();
  params = params || {};
  var xhr = new XMLHttpRequest();
  var isDevOrFatEnv = isDevOrFat();
  var protocol = /^([\w-]+:)\/\//.test(url) ? RegExp.$1 : window.location.protocol;
  var hasDone = false;
  var done = function done(errOrEvent, responseData) {
    if (hasDone) {
      return;
    }
    if (errOrEvent) {
      var requestError = createRequestError(transformEventToError(errOrEvent), options, {
        status: xhr.status,
        statusText: xhr.statusText,
        data: xhr.responseText || xhr.response,
        headers: getResponseHeaders(xhr)
      });
      error(requestError, xhr);
    } else {
      var _result = {
        url: url,
        response: responseData,
        xhr: xhr
      };
      success(_result, xhr);
    }
    hasDone = true;
  };
  var handleLoad = function handleLoad() {
    if (validStatus(xhr.status, protocol)) {
      try {
        var response = decodeResponse(xhr, dataType);
        done(null, response);
      } catch (e) {
        done(e);
      }
    } else {
      var _err = new Error("url \"".concat(url, "\" response status \"").concat(xhr.status, "\" is not correct"));
      done(_err);
    }
  };
  var handleError = function handleError(e) {
    // console.log('handle error: ', e);
    done(e);
  };
  var handleReadyChange = function onreadystatechange() {
    if (xhr.readyState === XHR_DONE) {
      xhr.onreadystatechange = noop;
      // xhr emit "readystatechange" event before "error" event or "load" event
      // wait other event(like: "error", "load") emitted, handle this event in next tick
      // ie not support "load" event, @see https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/load_event
      setTimeout(function () {
        if (!hasDone) {
          handleLoad();
        }
      }, 0);
    }
  };
  if (isDevOrFatEnv) {
    // in fat env && exist forceHost in cookies
    var forceHost = getForceHost();
    if (forceHost) {
      try {
        var base = /^[\w-]+:\/\//.test(forceHost) ? forceHost : "".concat(protocol, "//").concat(forceHost);
        url = new URL(url, base).href;
      } catch (e) {
        console.error(e);
      }
    }

    // if exist subEnv in localStorage and in fat env
    var subEnv = getSubEnv();
    if (subEnv) {
      params[SUB_ENV_QUERY_NAME] = subEnv;
    }
  }
  var traceId = "".concat(getVid() || getRandom(10), "-").concat(new Date().getTime(), "-").concat(getRandom(10));
  params[TRACE_ID] = traceId;
  if (params) {
    url += (url.indexOf('?') > -1 ? '&' : '?') + buildQuery(params);
  }
  xhr.onreadystatechange = handleReadyChange;
  xhr.onload = handleLoad;
  xhr.onerror = function (e) {
    return handleError(e);
  };
  xhr.ontimeout = function () {
    return handleError(new TimeoutError(timeout));
  };
  xhr.onabort = function () {
    // mark user manual abort error
    if (xhr.__abortByUser) {
      handleError(AbortError.MANUAL_ABORT_ERROR());
    } else {
      handleError(new AbortError());
    }
  };
  xhr.open(method, url, true, null, null);
  var locale = CargoBrowser.getLocale();
  var currency = CargoBrowser.getCurrency();
  if (locale) xhr.setRequestHeader(HEADER_LOCALE, locale);
  if (currency) xhr.setRequestHeader(HEADER_CURRENCY, currency);
  xhr.setRequestHeader(TRACE_ID, traceId);
  xhr.setRequestHeader(TRIP_TRACE_ID, traceId);
  for (var _i = 0, _Object$keys = Object.keys(headers); _i < _Object$keys.length; _i++) {
    var headerName = _Object$keys[_i];
    var headerValue = headers[headerName];
    xhr.setRequestHeader(headerName, headerValue);
  }
  if (method === 'POST' && !headers['Content-Type']) {
    xhr.setRequestHeader('Content-Type', contentType || 'application/json');
  }
  if (timeout > 0) {
    xhr.timeout = timeout;
  }
  if (withCredentials) {
    xhr.withCredentials = true;
  }
  xhr.send(data && method !== 'GET' ? JSON.stringify(data) : null);
  return xhr;
}
var _request = function _request(opt) {
  if (opt.cache) {
    var cacheResult = cacheManager.get(opt);
    if (cacheResult && isAbortable(cacheResult)) {
      return cacheResult;
    }
  }
  var _xhr;
  var promise = new Promise(function (resolve, reject) {
    var options = opt;
    options.__success = resolve;
    options.__error = reject;
    _xhr = _ajax(options);
  });
  var requestPromise = promise.then(function (result) {
    var response = result.response,
      url = result.url,
      xhr = result.xhr;
    trackAjaxSuccess(response, {
      url: url
    }, xhr);
    if (typeof opt.transformResponse === 'function') {
      try {
        return opt.transformResponse(response, {
          headers: getResponseHeaders(xhr)
        });
      } catch (error) {
        return response;
      }
    }
    return response;
  }).catch(function (err) {
    var requestError = createRequestError(err, opt);
    if (opt.trackError !== false) {
      trackAjaxFail(err, opt, _xhr);
    }
    if (defaultErrorHandler) {
      defaultErrorHandler(requestError);
    } else {
      throw requestError;
    }
  });
  requestPromise.abort = function () {
    if (_xhr) {
      _xhr.__abortByUser = true;
      _xhr.abort();
    }
  };
  Object.defineProperty(requestPromise, '_xhr', {
    get: function get() {
      return _xhr;
    }
  });
  if (opt.cache) {
    cacheManager.add(opt, requestPromise);
  }
  return requestPromise;
};
var request = bindRequestMethods(_request);
export { request };