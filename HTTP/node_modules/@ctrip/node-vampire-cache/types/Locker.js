const appConfig = require('@ctrip/node-vampire-appconfig');
const cache = require('../libs/cache.js');
const Cache = cache.Cache;

const LOCKER_NAME_PREFIX = 'L';
const LOCKER_EXPIRE_PREFIX = 'E';
const DEFAULT_LOCK_TIMEOUT = 30000;
const DEFAULT_RUN_TIMEOUT = 10000;
const DEFAULT_LOCK_SYNC_TIMEOUT = 3000;
const DEFAULT_RUN_SYNC_TIMEOUT = 1000;
const DEFAULT_UNLOCK_TIMEOUT = 200;
const DEFAULT_UNLOCK_RECOVER_TIMEOUT = 220;

let lockerMap = {};

function Locker(name, appIsolated, seq) {
	if (!/^\w+$/.test(name)) {
		throw new Error('Invalid Locker Name');
	}
	this.appIsolated = !!appIsolated;
	this.cacheName = 'node-vampire-cache-locker' + (this.appIsolated ? '-' + appConfig['AppID'] : '');
	if (Object.prototype.hasOwnProperty.call(lockerMap, this.cacheName)) {
		this.store = lockerMap[this.cacheName];
	} else {
		this.store = new Cache(this.cacheName, 5 * 1024 * 1024);
	}
	this.seq = seq || 0;
	this.name = name;
	this.key = LOCKER_NAME_PREFIX + '-' + this.name + '-' + this.seq;
	this.expireKey = LOCKER_EXPIRE_PREFIX + '-' + this.name + '-' + this.seq;
}

Locker.prototype.run = function (transaction, callback, opts) {
	opts = opts || {};
	let lockTimeout = opts.lockTimeout || DEFAULT_LOCK_TIMEOUT;
	let runTimeout = opts.runTimeout || DEFAULT_RUN_TIMEOUT;
	let start = opts.start || +new Date();
	let hasLocked = false;
	let t = cache.exchange(this.store, this.key, 1);
	if (t) {
		let ts = +new Date();
		let expireTs = this.store[this.expireKey];
		if (expireTs && expireTs < ts || !expireTs && ts - start > DEFAULT_RUN_SYNC_TIMEOUT) {
			this.unlock();
		}
		if (ts - start > lockTimeout) {
			callback && callback('Locker Timeout');
		} else {
			setImmediate(() => {
				this.run(transaction, callback, opts);
			});
		}
	} else {
		let expire = this.store[this.expireKey] = +new Date() + runTimeout;
		hasLocked = true;

		let done = (err) => {
			if (hasLocked) {
				hasLocked = false;
				clearTimeout(clock);
				this.store[this.expireKey] = +new Date() + DEFAULT_RUN_SYNC_TIMEOUT;
				delete this.store[this.key];
				callback && process.nextTick(callback, err);
			}
		};

		let locked = () => {
			if (hasLocked && +new Date() < expire) {
				done();
			}
			return hasLocked;
		};

		let clock = setTimeout(() => {
			hasLocked = false;
			this.unlock(function () {
				callback && callback('Locker Run Timeout');
			});
		}, DEFAULT_RUN_SYNC_TIMEOUT);

		try {
			transaction(done, locked);
			if (!transaction.length) {
				done();
			}
		} catch (e) {
			done(e);
			throw e;
		}
	}
};

Locker.prototype.runSync = function (transaction, opts) {
	opts = opts || {};
	let lockTimeout = opts.lockTimeout || DEFAULT_LOCK_SYNC_TIMEOUT;
	let runTimeout = opts.runTimeout || DEFAULT_RUN_SYNC_TIMEOUT;
	let start = +new Date();
	while (cache.exchange(this.store, this.key, 1)) {
		let ts = +new Date();
		let expireTs = this.store[this.expireKey];
		if (expireTs && expireTs < ts || !expireTs && ts - start > DEFAULT_RUN_SYNC_TIMEOUT) {
			this.unlock();
		}
		if (ts - start > lockTimeout) {
			throw new Error('Locker Timeout');
		}
	}

	let expire = this.store[this.expireKey] = +new Date() + runTimeout;

	function locked() {
		return +new Date() < expire;
	}

	try {
		transaction(locked);
	} finally {
		this.store[this.expireKey] = +new Date() + DEFAULT_RUN_SYNC_TIMEOUT;
		delete this.store[this.key];
	}
};

Locker.prototype.unlock = function (callback) {
	let start = +new Date();
	new Locker(this.name, this.appIsolated, this.seq + 1).run((done) => {
		if (+new Date() - start < DEFAULT_UNLOCK_TIMEOUT) {
			this.store[this.expireKey] = +new Date() + DEFAULT_RUN_SYNC_TIMEOUT;
			delete this.store[this.key];
			setTimeout(done, DEFAULT_UNLOCK_RECOVER_TIMEOUT);
		} else {
			done();
		}
	}, callback);
};

module.exports = Locker;