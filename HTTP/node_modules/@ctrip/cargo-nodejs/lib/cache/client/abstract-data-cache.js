'use strict'
const is = require('is-type-of')
const CacheEntry = require('../base-cache-entry')
const CacheConfig = require('../cache-config')
const AbstractCache = require('./abstract-cache')
const VersionManager = require('../method/version-manager')
const PROCESS = Symbol.for('CARGO#PROCESS_CACHE')
const CACHE = Symbol.for('CARGO#CACHE')

class AbstractDataCache extends AbstractCache {
  /**
   * Process data / dataWhiteList sources
   *
   * @param {Array<CacheEntry>} sources data source
   * @return {{ [key: string]: Array<CacheEntry> }} the collection of data source list group by key field
   */
  [PROCESS] (sources) {
    /** @type {{[key: string]: Array<CacheEntry>}} */
    const newCache = {}
    let cacheUpdated = false

    for (const data of sources) {
      const target = this.convert(data)
      if (!(target instanceof CacheEntry)) {
        continue
      }
      const cacheKey = target.cacheKey
      if (is.array(newCache[cacheKey])) {
        newCache[cacheKey].push(target)
      } else {
        newCache[cacheKey] = [target]
      }
    }

    for (const cacheKey in newCache) {
      const oldValue = (this[CACHE] && this[CACHE][cacheKey]) || []
      const neededUpdate = this.isNeededUpdate(oldValue, newCache[cacheKey])
      if (neededUpdate) {
        cacheUpdated = true
      }
      for (const cache of newCache[cacheKey]) {
        cache.changed = neededUpdate
      }
    }

    if (cacheUpdated) {
      this.emit(CacheConfig.CacheEvent.UPDATED)
    }
    this[CACHE] = newCache
  }

  /**
   * Returns all values in the cache.
   *
   * @param {boolean} isTriggerEnabled the listeners can be triggered or not.
   * @return {Array<Data>} all values in the cache.
   */
  getAll (isTriggerEnabled = true) {
    let cacheEntryList = []
    if (is.object(this[CACHE])) {
      for (const cacheKey in this[CACHE]) {
        cacheEntryList = cacheEntryList.concat(Array.from(this[CACHE][cacheKey]))
      }
    }
    if (isTriggerEnabled) {
      this.emit(CacheConfig.CacheEvent.VISITED_ALL, cacheEntryList)
    }
    return cacheEntryList
  }

  /**
   * Gets the snapshot of the datum in cache. Calculate by {@link VersionManager}
   *
   * @return {string} the snapshot of this cache.
   */
  getCacheVersion () {
    if (!is.object(this[CACHE])) {
      return CacheConfig.DEFAULT_VERSION
    }
    const cacheList = []
    for (const key in this[CACHE]) {
      for (const cache of this[CACHE][key]) {
        cacheList.push(cache)
      }
    }
    return VersionManager.encodeVersionList(cacheList)
  }
}

module.exports = AbstractDataCache
