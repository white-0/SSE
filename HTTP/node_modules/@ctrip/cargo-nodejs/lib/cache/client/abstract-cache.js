'use strict'
const pm2 = require('@ctrip/node-vampire-pm2')
const EventEmitter = require('events')
const is = require('is-type-of')
const Foundation = require('../../common/foundation')
const CacheConfig = require('../cache-config')
const CacheEntry = require('../base-cache-entry')
const { parseJson } = require('../../common/helpers')
const VersionManager = require('../method/version-manager')
const log = require('../../log')

const LOAD_RUNNER = Symbol('CARGO#LOAD_RUNNER')
const PROCESS = Symbol.for('CARGO#PROCESS_CACHE')
const CACHE = Symbol.for('CARGO#CACHE')

class AbstractCache extends EventEmitter {
  constructor (cacheName, configType) {
    super()

    /** @type { Map<string, CacheEntry | Array<CacheEntry>> | undefined } cache */
    this[CACHE] = undefined

    /** @type {string} cacheName */
    this.cacheName = cacheName

    /** @type {number} configType */
    this.configType = configType

    /** @type {boolean} isFirstLoad */
    this.isFirstLoad = true
  }

  init () {
    return this.load().then(sources => {
      if (is.array(sources) && sources.length > 0) {
        this[PROCESS](sources)
      }
      log.info(`first load cache ${this.cacheName} success!`)
      log.debug(this.cacheName, this[CACHE])
      this[LOAD_RUNNER]()
    }).catch(e => {
      log.warning(`first load cache ${this.cacheName} error!`, e)
      throw e
    })
  }

  /**
   * Timer to update config cache
   *
   * @param {Number} runAfterMillisecond interval time
   */
  [LOAD_RUNNER] (runAfterMillisecond) {
    if (Foundation.killed) {
      return
    }

    runAfterMillisecond = runAfterMillisecond || this.getInterval()
    let nextRunAfterMillisecond = runAfterMillisecond

    setTimeout(() => {
      if (Foundation.killed) {
        return
      }

      this.load().then(sources => {
        if (is.array(sources) && sources.length > 0) {
          this[PROCESS](sources)
          if (pm2.isMaster) {
            pm2.broadcast(CacheConfig.Message.UPDATED, {
              cacheName: this.cacheName,
              cache: this[CACHE]
            })
          }
          nextRunAfterMillisecond = this.getInterval()
          log.debug(`update cache ${this.cacheName} success!`, {
            nextRunAfterMillisecond
          })
          return
        }
        nextRunAfterMillisecond = this.getEmptyDelay()
        log.debug(`update cache ${this.cacheName} empty!`, {
          nextRunAfterMillisecond
        })
      }).catch(e => {
        nextRunAfterMillisecond = this.getExceptionDelay()
        log.warning(`update cache ${this.cacheName} error!`, e, {
          nextRunAfterMillisecond
        })
      }).then(() => {
        return this[LOAD_RUNNER](nextRunAfterMillisecond)
      })
    }, runAfterMillisecond)
  }

  /**
   * Process sources except data / dataWhiteList
   *
   * @param {Array<CacheEntry>} sources data source
   * @return {{ [key: string]: CacheEntry }} the collection of data source
   */
  [PROCESS] (sources) {
    const newCache = {}
    let cacheUpdated = false

    for (const data of sources) {
      const target = this.convert(data)
      if (!(target instanceof CacheEntry)) {
        continue
      }

      const cacheKey = target.cacheKey
      const oldValue = this[CACHE] && this[CACHE][cacheKey]
      const neededUpdate = this.isNeededUpdate(oldValue, target)
      if (neededUpdate) {
        cacheUpdated = true
      }

      target.changed = neededUpdate
      newCache[cacheKey] = target
    }

    if (cacheUpdated) {
      this.emit(CacheConfig.CacheEvent.UPDATED)
    }
    this[CACHE] = newCache
  }

  /**
   * Set cache value
   *
   * @param { Map<string, CacheEntry | Array<CacheEntry>> | undefined } rawData
   */
  setCache (rawData) {
    this[CACHE] = rawData
    this.emit(CacheConfig.CacheEvent.UPDATED)
  }

  /**
   * Get cache value
   *
   * @return { Map<string, CacheEntry | Array<CacheEntry>> | undefined } cache
   */
  getCache () {
    return this[CACHE]
  }

  /**
   * Returns all values in the cache.
   *
   * @param {boolean} isTriggerEnabled the listeners can be triggered or not.
   * @return {Array<CacheEntry>} all values in the cache.
   */
  getAll (isTriggerEnabled = true) {
    let cacheEntryList = []
    if (is.object(this[CACHE])) {
      cacheEntryList = Object.keys(this[CACHE]).map(key => Object.assign({}, this[CACHE][key]))
    }
    if (isTriggerEnabled) {
      this.emit(CacheConfig.CacheEvent.VISITED_ALL, cacheEntryList)
    }
    return cacheEntryList
  }

  /**
   * Return the value with the given key
   *
   * @param {string} cacheKey         the key to be given.
   * @param {boolean} isTriggerEnabled the listeners can be triggered or not.
   * @return {CacheEntry | Array<CacheEntry>} the value with the given key.
   */
  get (cacheKey, isTriggerEnabled = true) {
    let value = null
    if (is.object(this[CACHE])) {
      if (is.array(this[CACHE][cacheKey])) {
        value = Array.from(this[CACHE][cacheKey])
      } else if (is.object(this[CACHE][cacheKey])) {
        value = Object.assign({}, this[CACHE][cacheKey])
      }
    }
    if (isTriggerEnabled) {
      this.emit(CacheConfig.CacheEvent.VISITED, value)
    }
    if (value === null && this.configType !== null) {
      log.warning('get key empty', {
        cacheName: this.cacheName,
        cacheKey,
        value,
        isTriggerEnabled
      })
    } else {
      log.debug('get', this.cacheName, {
        cacheKey,
        value,
        isTriggerEnabled
      })
    }
    return value
  }

  /**
   * Load the data source
   *
   * @return {Promise<Object>} the loaded data.
   */
  load () {
    return Promise.reject(new Error('abstract method'))
  }

  /**
   * Convert the data
   *
   * @param {Object} data the data to convert
   * @return {CacheEntry} the converted data
   */
  convert (data) {
    throw new Error('abstract method')
  }

  /**
   * Check if the value needs to be updated in the com.ctrip.ibu.cargo.cache.
   *
   * @param {Object} previous the previous value in the com.ctrip.ibu.cargo.cache.
   * @param {Object} current  the current loaded value.
   * @return {Boolean} if the value needs to be update in the com.ctrip.ibu.cargo.cache, otherwise {@code false}
   */
  isNeededUpdate (previous, current) {
    throw new Error('abstract method')
  }

  /**
   * Gets the delay time when the loader thread loaded nothing.
   *
   * @return the delay time when the loader thread loaded nothing.
   */
  getEmptyDelay () {
    const cacheManager = require('../index')
    const configCache = cacheManager.getConfig(this.configType)
    if (configCache === null) {
      return CacheConfig.DEFAULT_EMPTY_DELAY
    }
    const config = parseJson(configCache.config)
    if (config && is.number(config.emptyDelay)) {
      return config.emptyDelay
    }
    return CacheConfig.DEFAULT_EMPTY_DELAY
  }

  /**
   * Gets the interval when the loader finished.
   *
   * @return the interval when the loader finished.
   */
  getInterval () {
    const cacheManager = require('../index')
    const configCache = cacheManager.getConfig(this.configType)
    if (configCache === null) {
      return CacheConfig.DEFAULT_INTERVAL
    }
    const config = parseJson(configCache.config)
    if (config && is.number(config.interval)) {
      return config.interval
    }
    return CacheConfig.DEFAULT_INTERVAL
  }

  /**
   * Gets the delay time when the loader occurred an exception, which is the maximum delay time,
   * because the loader will be re-scheduled in a random time between 0 and the given delay time.
   *
   * @return the delay time when the loader occurred an exception.
   */
  getExceptionDelay () {
    const cacheManager = require('../index')
    const configCache = cacheManager.getConfig(this.configType)
    if (configCache === null) {
      return CacheConfig.DEFAULT_EXCEPTION_DELAY
    }
    const config = parseJson(configCache.config)
    if (config && is.number(config.exceptionDelay)) {
      return config.exceptionDelay
    }
    return CacheConfig.DEFAULT_EXCEPTION_DELAY
  }

  /**
   * Gets the snapshot of the datum in cache. Calculate by {@link VersionManager}
   *
   * @return the snapshot of this cache.
   */
  getCacheVersion () {
    if (!is.object(this[CACHE])) {
      return CacheConfig.DEFAULT_VERSION
    }
    const cacheList = Object.keys(this[CACHE]).map(key => this[CACHE][key])
    return VersionManager.encodeVersionList(cacheList)
  }
}

module.exports = AbstractCache
