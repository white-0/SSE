'use strict'
const fs = require('fs')
const is = require('is-type-of')
const DataType = require('../common/data-type')
const Foundation = require('../common/foundation')
const { DEFAULT_APPID } = require('../common/constants')
const HeartBeatCollector = require('../collector')
const { CacheEvent, KeyType, SWITCH_CHANNEL } = require('./cache-config')
const VersionManager = require('./method/version-manager')
const generateCacheKey = require('./method/generate-cache-key')
const getDecorator = require('../metric/get')
const helpers = require('../common/helpers')
const log = require('../log')

const ChannelCache = require('./client/channel-cache')
const ConfigCache = require('./client/config-cache')
const CurrencyCache = require('./client/currency-cache')
const DataCache = require('./client/data-cache')
const DataWhiteListCache = require('./client/data-whitelist-cache')
const GroupCache = require('./client/group-cache')
const KeyCache = require('./client/key-cache')
const LocaleCache = require('./client/locale-cache')
const SiteCache = require('./client/site-cache')
const SourceCache = require('./client/source-cache')
const SwitchCache = require('./client/switch-cache')

const CHANNEL_CACHE = Symbol.for('CARGO#CAHNNEL_CACHE')
const CONFIG_CACHE = Symbol.for('CARGO#CONFIG_CACHE')
const CURRENCY_CACHE = Symbol.for('CARGO#CURRENCY_CACHE')
const DATA_CACHE = Symbol.for('CARGO#DATA_CACHE')
const DATA_WHITELIST_CACHE = Symbol.for('CARGO#DATA_WHITELIST_CACHE')
const GROUP_CACHE = Symbol.for('CARGO#GROUP_CACHE')
const KEY_CACHE = Symbol.for('CARGO#KEY_CACHE')
const LOCALE_CACHE = Symbol.for('CARGO#LOCALE_CACHE')
const SITE_CACHE = Symbol.for('CARGO#SITE_CACHE')
const SOURCE_CACHE = Symbol.for('CARGO#SOURCE_CACHE')
const SWITCH_CACHE = Symbol.for('CARGO#SWITCH_CACHE')

const SET_LOCAL_DATA = Symbol.for('CARGO#SET_LOCAL_DATA')

const INITED = Symbol('CARGO#INITED')
const INIT = Symbol.for('CARGO#INIT')
const INIT_PROMISE = Symbol('CARGO#INIT_PROMISE')

const createVisitedListener = dataType => data => {
  HeartBeatCollector.collect(data && data.id, dataType)
}

const createVisitedAllListener = dataType => dataList => {
  is.array(dataList) && dataList.forEach(data =>
    HeartBeatCollector.collect(data && data.id, dataType)
  )
}

class CacheManger {
  constructor () {
    this[CONFIG_CACHE] = new ConfigCache()
    this[DATA_CACHE] = new DataCache()
    this[DATA_WHITELIST_CACHE] = new DataWhiteListCache()
    this[SWITCH_CACHE] = new SwitchCache()

    this[CHANNEL_CACHE] = new ChannelCache()
    this[CHANNEL_CACHE].on(CacheEvent.VISITED, createVisitedListener(DataType.CHANNEL))
    this[CHANNEL_CACHE].on(CacheEvent.VISITED_ALL, createVisitedAllListener(DataType.CHANNEL))

    this[CURRENCY_CACHE] = new CurrencyCache()
    this[CURRENCY_CACHE].on(CacheEvent.VISITED, createVisitedListener(DataType.CURRENCY))
    this[CURRENCY_CACHE].on(CacheEvent.VISITED_ALL, createVisitedAllListener(DataType.CURRENCY))

    this[GROUP_CACHE] = new GroupCache()
    this[GROUP_CACHE].on(CacheEvent.VISITED, createVisitedListener(DataType.GROUP))
    this[GROUP_CACHE].on(CacheEvent.VISITED_ALL, createVisitedAllListener(DataType.GROUP))

    this[KEY_CACHE] = new KeyCache()
    this[KEY_CACHE].on(CacheEvent.VISITED, createVisitedListener(DataType.KEY))
    this[KEY_CACHE].on(CacheEvent.VISITED_ALL, createVisitedAllListener(DataType.KEY))

    this[LOCALE_CACHE] = new LocaleCache()
    this[LOCALE_CACHE].on(CacheEvent.VISITED, createVisitedListener(DataType.LOCALE))
    this[LOCALE_CACHE].on(CacheEvent.VISITED_ALL, createVisitedAllListener(DataType.LOCALE))

    this[SITE_CACHE] = new SiteCache()
    this[SITE_CACHE].on(CacheEvent.VISITED, createVisitedListener(DataType.SITE))
    this[SITE_CACHE].on(CacheEvent.VISITED_ALL, createVisitedAllListener(DataType.SITE))

    this[SOURCE_CACHE] = new SourceCache()
    this[SOURCE_CACHE].on(CacheEvent.VISITED, createVisitedListener(DataType.SOURCE))
    this[SOURCE_CACHE].on(CacheEvent.VISITED_ALL, createVisitedAllListener(DataType.SOURCE))

    this[INITED] = false
    this[INIT_PROMISE] = null

    // metric decorator
    this.getChannelCurrencySwitch = getDecorator(this)(this.getChannelCurrencySwitch)
    this.getChannelCurrencySwitchMap = getDecorator(this)(this.getChannelCurrencySwitchMap)
  }

  /**
   * Initialize all caches.
   */
  init () {
    if (this[INITED]) {
      return Promise.resolve(false)
    }
    if (!this[INIT_PROMISE]) {
      this[INIT_PROMISE] = this[INIT]().then(() => {
        this[INITED] = true
        return true
      })
    }
    return this[INIT_PROMISE]
  }

  /**
   * Get data from local file
   */
  getLocalFileData () {
    return new Promise((resolve, reject) => {
      const fileName = Foundation.serverEnv.storage
      fs.stat(fileName, (err, stat) => {
        if (err) {
          return reject(err)
        }
        fs.readFile(fileName, 'utf8', (err, rawData) => {
          if (err) {
            return reject(err)
          }
          const data = helpers.parseJson(rawData)
          if (this[SET_LOCAL_DATA](data)) {
            log.info('client-cache init from local file cache success')
            return resolve()
          }
          return reject(new Error('local file invalid'))
        })
      })
    })
  }

  /**
   * internal setData method
   */
  [SET_LOCAL_DATA] (data) {
    if (!data) {
      return false
    }
    const {
      configCache, dataCache, dataWhiteListCache,
      channelCache, currencyCache, groupCache,
      keyCache, localeCache, siteCache, sourceCache,
      switchCache
    } = data
    this[CONFIG_CACHE].setCache(configCache)
    this[DATA_CACHE].setCache(dataCache)
    this[DATA_WHITELIST_CACHE].setCache(dataWhiteListCache)
    this[CHANNEL_CACHE].setCache(channelCache)
    this[CURRENCY_CACHE].setCache(currencyCache)
    this[GROUP_CACHE].setCache(groupCache)
    this[KEY_CACHE].setCache(keyCache)
    this[LOCALE_CACHE].setCache(localeCache)
    this[SITE_CACHE].setCache(siteCache)
    this[SOURCE_CACHE].setCache(sourceCache)
    this[SWITCH_CACHE].setCache(switchCache)
    return true
  }

  /**
   * Internal init operation
   */
  [INIT] () {
    return Promise.reject(new Error('abstract method'))
  }

  /**
   * Max time to wait for initialization
   */
  initTimeout (maxInitialTime) {
    return new Promise((resolve, reject) => {
      setTimeout(
        () => reject(new Error('init timeout!')),
        maxInitialTime
      )
    })
  }

  /**
   * Register update event
   *
   * @param {Number} dataTye register data type
   * @param {Function} callback callback function
   */
  registerUpdateEvent (dataType, callback) {
    const mapper = {
      [DataType.CHANNEL]: this[CHANNEL_CACHE],
      [DataType.CURRENCY]: this[CURRENCY_CACHE],
      [DataType.GROUP]: this[GROUP_CACHE],
      [DataType.LOCALE]: this[LOCALE_CACHE],
      [DataType.SITE]: this[SITE_CACHE],
      [DataType.SOURCE]: this[SOURCE_CACHE],
      [DataType.DATA]: this[DATA_CACHE]
    }

    if (mapper[dataType]) {
      mapper[dataType].on(CacheEvent.UPDATED, callback)
    }
  }

  /**
   * Get a snapshot of all caches.
   *
   * @return {String} the snapshot of all caches
   */
  getCurrentCacheVersion () {
    return [
      this[DATA_CACHE].getCacheVersion(),
      this[KEY_CACHE].getCacheVersion(),
      this[GROUP_CACHE].getCacheVersion(),
      this[SITE_CACHE].getCacheVersion(),
      this[SOURCE_CACHE].getCacheVersion(),
      this[CHANNEL_CACHE].getCacheVersion(),
      this[CURRENCY_CACHE].getCacheVersion(),
      this[LOCALE_CACHE].getCacheVersion(),
      this[DATA_WHITELIST_CACHE].getCacheVersion(),
      this[SWITCH_CACHE].getCacheVersion()
    ].join(VersionManager.CACHE_SEPARATOR)
  }

  /**
   * Returns the config with the specified type and appId,
   * the {@code null} will be returned if it cannot be found.
   *
   * @param {Number} type the config type
   * @return {import('./cache-entry').Config} the config with the given config type.
   */
  getConfig (type) {
    let configEntry = null
    if (is.number(type)) {
      configEntry = this[CONFIG_CACHE].get(
        generateCacheKey(`${Foundation.appId}_${type}`, KeyType.CONFIG)
      )
      if (configEntry === null) {
        configEntry = this[CONFIG_CACHE].get(
          generateCacheKey(`${DEFAULT_APPID}_${type}`, KeyType.CONFIG)
        )
      }
    }
    return configEntry
  }

  /**
   * Returns all configs.
   *
   * @return {Array<import('./cache-entry').Config>} all configs.
   */
  getConfigs () {
    return this[CONFIG_CACHE].getAll()
  }

  /**
   * Returns the data with the specified data keyId,
   * the {@code null} will be returned if it cannot be found.
   *
   * @param {string} keyId
   * @return {Array<import('./cache-entry').Data>} the data with the given id.
   */
  getDataByKeyId (keyId) {
    if (keyId !== null) {
      return this[DATA_CACHE].get(generateCacheKey(keyId, KeyType.DATA)) || []
    }
    return []
  }

  /**
   * Returns all data in data cache.
   * @param {boolean} triggerListener
   *
   * @return {Array<import('./cache-entry').Data>} all data.
   */
  getAllData (triggerListener = false) {
    return this[DATA_CACHE].getAll(triggerListener)
  }

  /**
   * Returns all data white list in data cache.
   * @param {boolean} triggerListener
   *
   * @return {Array<import('./cache-entry').Data>} all data white list.
   */
  getAllDataWhitelist (triggerListener = false) {
    return this[DATA_WHITELIST_CACHE].getAll(triggerListener)
  }

  /**
   * Returns all keys.
   *
   * @return {Array<import('./cache-entry').Key>} all keys.
   */
  getKeys () {
    return this[KEY_CACHE].getAll()
  }

  /**
   * Returns the key with the specified name,
   * the {@code null} will be returned if it cannot be found.
   *
   * @param name the key name.
   * @return {import('./cache-entry').Key|null} the key with the given name.
   */
  getKeyByNameAndAppId (name, appId = Foundation.appId) {
    if (!is.string(name)) {
      return null
    }
    return this[KEY_CACHE].get(generateCacheKey(name + appId, KeyType.KEY))
  }

  /**
   * Returns all groups.
   *
   * @return {Array<import('./cache-entry').Group>} all groups.
   */
  getGroups () {
    return this[GROUP_CACHE].getAll()
  }

  /**
   * Returns the group with the specified id,
   * the {@code null} will be returned if it cannot be found.
   *
   * @param id the group id.
   * @return {import('./cache-entry').Group|null} the group with the given id.
   */
  getGroupById (id) {
    if (!is.number(id)) {
      return null
    }
    const groups = this.getGroups()
    for (const group of groups) {
      if (group.id === id) {
        return group
      }
    }
    return null
  }

  /**
   * Returns the group with the specified name,
   * the {@code null} will be returned if it cannot be found.
   *
   * @param {string} name the group name.
   * @return {import('./cache-entry').Group|null} the group with the given name.
   */
  getGroupByName (name) {
    if (!is.string(name)) {
      return null
    }
    return this[GROUP_CACHE].get(generateCacheKey(name, KeyType.GROUP))
  }

  /**
   * Returns all sites.
   *
   * @return {Array<import('./cache-entry').Site}> all sites.
   */
  getSites () {
    return this[SITE_CACHE].getAll()
  }

  /**
   * Returns the site with the specified id
   * the {@code null} will be returned if it cannot be found.
   *
   * @param {number} id the site id.
   * @return {import('./cache-entry').Site|null} the site with the given id.
   */
  getSiteById (id) {
    if (!is.number(id)) {
      return null
    }
    const sites = this.getSites()
    for (const site of sites) {
      if (site.id === id) {
        return site
      }
    }
    return null
  }

  /**
   * Returns the site with the specified group's name and site's name,
   * the {@code null} will be returned if it cannot be found.
   *
   * @param {string} groupName the group's name.
   * @param {string} siteName  the site's name.
   * @return {import('./cache-entry').Site|null} the site with the given group's name and site's name.
   */
  getSiteByName (groupName, siteName) {
    if (!is.string(groupName) || !is.string(siteName)) {
      return null
    }
    const group = this.getGroupByName(groupName)
    if (group != null) {
      return this[SITE_CACHE].get(generateCacheKey(siteName + group.id, KeyType.SITE))
    }
    return null
  }

  /**
   * Returns the site with the specified host,
   * the {@code null} will be returned if it cannot be found.
   *
   * @param {string} host the site host.
   * @return {import('./cache-entry').Site} the site with the given host.
   */
  getSiteByHost (host) {
    if (!is.string(host)) {
      return null
    }
    const sites = this.getSites()
    for (const site of sites) {
      if (site.hosts.indexOf(host) !== -1) {
        return site
      }
    }
    return null
  }

  /**
   * Returns all sources.
   *
   * @return {Array<import('./cache-entry').Source>} all sources.
   */
  getSources () {
    return this[SOURCE_CACHE].getAll()
  }

  /**
   * Returns the source with the specified name,
   * the {@code null} will be returned if it cannot be found.
   *
   * @param {string} name the source name.
   * @return {import('./cache-entry').Source|null} the source with the given name.
   */
  getSourceByName (name) {
    if (!is.string(name)) {
      return null
    }
    return this[SOURCE_CACHE].get(generateCacheKey(name, KeyType.SOURCE))
  }

  /**
   * Returns the source with the specified id,
   * the {@code null} will be returned if it cannot be found.
   *
   * @param {Number} id the source id.
   * @return {import('./cache-entry').Source | null} the currency with the given id.
   */
  getSourceById (id) {
    if (!is.number(id)) {
      return null
    }
    const sources = this.getChannels()
    for (const source of sources) {
      if (source.id === id) {
        return source
      }
    }
    return null
  }

  /**
   * Returns all channels.
   *
   * @return {Array<import('./cache-entry').Channel>} all channels.
   */
  getChannels () {
    return this[CHANNEL_CACHE].getAll()
  }

  /**
   * Returns the site with the specified name,
   * the {@code null} will be returned if it cannot be found.
   *
   * @param {string} name the site name.
   * @return {import('./cache-entry').Channel} the site with the given name.
   */
  getChannelByName (name) {
    if (!is.string(name)) {
      return null
    }
    return this[CHANNEL_CACHE].get(generateCacheKey(name, KeyType.CHANNEL))
  }

  /**
   * Returns the channel with the specified id,
   * the {@code null} will be returned if it cannot be found.
   *
   * @param {Number} id the channel id.
   * @return {import('./cache-entry').Channel | null} the currency with the given id.
   */
  getChannelById (id) {
    if (!is.number(id)) {
      return null
    }
    const channels = this.getChannels()
    for (const channel of channels) {
      if (channel.id === id) {
        return channel
      }
    }
    return null
  }

  /**
   * Returns all currencies.
   *
   * @return {Array<import('./cache-entry').Currency>} all currencies.
   */
  getCurrencies () {
    return this[CURRENCY_CACHE].getAll()
  }

  /**
   * Returns the currency with the specified id,
   * the {@code null} will be returned if it cannot be found.
   *
   * @param {Number} id the currency id.
   * @return {import('./cache-entry').Currency} the currency with the given id.
   */
  getCurrencyById (id) {
    if (!is.number(id)) {
      return null
    }
    const currencies = this.getCurrencies()
    for (const currency of currencies) {
      if (currency.id === id) {
        return currency
      }
    }
    return null
  }

  /**
   * Returns the currency with the specified name,
   * the {@code null} will be returned if it cannot be found.
   *
   * @param {string} name the currency name.
   * @return {import('./cache-entry').Currency|null} the currency with the given name.
   */
  getCurrencyByName (name) {
    if (!is.string(name)) {
      return null
    }
    return this[CURRENCY_CACHE].get(generateCacheKey(name, KeyType.CURRENCY))
  }

  /**
   * Returns all locales.
   *
   * @return {Array<import('./cache-entry').Locale>} all locales.
   */
  getLocales () {
    return this[LOCALE_CACHE].getAll()
  }

  /**
   * Returns the locale with the specified id,
   * the {@code null} will be returned if it cannot be found.
   *
   * @param {Number} id the locale id.
   * @return {import('./cache-entry').Locale|null} the locale with the given id.
   */
  getLocaleById (id) {
    if (!is.number(id)) {
      return null
    }
    const locales = this.getLocales()
    for (const locale of locales) {
      if (locale.id === id) {
        return locale
      }
    }
    return null
  }

  /**
   * Returns the locale with the specified name,
   * the {@code null} will be returned if it cannot be found.
   *
   * @param {String} name the locale name.
   * @return {import('./cache-entry').Locale|null} the locale with the given name.
   */
  getLocaleByName (name) {
    if (!is.string(name)) {
      return null
    }
    return this[LOCALE_CACHE].get(generateCacheKey(name, KeyType.LOCALE))
  }

  /**
   * Gets all channel's currency info about availability or prohibition with the specified channel's.
   *
   * @param {String} channel channel's name:For correct format, please refer to @see <a href="http://cargo.ibu.ctripcorp.com/#/basic/channel">http://cargo.ibu.ctripcorp.com/#/basic/channel</a>.
   * @return {{[key: string]: boolean}}
   */
  getChannelCurrencySwitchMap (channel) {
    const currencySwitchMap = {}
    if (!is.string(channel)) {
      return currencySwitchMap
    }
    const switches = this[SWITCH_CACHE].getAll()
    for (const currencySwitch of switches) {
      if (currencySwitch.channel && currencySwitch.channel === SWITCH_CHANNEL) {
        currencySwitchMap[currencySwitch.currency] = currencySwitch.value
      }
    }
    return currencySwitchMap
  }

  /**
   * Gets all channel's currency info about availability or prohibition with the specified channel's.
   *
   * @param {string} channel channel's name: For correct format, please refer to @see <a href="http://cargo.ibu.ctripcorp.com/#/basic/channel">http://cargo.ibu.ctripcorp.com/#/basic/channel</a>.
   * @param {string} currency currency's name: For correct format, please refer to @see <a href="http://cargo.ibu.ctripcorp.com/#/basic/currency">http://cargo.ibu.ctripcorp.com/#/basic/currency</a>.
   * @return {boolean}
   */
  getChannelCurrencySwitch (channel, currency) {
    if (!is.string(channel) || !is.string(currency)) {
      return true
    }
    const currencySwitchMap = this.getChannelCurrencySwitchMap(channel)
    if (!is.object(currencySwitchMap) ||
      // eslint-disable-next-line no-prototype-builtins
      !currencySwitchMap.hasOwnProperty(currency)) {
      return true
    }
    return currencySwitchMap[currency]
  }
}

module.exports = CacheManger
