'use strict'
const pm2 = require('@ctrip/node-vampire-pm2')
const CacheManager = require('./cache-manager')
const { Message, ClientCacheName, MAX_SLAVE_INITIAL_TIME } = require('./cache-config')
const log = require('../log')

const CHANNEL_CACHE = Symbol.for('CARGO#CAHNNEL_CACHE')
const CONFIG_CACHE = Symbol.for('CARGO#CONFIG_CACHE')
const CURRENCY_CACHE = Symbol.for('CARGO#CURRENCY_CACHE')
const DATA_CACHE = Symbol.for('CARGO#DATA_CACHE')
const DATA_WHITELIST_CACHE = Symbol.for('CARGO#DATA_WHITELIST_CACHE')
const GROUP_CACHE = Symbol.for('CARGO#GROUP_CACHE')
const KEY_CACHE = Symbol.for('CARGO#KEY_CACHE')
const LOCALE_CACHE = Symbol.for('CARGO#LOCALE_CACHE')
const SITE_CACHE = Symbol.for('CARGO#SITE_CACHE')
const SOURCE_CACHE = Symbol.for('CARGO#SOURCE_CACHE')
const SWITCH_CACHE = Symbol.for('CARGO#SWITCH_CACHE')

const SET_LOCAL_DATA = Symbol.for('CARGO#SET_LOCAL_DATA')

const INIT = Symbol.for('CARGO#INIT')

class CacheManagerSlave extends CacheManager {
  [INIT] () {
    const initCacheManager = () => new Promise((resolve, reject) => {
      pm2.once(Message.INIT, data => {
        if (this[SET_LOCAL_DATA](data)) {
          log.info('received cache, init success')
          log.debug('received cache profile', data)
          return resolve()
        }
        reject(new Error('received invalid cache!'))
      })
    })

    return Promise.race([
      initCacheManager(),
      this.initTimeout(MAX_SLAVE_INITIAL_TIME)
    ]).catch((e) => {
      log.warning('client-cache init from master error', e)
      return this.getLocalFileData()
    }).then(() => {
      this.bindUpdateEvent()
      log.info('client-cache init success')
    }).catch((e) => {
      log.error('client-cache init error', e)
      process.exit(0)
    })
  }

  bindUpdateEvent () {
    pm2.on(Message.UPDATED, data => {
      const cache = data.cache
      log.info('received update data')
      log.debug('received update data profile', data)
      switch (data.cacheName) {
        case ClientCacheName.CONFIG:
          return this[CONFIG_CACHE].setCache(cache)
        case ClientCacheName.SOURCE:
          return this[SOURCE_CACHE].setCache(cache)
        case ClientCacheName.SITE:
          return this[SITE_CACHE].setCache(cache)
        case ClientCacheName.LOCALE:
          return this[LOCALE_CACHE].setCache(cache)
        case ClientCacheName.KEY:
          return this[KEY_CACHE].setCache(cache)
        case ClientCacheName.GROUP:
          return this[GROUP_CACHE].setCache(cache)
        case ClientCacheName.DATA_WHITELIST:
          return this[DATA_WHITELIST_CACHE].setCache(cache)
        case ClientCacheName.DATA:
          return this[DATA_CACHE].setCache(cache)
        case ClientCacheName.CURRENCY:
          return this[CURRENCY_CACHE].setCache(cache)
        case ClientCacheName.CHANNEL:
          return this[CHANNEL_CACHE].setCache(cache)
        case ClientCacheName.SWITCH:
          return this[SWITCH_CACHE].setCache(cache)
      }
    })
  }
}

module.exports = CacheManagerSlave
