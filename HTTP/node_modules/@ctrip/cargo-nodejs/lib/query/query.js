'use strict'
const is = require('is-type-of')
const cacheManager = require('../cache')
const HeartBeatCollector = require('../collector')
const DataType = require('../common/data-type')
const log = require('../log')
const {
  injectItemSize,
  itemCanRemove,
  itemCanMatch,
  insertCandidate
} = require('./query-methods')
const queryMetric = require('../metric/query')

const QUERY_WHITELIST = Symbol('CARGO#QUERY_WHITELIST')
const QUERY = Symbol('CARGO#QUERY')
const SIZE = Symbol.for('CARGO#DATA_ITEM_SIZE')

class Query {
  constructor (keyId, appId, conditions, candidate) {
    /** @type {string} */
    this.keyId = keyId

    /** @type {Array<{ field: string, value: number|string, name: string }>} */
    this.conditions = conditions

    /** @type {string} */
    this.candidate = candidate

    /** @type {string} */
    this.appId = appId

    this.query = queryMetric(this)(this.query)
  }

  query () {
    if (!this.keyId) {
      return ''
    }
    let result = ''
    if (is.string(this.candidate) && this.candidate !== '') {
      result = this[QUERY_WHITELIST]()
    }
    if (result === '') {
      result = this[QUERY]()
    }
    if (result === '') {
      log.warning('QUERY EMPTY', this.keyId, this.conditions, this.candidate)
    }
    return result
  }

  [QUERY_WHITELIST] () {
    const newConditions = insertCandidate(this.conditions, this.candidate)
    const dataWhiteList = cacheManager
      .getAllData(false)
      .filter(item => item.keyId && item.keyId === this.keyId)
      .map(injectItemSize)
      .filter(item => {
        if (item.appId !== this.appId) {
          return false
        }
        for (const condition of newConditions) {
          if (itemCanRemove(item, condition, newConditions.length)) {
            return false
          }
        }
        return true
      })

    dataWhiteList.sort((item1, item2) => item2[SIZE] - item1[SIZE])

    for (let maxIndex = newConditions.length; maxIndex > 0; maxIndex--) {
      for (const item of dataWhiteList) {
        if (itemCanMatch(item, newConditions, maxIndex)) {
          HeartBeatCollector.collect(item.id, DataType.DATA_WHITELIST)
          return item.value
        }
      }
    }
    return ''
  }

  [QUERY] () {
    const data = cacheManager
      .getAllData(false)
      .filter(item => item.keyId && item.keyId === this.keyId)
      .map(injectItemSize)
      .filter(item => {
        if (item.appId !== this.appId) {
          return false
        }
        for (const condition of this.conditions) {
          if (itemCanRemove(item, condition, this.conditions.length)) {
            return false
          }
        }
        return true
      })

    data.sort((item1, item2) => item2[SIZE] - item1[SIZE])

    // reduce conditions and match
    for (let maxIndex = this.conditions.length; maxIndex > 0; maxIndex--) {
      for (const item of data) {
        if (itemCanMatch(item, this.conditions, maxIndex)) {
          HeartBeatCollector.collect(item.id, DataType.DATA)
          return item.value
        }
      }
    }
    return ''
  }
}

module.exports = Query
