"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.messageQueue = void 0;
const node_vampire_cat_1 = __importDefault(require("@ctrip/node-vampire-cat"));
const node_vampire_metric_1 = __importDefault(require("@ctrip/node-vampire-metric"));
const commonConstants_1 = require("./commonConstants");
const RpcSender_1 = require("./RpcSender");
const version = require('../../package.json').version;
const metric = new node_vampire_metric_1.default({
    name: "nodejs.triplog.count",
    tags: {
        version: version
    },
    interval: 6000,
});
metric.start();
class MessageQueue {
    constructor() {
        this._messageQueue = new Array();
        this._sendQueue = { msg: [], len: 0 };
        this.sendTs = new Date().getTime();
        this.repcSender = new RpcSender_1.RpcSender();
        this.TIMEOUT = 10000;
    }
    /**
   * 新增一条clog数据进入队列;
   * @param {LogEvent} data 一条LogEvent数据
   */
    addToQueue(data) {
        this._messageQueue.push(data);
        while (this._messageQueue.length > 500) {
            node_vampire_cat_1.default.event('TripLog.Drop', 'BatchQueueFull', this._messageQueue.length);
            this._messageQueue.shift();
        }
        this.checkQueue();
    }
    /**
      * 发送日志
      * maxBatchConut:单批次发送日志的最大条数，默认100
      * maxBatchSize:单批次发送日志的最大大小，默认16MB
      * maxQueueSize:缓存队列的时间，默认是4000
     */
    checkQueue() {
        metric.add(1, { version });
        this.doAccumlate();
        if (this._sendQueue.msg.length > 0 && +new Date() - this.sendTs > 4000 || this._sendQueue.len >= commonConstants_1.LIMIT_RANGE.maxBatchSize || this._sendQueue.msg.length >= commonConstants_1.LIMIT_RANGE.maxBatchCount) {
            this.sendTs = +new Date();
            const { msg, len } = this._sendQueue;
            this._sendQueue = { msg: [], len: 0 };
            (msg && msg.length > 0) && this.sendFn(msg, len);
        }
    }
    doAccumlate() {
        const message = this._messageQueue.slice(0, 1)[0];
        while (this._messageQueue.length > 0 && this._sendQueue.msg.length < commonConstants_1.LIMIT_RANGE.maxBatchCount && this._sendQueue.len + message.getMessage().length < commonConstants_1.LIMIT_RANGE.maxBatchSize) {
            const _message = this._messageQueue.splice(0, 1)[0];
            _message && this._sendQueue.msg.push(_message);
            this._sendQueue.len += _message.getMessage().length;
        }
        //todo: heartbeat 加入面板
    }
    sendFn(sendMsgQueue, len, retryTime) {
        retryTime = retryTime || 0;
        node_vampire_cat_1.default.event('TripLog.Accumulated', 'default', `length:${sendMsgQueue.length},size:${len}`);
        this.repcSender.send(sendMsgQueue, len, (err, response) => {
            retryTime++;
            if (err) {
                if (retryTime < commonConstants_1.LIMIT_RANGE.MAX_RETRY_ATTEMPTS) {
                    setTimeout(() => {
                        console.log(`[@ctrip/node-vampire-triplog] Send failed: ${err.message}, retry after ` +
                            this.TIMEOUT +
                            `ms (` +
                            retryTime +
                            `)`);
                        this.sendFn(sendMsgQueue, len, retryTime);
                    }, this.TIMEOUT).unref();
                }
                else {
                    // console.log(`[@ctrip/node-vampire-triplog] send message error,errMessage:${err.message}`);
                    node_vampire_cat_1.default.event('TripLog.Drop', 'Send.Failed', sendMsgQueue.length);
                }
            }
            if (response && response.getResult() != 0) {
                //console.log(`[@ctrip/node-vampire-triplog] send message error, statusCode:${response.getResult()}`);
            }
        });
    }
}
exports.messageQueue = new MessageQueue();
setInterval(() => { exports.messageQueue.checkQueue(); }, 1000).unref();
