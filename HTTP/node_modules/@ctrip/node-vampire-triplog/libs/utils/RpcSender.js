"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RpcSender = void 0;
const grpc = __importStar(require("@grpc/grpc-js"));
const node_vampire_cat_1 = __importDefault(require("@ctrip/node-vampire-cat"));
const node_vampire_pm2_1 = __importDefault(require("@ctrip/node-vampire-pm2"));
const TriplogBootstrapProvider_1 = require("./TriplogBootstrapProvider");
const tripLog_grpc_pb_1 = require("../../protobuf/tripLog_grpc_pb");
const commonConstants_1 = require("../utils/commonConstants");
const node_vampire_util_1 = __importDefault(require("@ctrip/node-vampire-util"));
const node_vampire_foundation_framework_1 = __importDefault(require("@ctrip/node-vampire-foundation-framework"));
const tripLog_pb_1 = require("../../protobuf/tripLog_pb");
let flag = 0;
const ChannelCredentials = grpc.ChannelCredentials.createInsecure();
const deadline = 5000;
class RpcSender {
    constructor() {
        this.originAddressMap = {};
        this.buildChannelPromise = null;
        this.buildChannelPromise = this.buildChannel();
        setInterval(() => {
            this.resetChannel();
            this.buildChannel();
        }, 300000).unref();
    }
    /**
     * filter channel
     */
    buildChannel() {
        return TriplogBootstrapProvider_1.tripBootstrapServers.fetchBootstrapServers().then(() => {
            const originAddresses = Object.keys(this.originAddressMap);
            const latestAddresses = [];
            const func = (value) => {
                const address = value + ':' + TriplogBootstrapProvider_1.tripBootstrapServers.bootstrapServerPort;
                latestAddresses.push(address);
                if (!this.originAddressMap[address]) {
                    this.originAddressMap[address] = new tripLog_grpc_pb_1.LogSenderClient(address, ChannelCredentials, {
                        "grpc.enable_http_proxy": 0,
                        "grpc.enable_channelz": 0,
                        "grpc.enable_retries": 0,
                        "grpc.use_local_subchannel_pool": 1,
                        'grpc.default_compression_algorithm': grpc.compressionAlgorithms.gzip
                    });
                }
            };
            const severLIst = TriplogBootstrapProvider_1.tripBootstrapServers.bootstrapServerList;
            if (node_vampire_pm2_1.default.count === 1) {
                severLIst.slice(0, 5).forEach((value) => {
                    func(value);
                });
            }
            else {
                //多进程时负载均衡,每个进程至少每个进程至少分配3个服务实例
                const num = Math.trunc(severLIst.length / ((node_vampire_pm2_1.default.id + 1) * 3));
                if (num >= 1) { //每个进程至少分配3个服务实例
                    severLIst.slice(node_vampire_pm2_1.default.id * 3, (node_vampire_pm2_1.default.id + 1) * 3).forEach((value) => {
                        func(value);
                    });
                }
                else {
                    const remainder = (node_vampire_pm2_1.default.id * 3) % severLIst.length; // 计算起点
                    const newArr = severLIst.concat(severLIst);
                    newArr.slice(remainder, remainder + 3).forEach((value) => {
                        func(value);
                    });
                }
            }
            originAddresses.forEach((item) => {
                if (!latestAddresses.includes(item)) {
                    // 将遗留channel关闭并移除 cheannel 
                    const client = this.originAddressMap[item];
                    delete this.originAddressMap[item];
                    //间隔一段时间再关闭,避免该地址还在被占用;
                    setTimeout(() => {
                        client.close();
                    }, 1000).unref();
                }
            });
            node_vampire_cat_1.default.event('TripLog.serverList', 'TripLog.serverList', JSON.stringify(Object.keys(this.originAddressMap)));
        }).catch((err) => {
            console.log('[@ctrip/node-vampire-tripLog buildChannel error]:', err.message || err);
        });
    }
    /**
     *
     * @returns 顺序返回连接,如果channel持续时长超过60s非ready状态,则不再返回该channel
     */
    readyClient() {
        let ret = null;
        const client = Object.values(this.originAddressMap);
        for (let i = flag; i < flag + client.length; i++) {
            let index = i % client.length;
            let channel = client[index];
            const status = channel.getChannel().getConnectivityState(false);
            if (status != grpc.connectivityState.SHUTDOWN && status != grpc.connectivityState.TRANSIENT_FAILURE) {
                ret = channel;
                break;
            }
        }
        flag++;
        if (flag >= client.length) {
            flag = 0;
        }
        return ret;
    }
    /**
     * reset channel
     */
    resetChannel() {
        const latestAddresses = Object.keys(this.originAddressMap);
        latestAddresses.forEach((address) => {
            const grpcClient = this.originAddressMap[address];
            const connectStatus = grpcClient && grpcClient.getChannel() && grpcClient.getChannel().getConnectivityState(false);
            if (connectStatus === grpc.connectivityState.SHUTDOWN || connectStatus === grpc.connectivityState.TRANSIENT_FAILURE) {
                node_vampire_cat_1.default.event('TripLog.delete.address', address, connectStatus);
                grpcClient.close();
                delete this.originAddressMap[address];
            }
        });
    }
    /**
     * send message to server (gzip)
     * @param logEventList Array<LogEvent>
     */
    send(logEventList, size, func) {
        let logBatch = new tripLog_pb_1.LogBatch();
        logBatch.setDomain(node_vampire_foundation_framework_1.default.getAppID());
        logBatch.setSize(size);
        logBatch.setLogsList(logEventList);
        logBatch.getPropertiesMap().set(commonConstants_1.constants.KEY_GROUP, process.env['PAAS_APP_GROUPID'] || 'unknown');
        logBatch.getPropertiesMap().set(commonConstants_1.constants.KEY_HOST_ADDRESS, node_vampire_util_1.default.getHostIp());
        logBatch.getPropertiesMap().set(commonConstants_1.constants.KEY_HOSTNAME, node_vampire_util_1.default.getHostName());
        logBatch.getPropertiesMap().set(commonConstants_1.constants.KEY_SUBENV, node_vampire_foundation_framework_1.default.getServerPropertiesSync('subenv') || 'unknown');
        logBatch.getPropertiesMap().set(commonConstants_1.constants.KEY_ZONE, node_vampire_foundation_framework_1.default.getServerPropertiesSync('idc') || 'unknown');
        logBatch.getPropertiesMap().set(commonConstants_1.constants.KEY_CLOG_AZ, node_vampire_foundation_framework_1.default.getServerPropertiesSync('az') || 'unknown');
        logBatch.getPropertiesMap().set(commonConstants_1.constants.KEY_CLOG_REGION, node_vampire_foundation_framework_1.default.getServerPropertiesSync('region') || 'unknown');
        logBatch.getPropertiesMap().set(commonConstants_1.constants.KEY_CLOG_IDC, node_vampire_foundation_framework_1.default.getServerPropertiesSync('idc') || 'unknown');
        let client = this.readyClient();
        if (client) {
            node_vampire_cat_1.default.event('TripLog.client', 'triplog.address', client.getChannel().getTarget());
            client.send(logBatch, { deadline: Date.now() + deadline }, func);
        }
        else {
            node_vampire_cat_1.default.event('TripLog.client', 'client channel is null', client);
            func(new Error('client channel is null'), null);
        }
    }
}
exports.RpcSender = RpcSender;
