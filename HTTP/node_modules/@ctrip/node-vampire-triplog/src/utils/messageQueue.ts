import cat from '@ctrip/node-vampire-cat';
import Metric from '@ctrip/node-vampire-metric';
import { LogEvent, SendResult } from '../../protobuf/tripLog_pb';
import { LIMIT_RANGE } from './commonConstants';
import { RpcSender } from './RpcSender';
const version = require('../../package.json').version;
const metric = new Metric({
    name: "nodejs.triplog.count",
    tags: {
        version: version
    },
    interval: 6000,
});
metric.start();
class MessageQueue {
    private _messageQueue = new Array<LogEvent>();
    private _sendQueue = { msg: [], len: 0 } as { msg: Array<LogEvent>, len: number };
    private sendTs: number = new Date().getTime();
    private repcSender: RpcSender = new RpcSender();
    private TIMEOUT: number = 10000;
    constructor() {
    }
    /**
   * 新增一条clog数据进入队列;
   * @param {LogEvent} data 一条LogEvent数据
   */
    addToQueue(data: LogEvent): void {
        this._messageQueue.push(data);
        while (this._messageQueue.length > 500) {
            cat.event('TripLog.Drop', 'BatchQueueFull', this._messageQueue.length);
            this._messageQueue.shift();
        }
        this.checkQueue();
    }
    /**
      * 发送日志
      * maxBatchConut:单批次发送日志的最大条数，默认100
      * maxBatchSize:单批次发送日志的最大大小，默认16MB
      * maxQueueSize:缓存队列的时间，默认是4000
     */
    checkQueue(): void {
        metric.add(1, { version })
        this.doAccumlate();
        if (this._sendQueue.msg.length > 0 && +new Date() - this.sendTs > 4000 || this._sendQueue.len >= LIMIT_RANGE.maxBatchSize || this._sendQueue.msg.length >= LIMIT_RANGE.maxBatchCount) {
            this.sendTs = +new Date();
            const { msg, len } = this._sendQueue;
            this._sendQueue = { msg: [] as Array<LogEvent>, len: 0 };
            (msg && msg.length > 0) && this.sendFn(msg, len);
        }
    }
    doAccumlate(): void {
        const message = this._messageQueue.slice(0, 1)[0]

        while (this._messageQueue.length > 0 && this._sendQueue.msg.length < LIMIT_RANGE.maxBatchCount && this._sendQueue.len + message.getMessage().length < LIMIT_RANGE.maxBatchSize) {
            const _message = this._messageQueue.splice(0, 1)[0];
            _message && this._sendQueue.msg.push(_message);
            this._sendQueue.len += _message.getMessage().length;
        }
        //todo: heartbeat 加入面板
    }

    sendFn(sendMsgQueue: Array<LogEvent>, len: number, retryTime?: number): void {
        retryTime = retryTime || 0;

        cat.event('TripLog.Accumulated', 'default', `length:${sendMsgQueue.length},size:${len}`);
        this.repcSender.send(sendMsgQueue, len, (err, response: SendResult) => {
            retryTime++;
            if (err) {
                if (retryTime < LIMIT_RANGE.MAX_RETRY_ATTEMPTS) {
                    setTimeout(() => {
                        console.log(
                            `[@ctrip/node-vampire-triplog] Send failed: ${err.message}, retry after ` +
                            this.TIMEOUT +
                            `ms (` +
                            retryTime +
                            `)`
                        );
                        this.sendFn(sendMsgQueue,len,retryTime)
                    }, this.TIMEOUT).unref();
                } else {
                   // console.log(`[@ctrip/node-vampire-triplog] send message error,errMessage:${err.message}`);
                    cat.event('TripLog.Drop', 'Send.Failed', sendMsgQueue.length);
                }
            }
            if (response && response.getResult() != 0) {
                //console.log(`[@ctrip/node-vampire-triplog] send message error, statusCode:${response.getResult()}`);
            }
        })
    }

}
export const messageQueue = new MessageQueue();

setInterval(() => { messageQueue.checkQueue() }, 1000).unref();