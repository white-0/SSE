import * as grpc from '@grpc/grpc-js';
import cat from '@ctrip/node-vampire-cat';
import pm2 from '@ctrip/node-vampire-pm2';
import { tripBootstrapServers } from './TriplogBootstrapProvider';
import { LogSenderClient } from '../../protobuf/tripLog_grpc_pb';
import { constants } from '../utils/commonConstants';
import util from '@ctrip/node-vampire-util';
import ff from '@ctrip/node-vampire-foundation-framework';
import { LogEvent, LogBatch, SendResult } from '../../protobuf/tripLog_pb';
let flag = 0;
const ChannelCredentials = grpc.ChannelCredentials.createInsecure();
const deadline = 5000;
export class RpcSender {
    private originAddressMap = {} as { [x: string]: LogSenderClient };
    private buildChannelPromise = null;

    constructor() {
        this.buildChannelPromise = this.buildChannel();
        setInterval(() => {
            this.resetChannel();
            this.buildChannel();
        }, 300000).unref();
    }

    /**
     * filter channel
     */
    buildChannel() {
        return tripBootstrapServers.fetchBootstrapServers().then(() => {
            const originAddresses: Array<string> = Object.keys(this.originAddressMap);
            const latestAddresses: Array<string> = [];
            const func = (value) => {
                const address: string = value + ':' + tripBootstrapServers.bootstrapServerPort;
                latestAddresses.push(address);
                if (!this.originAddressMap[address]) {
                    this.originAddressMap[address] = new LogSenderClient(address, ChannelCredentials, {
                        "grpc.enable_http_proxy": 0,
                        "grpc.enable_channelz": 0,
                        "grpc.enable_retries": 0,
                        "grpc.use_local_subchannel_pool": 1,
                        'grpc.default_compression_algorithm': grpc.compressionAlgorithms.gzip
                    });
                }
            };
            const severLIst = tripBootstrapServers.bootstrapServerList;
            if (pm2.count === 1) {
                severLIst.slice(0, 5).forEach((value) => {
                    func(value);
                });
            } else {
                //多进程时负载均衡,每个进程至少每个进程至少分配3个服务实例
                const num = Math.trunc(severLIst.length / ((pm2.id + 1) * 3));
                if (num >= 1) { //每个进程至少分配3个服务实例
                    severLIst.slice(pm2.id * 3, (pm2.id + 1) * 3).forEach((value) => {
                        func(value);
                    })
                } else {
                    const remainder = (pm2.id * 3) % severLIst.length; // 计算起点
                    const newArr = severLIst.concat(severLIst);
                    newArr.slice(remainder, remainder + 3).forEach((value) => {
                        func(value);
                    })
                }
            }
            originAddresses.forEach((item) => {
                if (!latestAddresses.includes(item)) {
                    // 将遗留channel关闭并移除 cheannel 
                    const client = this.originAddressMap[item];
                    delete this.originAddressMap[item];
                    //间隔一段时间再关闭,避免该地址还在被占用;
                    setTimeout(() => {
                        client.close();
                    }, 1000).unref();
                }
            })
            cat.event('TripLog.serverList', 'TripLog.serverList', JSON.stringify(Object.keys(this.originAddressMap)));
        }).catch((err) => {
            console.log('[@ctrip/node-vampire-tripLog buildChannel error]:', err.message || err);
        });
    }

    /**
     * 
     * @returns 顺序返回连接,如果channel持续时长超过60s非ready状态,则不再返回该channel
     */
    readyClient(): LogSenderClient {
        let ret = null;
        const client = Object.values(this.originAddressMap);
        for (let i = flag; i < flag + client.length; i++) {
            let index = i % client.length;
            let channel = client[index];
            const status = channel.getChannel().getConnectivityState(false);
            if (status != grpc.connectivityState.SHUTDOWN && status != grpc.connectivityState.TRANSIENT_FAILURE) {
                ret = channel;
                break;
            }
        }
        flag++;
        if (flag >= client.length) {
            flag = 0;
        }
        return ret;
    }

    /**
     * reset channel
     */
    private resetChannel() {
        const latestAddresses = Object.keys(this.originAddressMap);
        latestAddresses.forEach((address) => {
            const grpcClient = this.originAddressMap[address];
            const connectStatus = grpcClient && grpcClient.getChannel() && grpcClient.getChannel().getConnectivityState(false);
            if (connectStatus === grpc.connectivityState.SHUTDOWN || connectStatus === grpc.connectivityState.TRANSIENT_FAILURE) {
                cat.event('TripLog.delete.address', address, connectStatus);
                grpcClient.close();
                delete this.originAddressMap[address];
            }
        });
    }
    /**
     * send message to server (gzip)
     * @param logEventList Array<LogEvent>
     */
    send(logEventList: Array<LogEvent>, size: number, func: (err: any, response: SendResult) => void): void {
        let logBatch = new LogBatch() as LogBatch;
        logBatch.setDomain(ff.getAppID());
        logBatch.setSize(size);
        logBatch.setLogsList(logEventList);
        logBatch.getPropertiesMap().set(constants.KEY_GROUP, process.env['PAAS_APP_GROUPID'] || 'unknown');
        logBatch.getPropertiesMap().set(constants.KEY_HOST_ADDRESS, util.getHostIp());
        logBatch.getPropertiesMap().set(constants.KEY_HOSTNAME, util.getHostName());
        logBatch.getPropertiesMap().set(constants.KEY_SUBENV, ff.getServerPropertiesSync('subenv') || 'unknown');
        logBatch.getPropertiesMap().set(constants.KEY_ZONE, ff.getServerPropertiesSync('idc') || 'unknown');
        logBatch.getPropertiesMap().set(constants.KEY_CLOG_AZ, ff.getServerPropertiesSync('az') || 'unknown');
        logBatch.getPropertiesMap().set(constants.KEY_CLOG_REGION, ff.getServerPropertiesSync('region') || 'unknown');
        logBatch.getPropertiesMap().set(constants.KEY_CLOG_IDC, ff.getServerPropertiesSync('idc') || 'unknown');

        let client = this.readyClient();
        if (client) {
            cat.event('TripLog.client', 'triplog.address', client.getChannel().getTarget());
            client.send(logBatch, { deadline: Date.now() + deadline } as any, func);
        } else {
            cat.event('TripLog.client', 'client channel is null', client);
            func(new Error('client channel is null'), null);
        }

    }
}