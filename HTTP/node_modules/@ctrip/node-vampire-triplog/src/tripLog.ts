import { EventEmitter } from 'events';
import appConfig from '@ctrip/node-vampire-appconfig';
import { LogEvent, LogLevel } from '../protobuf/tripLog_pb';
import { tripLogMessage, TRIPLOGGING_MESSAGE_TYPES, LIMIT_RANGE, constants } from './utils/commonConstants';
import { messageQueue } from './utils/messageQueue';
import cUtil from '@ctrip/node-vampire-util';
import cache from '@ctrip/node-vampire-cache';
import Locker from '@ctrip/node-vampire-locker';
import cat from '@ctrip/node-vampire-cat';
const Cache = cache.Cache;

const cacheName = 'node-vampire-triplog-' + appConfig['AppID'];
const lockerName = 'node-vampire-triplog-' + appConfig['AppID'];

let store = new Cache(cacheName, 512 * 1024);
let locker = new Locker(lockerName);

let maxMsgSeq = 2147483647;
locker.lockSync();

if (!store[getHourString() + '-hour']) {
    store[getHourString() + '-hour'] = Math.floor(maxMsgSeq / 60) * (new Date()).getMinutes();
}
locker.unlockSync();

function getHourString() {
    return Math.floor((+new Date()) / 3600000).toString();
}

class TripLog extends EventEmitter {
    constructor() {
        super();
    }
    /**
     * @param 全链路上下文传递;会跨链路传递到下游，影响后续整个链路的调用，使用前请考虑清楚，通常只用于 traceId , orderId 字段，慎用！！！
     * @param {String} name
     * @param {any} value
     */
    setTraceContext(name: string, value: any): void {
        let currentSpan = cat.getActiveSpan();
        if (currentSpan) {
            const traceContext = currentSpan.getTraceContext && currentSpan.getTraceContext(true);
            if (!Object.keys(traceContext.getContext()).includes('triplog-' + name)) {
                traceContext.add('triplog-' + name, value);
            } else {
                console.log(`[@ctrip/node-vampire-triplog] set traceContext failed,because triplog-${name} already exists`);
            }
        }
    }
    /**
     * 新增一条clog日志
     * @param {Object} data 一条clogging数据
     * @param {String} data.type 类型
     * @param {String} data.title 标题
     * @param {any} data.message 消息内容
     * @param {Object} data.addInfo 额外信息
     * @param {boolean=} data.scenario 是否发送ck
     */
    custom(data: tripLogMessage): void {
        data = cUtil.copy(data);
        if (TRIPLOGGING_MESSAGE_TYPES.indexOf(data.type) == -1) {
            data.type = 'info';
        }
        if ((typeof data.addInfo) != 'object') {
            data.addInfo = {};
        }
        messageQueue.addToQueue(this.logEventConverter(data));
    }

    logEventConverter(data: tripLogMessage): LogEvent {
        let logEvent = new LogEvent();
        const newData: tripLogMessage = this.rebuildData(data, logEvent);
        logEvent.setId(this.cloggingId());
        logEvent.setLoglevel(LogLevel[newData.type.toLocaleUpperCase()]);
        logEvent.setLoggername(data.name || data.source || 'Nodejs');
        logEvent.setThreadid(process.pid);
        logEvent.setThreadname('Nodejs');
        logEvent.setTimestamp(new Date().getTime());
        logEvent.setMessage(Buffer.from(newData.message, 'utf-8'));
        return logEvent;
    }
    /**
    * 整理数据
    * @param {Object} data 一条clogging数据
    * @param {String} data.type 类型
    * @param {String} data.title 标题
    * @param {Array} data.message 消息内容
    * @param {Object} data.addInfo 额外信息
    * @param {boolean} data.scenario 是否发送ck
    * @return {Object} newData
    */
    private rebuildData(data: tripLogMessage, logEvent: LogEvent): tripLogMessage {
        data.title = this.sliceString(data.title, LIMIT_RANGE.DEFAULT_MAX_TAG_TITLE_LENGTH);
        if (data.type.toLocaleUpperCase() === 'ERROR') {
            if (data.message) {
                data.addInfo[constants.KEY_EXCEPTION] = 'Error';
                data.message = this.extendException(data.message);
                //记录cat日志
                cat.error('[triplog-Error]:' + (data.title || data.name), data.message);
            }
        }
        // 避免用户指定了__scenario 
        if (data.scenario && data.addInfo[constants.KEY_LOG_SCENARIO]) {
            throw new Error("[@ctirp/node-vampire-cat] don't add tag `__scenario`,when specifying scenario");
        }
        if (data.scenario && typeof data.scenario === 'string') {
            data.addInfo[constants.KEY_LOG_SCENARIO] = data.scenario;
        }
        if (data.scenario && typeof data.scenario === 'boolean') {
            data.addInfo[constants.KEY_LOG_SCENARIO] = data.title;
        }
        try {
            this.catLink(data.addInfo);
        } catch (err) {
            cat.event('triplog.catLink.error', err);
        }
        data.message = this.sliceString(data.message, LIMIT_RANGE.DEFAULT_MAX_MESSAGE_LENGTH) || '';
        let attributes = Object.assign({}, data.addInfo);
        for (let key in attributes) {
            if (cUtil.hasOwn(attributes, key)) {
                let tempKey = this.sliceString(key, LIMIT_RANGE.DEFAULT_MAX_TAG_KEY_LENGTH);
                logEvent.getPropertiesMap().set(tempKey, this.sliceString(attributes[key], LIMIT_RANGE.DEFAULT_MAX_TAG_VALUE_LENGTH));
            }
        }
        if (data.title) {
            logEvent.getPropertiesMap().set('title', data.title);
        }
        return data;
    }

    /**
     * 
     * @param value 
     * @param maxLen 
     * @returns 
     */
    private extendException(err: any): any {
        let message = null;
        switch (cUtil.type(err)) {
            case "error":
                message = (err.message || 'Error') + '\r\n----\r\n' + err.stack;
                break;
            case "string":
            case "number":
                message = "" + err;
                break;
            case "array":
            case "object":
                message = JSON.stringify(err);
                break;
            case "date":
                message = err.toLocaleString();
                break;
            default:
                message = "" + err;
                break;
        }
        return message;
    }

    /** 长度限制功能
    **  防止传入进来的数据格式不是string或者空，做一下转换。后续还要做长度校验发送
    * @param {String|Object|Error} value 原始值
    * @param {Number} maxLen 最大长度
    * @return {String} newValue 截取长度之后的新值
    */
    private sliceString(value: any, maxLen: number): string {
        if (typeof value == 'undefined') {
            return 'N/A';
        }
        switch (cUtil.type(value)) {
            case 'string':
                break;
            case 'object':
                value = JSON.stringify(value);
                break;
            default:
                value = '' + value;
                break;
        }
        return value.slice(0, maxLen);
    }
    /**
   * 获取Id
   * @return {Object} id
   */
    private cloggingId(): number {
        let msgSeq = 0;
        let hourStr = getHourString();
        msgSeq = (cache.increase(store, hourStr + '-hour', 1) as any) % maxMsgSeq;
        return msgSeq;
    }

    /**
     * clog 日志在和cat日志串联,一些关键性tag
     */
    catLink(tags: object): void {
        let markNewSpan: boolean = false;
        let currentSpan = null;
        if (cat.getActiveSpan()) {
            currentSpan = cat.getActiveSpan();
        }
        if (currentSpan) {
            !currentSpan.__properties && (currentSpan.__properties = {});
            if ((cat as any).setPropertiesToRootActiveSpan) {
                (cat as any).setPropertiesToRootActiveSpan('Cat.LinkType', 'marker');
            } else { //兼容老版本1.0.108及以下
                Object.assign((currentSpan.__root || currentSpan).__properties, { 'Cat.LinkType': 'marker' });
            }
            const messgeId = (currentSpan.__root && currentSpan.__root.__outerIds) ? currentSpan.__root.__outerIds['x-cat-id'] : (currentSpan && currentSpan.__messageId); //父节点的messageId;
            const traceContext = currentSpan.getTraceContext && currentSpan.getTraceContext(true).getContext();
            let markerId = 0;
            const _traceContext = currentSpan.getTraceContext && currentSpan.getTraceContext(true);
            if (_traceContext && _traceContext.increaseMarkerId) {
                _traceContext && _traceContext.increaseMarkerId();
                markerId = _traceContext.markerId || 0;
            } else {
                if (!currentSpan.__root.markerId) {
                    currentSpan.__root.markerId = 0;
                }
                markerId = currentSpan.__root.markerId++;
            }
            for (let item in traceContext) {
                if (item.startsWith('triplog-') && Object.prototype.hasOwnProperty.call(traceContext, item)) {
                    tags[item.substr(8)] = traceContext[item];
                }
            }


            if (tags[constants.KEY_LOG_SCENARIO]) {
                const scenario = tags[constants.KEY_LOG_SCENARIO];
                if (scenario != constants.LABEL_DEFAULT) {
                    this.setScenario(scenario, currentSpan);
                    cat.event('__Clickhouse__', scenario, String(markerId));
                } else {
                    cat.event('__CLOG__', '__DEFAULT__', String(markerId));
                }
            } else {
                cat.event('__CLOG__', '__DEFAULT__', String(markerId));
            }
            tags[constants.KEY_CAT_MESSAGE_ID] = messgeId;
            tags[constants.KEY_CAT_MARKER_ID] = String(markerId);
            markNewSpan && currentSpan.end();
        }
    }

    private setScenario(scenario: string, currentSpan: any): void {
        if (!currentSpan) return;
        if (!currentSpan.__properties) {
            currentSpan.__properties = {};
        }
        const m_scenarios = currentSpan.__properties[constants.SCENARIOS_KEYS];
        let ret: any = scenario;
        if (m_scenarios) {
            ret = m_scenarios + '|' + scenario;
        }
        currentSpan.__properties[constants.SCENARIOS_KEYS] = ret;
    }
}

export const tripLog = new TripLog();