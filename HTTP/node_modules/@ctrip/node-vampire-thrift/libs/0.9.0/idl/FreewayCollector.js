//
// Autogenerated by Thrift Compiler (0.9.0)
//
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
//
const InfinityLoop = true;

const Thrift = require('../thrift').Thrift;

const FreewayService = require('./FreewayService')
const FreewayServiceClient = FreewayService.Client
const FreewayServiceProcessor = FreewayService.Processor
const ttypes = require('./clogging_v2_types');
//HELPER FUNCTIONS AND STRUCTURES

let FreewayCollector_produce_args = function(args) {
    this.chunk = null;
    if (args) {
        if (args.chunk !== undefined) {
            this.chunk = args.chunk;
        }
    }
};
FreewayCollector_produce_args.prototype = {};
FreewayCollector_produce_args.prototype.read = function(input) {
    input.readStructBegin();
    while (InfinityLoop) {
        let ret = input.readFieldBegin();
        // let fname = ret.fname;
        let ftype = ret.ftype;
        let fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
            break;
        }
        switch (fid) {
            case 1:
                if (ftype == Thrift.Type.STRUCT) {
                    this.chunk = new ttypes.Chunk();
                    this.chunk.read(input);
                } else {
                    input.skip(ftype);
                }
                break;
            case 0:
                input.skip(ftype);
                break;
            default:
                input.skip(ftype);
        }
        input.readFieldEnd();
    }
    input.readStructEnd();
    return;
};

FreewayCollector_produce_args.prototype.write = function(output) {
    output.writeStructBegin('FreewayCollector_produce_args');
    if (this.chunk !== null && this.chunk !== undefined) {
        output.writeFieldBegin('chunk', Thrift.Type.STRUCT, 1);
        this.chunk.write(output);
        output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
};

let FreewayCollector_produce_result = function(args) {
    this.success = null;
    if (args) {
        if (args.success !== undefined) {
            this.success = args.success;
        }
    }
};
FreewayCollector_produce_result.prototype = {};
FreewayCollector_produce_result.prototype.read = function(input) {
    input.readStructBegin();
    while (InfinityLoop) {
        let ret = input.readFieldBegin();
        // let fname = ret.fname;
        let ftype = ret.ftype;
        let fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
            break;
        }
        switch (fid) {
            case 0:
                if (ftype == Thrift.Type.STRUCT) {
                    this.success = new ttypes.Result();
                    this.success.read(input);
                } else {
                    input.skip(ftype);
                }
                break;
            default:
                input.skip(ftype);
        }
        input.readFieldEnd();
    }
    input.readStructEnd();
    return;
};

FreewayCollector_produce_result.prototype.write = function(output) {
    output.writeStructBegin('FreewayCollector_produce_result');
    if (this.success !== null && this.success !== undefined) {
        output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
        this.success.write(output);
        output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
};

let FreewayCollector_send_args = function(args) {
    this.data = null;
    this.compressionType = null;
    this.uncompressedLength = null;
    if (args) {
        if (args.data !== undefined) {
            this.data = args.data;
        }
        if (args.compressionType !== undefined) {
            this.compressionType = args.compressionType;
        }
        if (args.uncompressedLength !== undefined) {
            this.uncompressedLength = args.uncompressedLength;
        }
    }
};
FreewayCollector_send_args.prototype = {};
FreewayCollector_send_args.prototype.read = function(input) {
    input.readStructBegin();
    while (InfinityLoop) {
        let ret = input.readFieldBegin();
        // let fname = ret.fname;
        let ftype = ret.ftype;
        let fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
            break;
        }
        switch (fid) {
            case 1:
                if (ftype == Thrift.Type.STRING) {
                    this.data = input.readString();
                } else {
                    input.skip(ftype);
                }
                break;
            case 2:
                if (ftype == Thrift.Type.I32) {
                    this.compressionType = input.readI32();
                } else {
                    input.skip(ftype);
                }
                break;
            case 3:
                if (ftype == Thrift.Type.I32) {
                    this.uncompressedLength = input.readI32();
                } else {
                    input.skip(ftype);
                }
                break;
            default:
                input.skip(ftype);
        }
        input.readFieldEnd();
    }
    input.readStructEnd();
    return;
};

FreewayCollector_send_args.prototype.write = function(output) {
    output.writeStructBegin('FreewayCollector_send_args');
    if (this.data !== null && this.data !== undefined) {
        output.writeFieldBegin('data', Thrift.Type.STRING, 1);
        output.writeString(this.data);
        output.writeFieldEnd();
    }
    if (this.compressionType !== null && this.compressionType !== undefined) {
        output.writeFieldBegin('compressionType', Thrift.Type.I32, 2);
        output.writeI32(this.compressionType);
        output.writeFieldEnd();
    }
    if (this.uncompressedLength !== null && this.uncompressedLength !== undefined) {
        output.writeFieldBegin('uncompressedLength', Thrift.Type.I32, 3);
        output.writeI32(this.uncompressedLength);
        output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
};

let FreewayCollector_send_result = function(args) {
    this.success = null;
    if (args) {
        if (args.success !== undefined) {
            this.success = args.success;
        }
    }
};
FreewayCollector_send_result.prototype = {};
FreewayCollector_send_result.prototype.read = function(input) {
    input.readStructBegin();
    while (InfinityLoop) {
        let ret = input.readFieldBegin();
        // let fname = ret.fname;
        let ftype = ret.ftype;
        let fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
            break;
        }
        switch (fid) {
            case 0:
                if (ftype == Thrift.Type.STRUCT) {
                    this.success = new ttypes.Result();
                    this.success.read(input);
                } else {
                    input.skip(ftype);
                }
                break;
            default:
                input.skip(ftype);
        }
        input.readFieldEnd();
    }
    input.readStructEnd();
    return;
};

FreewayCollector_send_result.prototype.write = function(output) {
    output.writeStructBegin('FreewayCollector_send_result');
    if (this.success !== null && this.success !== undefined) {
        output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
        this.success.write(output);
        output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
};

let FreewayCollector_consume_args = function(args) {
    this.queueName = null;
    if (args) {
        if (args.queueName !== undefined) {
            this.queueName = args.queueName;
        }
    }
};
FreewayCollector_consume_args.prototype = {};
FreewayCollector_consume_args.prototype.read = function(input) {
    input.readStructBegin();
    while (InfinityLoop) {
        let ret = input.readFieldBegin();
        // let fname = ret.fname;
        let ftype = ret.ftype;
        let fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
            break;
        }
        switch (fid) {
            case 1:
                if (ftype == Thrift.Type.STRING) {
                    this.queueName = input.readString();
                } else {
                    input.skip(ftype);
                }
                break;
            case 0:
                input.skip(ftype);
                break;
            default:
                input.skip(ftype);
        }
        input.readFieldEnd();
    }
    input.readStructEnd();
    return;
};

FreewayCollector_consume_args.prototype.write = function(output) {
    output.writeStructBegin('FreewayCollector_consume_args');
    if (this.queueName !== null && this.queueName !== undefined) {
        output.writeFieldBegin('queueName', Thrift.Type.STRING, 1);
        output.writeString(this.queueName);
        output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
};

let FreewayCollector_consume_result = function(args) {
    this.success = null;
    if (args) {
        if (args.success !== undefined) {
            this.success = args.success;
        }
    }
};
FreewayCollector_consume_result.prototype = {};
FreewayCollector_consume_result.prototype.read = function(input) {
    input.readStructBegin();
    while (InfinityLoop) {
        let ret = input.readFieldBegin();
        // let fname = ret.fname;
        let ftype = ret.ftype;
        let fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
            break;
        }
        switch (fid) {
            case 0:
                if (ftype == Thrift.Type.STRUCT) {
                    this.success = new ttypes.Response();
                    this.success.read(input);
                } else {
                    input.skip(ftype);
                }
                break;
            default:
                input.skip(ftype);
        }
        input.readFieldEnd();
    }
    input.readStructEnd();
    return;
};

FreewayCollector_consume_result.prototype.write = function(output) {
    output.writeStructBegin('FreewayCollector_consume_result');
    if (this.success !== null && this.success !== undefined) {
        output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
        this.success.write(output);
        output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
};

let FreewayCollector_getCollectors_args = function(args) {
    this.appId = null;
    this.hostIp = null;
    if (args) {
        if (args.appId !== undefined) {
            this.appId = args.appId;
        }
        if (args.hostIp !== undefined) {
            this.hostIp = args.hostIp;
        }
    }
};
FreewayCollector_getCollectors_args.prototype = {};
FreewayCollector_getCollectors_args.prototype.read = function(input) {
    input.readStructBegin();
    while (InfinityLoop) {
        let ret = input.readFieldBegin();
        // let fname = ret.fname;
        let ftype = ret.ftype;
        let fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
            break;
        }
        switch (fid) {
            case 1:
                if (ftype == Thrift.Type.STRING) {
                    this.appId = input.readString();
                } else {
                    input.skip(ftype);
                }
                break;
            case 2:
                if (ftype == Thrift.Type.STRING) {
                    this.hostIp = input.readString();
                } else {
                    input.skip(ftype);
                }
                break;
            default:
                input.skip(ftype);
        }
        input.readFieldEnd();
    }
    input.readStructEnd();
    return;
};

FreewayCollector_getCollectors_args.prototype.write = function(output) {
    output.writeStructBegin('FreewayCollector_getCollectors_args');
    if (this.appId !== null && this.appId !== undefined) {
        output.writeFieldBegin('appId', Thrift.Type.STRING, 1);
        output.writeString(this.appId);
        output.writeFieldEnd();
    }
    if (this.hostIp !== null && this.hostIp !== undefined) {
        output.writeFieldBegin('hostIp', Thrift.Type.STRING, 2);
        output.writeString(this.hostIp);
        output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
};

let FreewayCollector_getCollectors_result = function(args) {
    this.success = null;
    if (args) {
        if (args.success !== undefined) {
            this.success = args.success;
        }
    }
};
FreewayCollector_getCollectors_result.prototype = {};
FreewayCollector_getCollectors_result.prototype.read = function(input) {
    input.readStructBegin();
    while (InfinityLoop) {
        let ret = input.readFieldBegin();
        // let fname = ret.fname;
        let ftype = ret.ftype;
        let fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
            break;
        }
        switch (fid) {
            case 0:
                if (ftype == Thrift.Type.LIST) {
                    let _size224 = 0;
                    let _rtmp3228;
                    this.success = [];
                    // let _etype227 = 0;
                    _rtmp3228 = input.readListBegin();
                    // _etype227 = _rtmp3228.etype;
                    _size224 = _rtmp3228.size;
                    for (let _i229 = 0; _i229 < _size224; ++_i229) {
                        let elem230 = null;
                        elem230 = input.readString();
                        this.success.push(elem230);
                    }
                    input.readListEnd();
                } else {
                    input.skip(ftype);
                }
                break;
            default:
                input.skip(ftype);
        }
        input.readFieldEnd();
    }
    input.readStructEnd();
    return;
};

FreewayCollector_getCollectors_result.prototype.write = function(output) {
    output.writeStructBegin('FreewayCollector_getCollectors_result');
    if (this.success !== null && this.success !== undefined) {
        output.writeFieldBegin('success', Thrift.Type.LIST, 0);
        output.writeListBegin(Thrift.Type.STRING, this.success.length);
        for (let iter231 in this.success) {
            if (Object.prototype.hasOwnProperty.call(this.success, iter231)) {
                iter231 = this.success[iter231];
                output.writeString(iter231);
            }
        }
        output.writeListEnd();
        output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
};

let FreewayCollectorClient = exports.Client = function(output, pClass) {
    this.output = output;
    this.pClass = pClass;
    this.seqid = 0;
    this._reqs = {};
};
Thrift.inherits(FreewayCollectorClient, FreewayServiceClient)
FreewayCollectorClient.prototype.produce = function(chunk, callback) {
    this.seqid += 1;
    this._reqs[this.seqid] = callback;
    this.send_produce(chunk);
};

FreewayCollectorClient.prototype.send_produce = function(chunk) {
    let output = new this.pClass(this.output);
    output.writeMessageBegin('produce', Thrift.MessageType.CALL, this.seqid);
    let args = new FreewayCollector_produce_args();
    args.chunk = chunk;
    args.write(output);
    output.writeMessageEnd();
    return this.output.flush();
};

FreewayCollectorClient.prototype.recv_produce = function(input, mtype, rseqid) {
    let callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
        let x = new Thrift.TApplicationException();
        x.read(input);
        input.readMessageEnd();
        return callback(x);
    }
    let result = new FreewayCollector_produce_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.success) {
        return callback(null, result.success);
    }
    return callback('produce failed: unknown result');
};
FreewayCollectorClient.prototype.send = function(data, compressionType, uncompressedLength, callback) {
    this.seqid += 1;
    this._reqs[this.seqid] = callback;
    this.send_send(data, compressionType, uncompressedLength);
};

FreewayCollectorClient.prototype.send_send = function(data, compressionType, uncompressedLength) {
    let output = new this.pClass(this.output);
    output.writeMessageBegin('send', Thrift.MessageType.CALL, this.seqid);
    let args = new FreewayCollector_send_args();
    args.data = data;
    args.compressionType = compressionType;
    args.uncompressedLength = uncompressedLength;
    args.write(output);
    output.writeMessageEnd();
    return this.output.flush();
};

FreewayCollectorClient.prototype.recv_send = function(input, mtype, rseqid) {
    let callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
        let x = new Thrift.TApplicationException();
        x.read(input);
        input.readMessageEnd();
        return callback(x);
    }
    let result = new FreewayCollector_send_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.success) {
        return callback(null, result.success);
    }
    return callback('send failed: unknown result');
};
FreewayCollectorClient.prototype.consume = function(queueName, callback) {
    this.seqid += 1;
    this._reqs[this.seqid] = callback;
    this.send_consume(queueName);
};

FreewayCollectorClient.prototype.send_consume = function(queueName) {
    let output = new this.pClass(this.output);
    output.writeMessageBegin('consume', Thrift.MessageType.CALL, this.seqid);
    let args = new FreewayCollector_consume_args();
    args.queueName = queueName;
    args.write(output);
    output.writeMessageEnd();
    return this.output.flush();
};

FreewayCollectorClient.prototype.recv_consume = function(input, mtype, rseqid) {
    let callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
        let x = new Thrift.TApplicationException();
        x.read(input);
        input.readMessageEnd();
        return callback(x);
    }
    let result = new FreewayCollector_consume_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.success) {
        return callback(null, result.success);
    }
    return callback('consume failed: unknown result');
};
FreewayCollectorClient.prototype.getCollectors = function(appId, hostIp, callback) {
    this.seqid += 1;
    this._reqs[this.seqid] = callback;
    this.send_getCollectors(appId, hostIp);
};

FreewayCollectorClient.prototype.send_getCollectors = function(appId, hostIp) {
    let output = new this.pClass(this.output);
    output.writeMessageBegin('getCollectors', Thrift.MessageType.CALL, this.seqid);
    let args = new FreewayCollector_getCollectors_args();
    args.appId = appId;
    args.hostIp = hostIp;
    args.write(output);
    output.writeMessageEnd();
    return this.output.flush();
};

FreewayCollectorClient.prototype.recv_getCollectors = function(input, mtype, rseqid) {
    let callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
        let x = new Thrift.TApplicationException();
        x.read(input);
        input.readMessageEnd();
        return callback(x);
    }
    let result = new FreewayCollector_getCollectors_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.success) {
        return callback(null, result.success);
    }
    return callback('getCollectors failed: unknown result');
};
let FreewayCollectorProcessor = exports.Processor = function(handler) {
    this._handler = handler
}
Thrift.inherits(FreewayCollectorProcessor, FreewayServiceProcessor)
FreewayCollectorProcessor.prototype.process = function(input, output) {
    let r = input.readMessageBegin();
    if (this['process_' + r.fname]) {
        return this['process_' + r.fname].call(this, r.rseqid, input, output);
    } else {
        input.skip(Thrift.Type.STRUCT);
        input.readMessageEnd();
        let x = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN_METHOD, 'Unknown function ' + r.fname);
        output.writeMessageBegin(r.fname, Thrift.MessageType.Exception, r.rseqid);
        x.write(output);
        output.writeMessageEnd();
        output.flush();
    }
}

FreewayCollectorProcessor.prototype.process_produce = function(seqid, input, output) {
    let args = new FreewayCollector_produce_args();
    args.read(input);
    input.readMessageEnd();
    this._handler.produce(args.chunk, function(err, result) {
        result = new FreewayCollector_produce_result((err != null ? err : {
            success: result
        }));
        output.writeMessageBegin("produce", Thrift.MessageType.REPLY, seqid);
        result.write(output);
        output.writeMessageEnd();
        output.flush();
    })
}

FreewayCollectorProcessor.prototype.process_send = function(seqid, input, output) {
    let args = new FreewayCollector_send_args();
    args.read(input);
    input.readMessageEnd();
    this._handler.send(args.data, args.compressionType, args.uncompressedLength, function(err, result) {
        result = new FreewayCollector_send_result((err != null ? err : {
            success: result
        }));
        output.writeMessageBegin("send", Thrift.MessageType.REPLY, seqid);
        result.write(output);
        output.writeMessageEnd();
        output.flush();
    })
}

FreewayCollectorProcessor.prototype.process_consume = function(seqid, input, output) {
    let args = new FreewayCollector_consume_args();
    args.read(input);
    input.readMessageEnd();
    this._handler.consume(args.queueName, function(err, result) {
        result = new FreewayCollector_consume_result((err != null ? err : {
            success: result
        }));
        output.writeMessageBegin("consume", Thrift.MessageType.REPLY, seqid);
        result.write(output);
        output.writeMessageEnd();
        output.flush();
    })
}

FreewayCollectorProcessor.prototype.process_getCollectors = function(seqid, input, output) {
    let args = new FreewayCollector_getCollectors_args();
    args.read(input);
    input.readMessageEnd();
    this._handler.getCollectors(args.appId, args.hostIp, function(err, result) {
        result = new FreewayCollector_getCollectors_result((err != null ? err : {
            success: result
        }));
        output.writeMessageBegin("getCollectors", Thrift.MessageType.REPLY, seqid);
        result.write(output);
        output.writeMessageEnd();
        output.flush();
    })
}