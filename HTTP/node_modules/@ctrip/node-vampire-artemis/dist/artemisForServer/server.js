"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Server = void 0;
const os_1 = __importDefault(require("os"));
const node_vampire_util_1 = __importDefault(require("@ctrip/node-vampire-util"));
const node_vampire_cat_1 = __importDefault(require("@ctrip/node-vampire-cat"));
const appConfig_1 = require("../appConfig");
const node_vampire_http_1 = __importDefault(require("@ctrip/node-vampire-http"));
const getArtemisServerList_1 = require("../utils/getArtemisServerList");
const _getArtemisServerList = { qschedule: null, soa: null };
const OPERATION_NAME = 'service';
const utils_1 = require("../utils/utils");
const console = require('@ctrip/node-vampire-console')('vampire:artemis');
class Server {
    constructor(clientType) {
        this.config = {};
        this.ServerIp = node_vampire_util_1.default.getHostIp();
        this.ServerPort = 80; // 目前是固定值，不用修改
        this.host = this.ServerIp + (this.ServerPort === 80 ? '' : ':' + this.ServerPort);
        this.RegionId = 'sha'; // 暂时固定为 上海
        this.ZoneId = '';
        this.HealthCheckUrl = '/checkhealth.json';
        this.StartUpTime = new Date();
        this.clientType = clientType || utils_1.CallerType.SOA; // 区分qschedule 或 soa
    }
    /**
     * artemis register
     * @param c {
        AppID: string,
        ServiceId: string,
        ServerPort?: number,
        vd: string,
        Env: string,
        frameworkVersion: string
    }  Service Registration Parameters
     */
    initConfig(c) {
        Object.assign(this.config, c);
    }
    _getInstance() {
        const isSOA = this.clientType === utils_1.CallerType.SOA;
        return ({
            'Instances': [{
                    'RegionId': this.RegionId,
                    'ZoneId': this.ZoneId.toLowerCase(),
                    'GroupId': this.config['AppID'],
                    'ServiceId': this.config['ServiceId'],
                    'InstanceId': isSOA ? this.ServerIp : this.config['InstanceId'],
                    'MachineName': os_1.default.hostname(),
                    'IP': this.ServerIp,
                    'Port': this.config['ServerPort'],
                    'Protocol': isSOA ? 'http' : this.config['Protocol'],
                    'Url': isSOA ? `http://${this.host}${this.config.vd}` : this.config['Url'],
                    'HealthCheckUrl': isSOA ? `http://${this.host}${this.config.vd}${this.HealthCheckUrl}` : null,
                    'Status': 'up',
                    'Metadata': {
                        'appid': this.config['AppID'],
                        'available': 'true',
                        'subenv': appConfig_1.appConfig['subEnv'] ? appConfig_1.appConfig['subEnv'].toLowerCase() : this.config['Env'],
                        'framework-version': this.config['frameworkVersion'],
                        'StartUpTime': this.StartUpTime
                    }
                }]
        });
    }
    /**
     * send heartBeat
     * @returns Promise<void>
     */
    heartBeat() {
        if (!_getArtemisServerList[this.clientType]) {
            _getArtemisServerList[this.clientType] = new getArtemisServerList_1.ArtemisServerList(OPERATION_NAME, this.clientType);
        }
        return _getArtemisServerList[this.clientType].artemisPromise.then(() => {
            this.ZoneId = appConfig_1.appConfig['Artemis.Zone.Service.Id'];
            const option = JSON.stringify(this._getInstance());
            return this._intervalHeartBeat(option);
        }).catch((errs) => {
            throw errs;
        });
    }
    /**
     * Send heartbeat every 5s
     * @returns Promise<void>
     */
    _intervalHeartBeat(option) {
        return this._setHeartBeat(option, node_vampire_util_1.default.copy(appConfig_1.appConfig[this.clientType]['artemis.registry.Promise.Url'])).then((datas) => {
            setInterval(() => {
                this._setHeartBeat(option, node_vampire_util_1.default.copy(appConfig_1.appConfig[this.clientType]['artemis.registry.Promise.Url'])).catch((err) => {
                    console.warn('Send registry heartbeat err :', err);
                });
            }, 5000);
            return datas;
        }).catch((err) => {
            throw err;
        });
    }
    _setHeartBeat(option, server_lists) {
        return new Promise((resolve, reject) => {
            if (server_lists && Array.isArray(server_lists) && server_lists.length > 0) {
                const random = Math.floor(Math.random() * server_lists.length);
                const _RootUrl = (0, utils_1.checkUrl)(server_lists[random].url);
                if (!_RootUrl) {
                    reject('url is not valid');
                    node_vampire_cat_1.default.event('Artemis.registry.heartbeat.error', 'url ' + server_lists[random].url + ' is invalid');
                    return;
                }
                node_vampire_cat_1.default.event('Artemis.registry.heartbeat.url', _RootUrl.toString());
                (0, node_vampire_http_1.default)(_RootUrl + 'api/registry/heartbeat.json', {
                    headers: {
                        'Content-Type': 'application/json',
                        'x-client-appid': appConfig_1.appConfig['AppID'],
                        'x-client-idc': appConfig_1.appConfig['idc']
                    }
                }, option).then((data) => {
                    // console.log('recv message', data) //test
                    // let failedInstances = null;
                    try {
                        if (data) {
                            const json = JSON.parse(data);
                            if (json && json.responseStatus && json.responseStatus.status === 'success') {
                                // cat.event('Artemis.registry.heartbeat.success', data);
                                resolve(0);
                            }
                            else {
                                node_vampire_cat_1.default.event('Artemis.registry.heartbeat.error', data);
                                return reject(json);
                            }
                            // failedInstances = json && json.failedInstances;
                        }
                    }
                    catch (e) {
                        node_vampire_cat_1.default.event('Artemis.registry.heartbeat.error', data);
                        return Promise.reject(e);
                    }
                    // if (util.type(failedInstances) === 'array' && failedInstances.length > 0) {
                    //     const Instances = [];
                    //     failedInstances.forEach((fi) => {
                    //         if (fi === null) {
                    //             return;
                    //         }
                    //         if (fi.errorCode === 'data-not-found') {
                    //             Instances.push(fi.instance);
                    //         }
                    //     });
                    //     if (Instances.length > 0) {
                    //         return this._register(_RootUrl).then((datas) => {
                    //             console.log('SOA instance registered successfully. ', datas);
                    //             datas = JSON.parse(datas);
                    //             if (datas && datas.responseStatus && datas.responseStatus.status === 'success') {
                    //                 resolve(datas);
                    //             } else {
                    //                 throw new Error('Registration failed: ' + JSON.stringify(datas));
                    //             }
                    //         }).catch((err) => {
                    //             console.error('SOA instance registered failed. ', err);
                    //             throw err;
                    //         });
                    //     } else {
                    //         resolve(0);
                    //     }
                    // } else {
                    //     resolve(0);
                    // }
                }).catch((err) => {
                    node_vampire_cat_1.default.event('Artemis.registry.heartbeat.error', err);
                    const specialErrorCodes = ['ECONNREFUSED', 'ECONNRESET', 'ETIMEDOUT'];
                    if (specialErrorCodes.includes(err.code)) {
                        server_lists.splice(random, 1);
                        return this._setHeartBeat(option, server_lists).then(resolve, reject);
                    }
                    else {
                        reject(err);
                    }
                });
            }
            else {
                reject('None Available Server, Servers:' + server_lists);
            }
        });
    }
}
exports.Server = Server;
