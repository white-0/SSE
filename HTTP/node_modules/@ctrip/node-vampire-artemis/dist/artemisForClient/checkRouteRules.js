"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CheckRouteRules = void 0;
const appConfig_1 = require("../appConfig");
const node_vampire_cat_1 = __importDefault(require("@ctrip/node-vampire-cat"));
const utils_1 = require("../utils/utils");
/*
 * 路由匹配优先级：请求路由(custom-*) > 操作路由 > 默认路由(default-route-rule)。如：已配置操作路由但该路由未找到匹配的实例则报错
 * 在匹配时检查instances 和 logicInstances中实例时，若路由的weight为0或匹配不到都报错
 */
class CheckRouteRules {
    constructor(opt) {
        this.subEnv = !['uat', 'pro'].includes(appConfig_1.appConfig['Env']) && opt.subEnv ? opt.subEnv : null; //uat,pro不考虑子环境
        this.zoneId = (appConfig_1.appConfig['Artemis.Zone.Service.Id'] || '').toLowerCase();
        this.routeContext = [];
        this.region = (appConfig_1.appConfig['region'] || '').toLowerCase();
    }
    /*
     * 注意fatx/lptx 子环境问题：
     * 请求路由：只在当前路由下匹配子环境
     * 操作路由：若当前子环境下匹配不到服务则fallback到默认路由
     * 默认路由：在当前子环境匹配实例,匹配不到时：在该路由分组范围内，按照优先级排序匹配fws/其他子环境
     */
    getAvailableServers(lookUpServices, ucs_strategy) {
        const routeRules = lookUpServices.routeRules, _routeContext = {
            'customConstraints': [],
            'defaultConstraints': [],
            'operationConstraints': [],
            'custom': [],
            'operation': [],
            'default': []
        };
        const customKey = /^custom-.*?/, defaultKey = /^default-route-rule$/, customConstraintsKey = /^custom-.*:constraints$/, defaultConstraintsKey = /^default-route-rule:constraints$/;
        routeRules.forEach((itemGroup) => {
            // 过滤压测路由条件
            const currentRouteContext = {};
            let keyName = null;
            const _key = itemGroup.routeId;
            if (itemGroup.constraints && Object.keys(itemGroup.constraints).length > 0 && itemGroup.constraints['context'] && itemGroup.constraints['context'].length > 0) {
                currentRouteContext[_key] = this._getAvailableServers(lookUpServices.instances, lookUpServices.logicInstances, itemGroup, ucs_strategy);
                currentRouteContext['context'] = itemGroup.constraints['context'];
                if (customConstraintsKey.test(_key)) {
                    keyName = 'customConstraints';
                }
                else if (defaultConstraintsKey.test(_key)) {
                    keyName = 'defaultConstraints';
                }
                else {
                    keyName = 'operationConstraints';
                }
            }
            else {
                currentRouteContext[_key] = this._getAvailableServers(lookUpServices.instances, lookUpServices.logicInstances, itemGroup, ucs_strategy);
                if (customKey.test(_key)) {
                    keyName = 'custom';
                }
                else if (defaultKey.test(_key)) {
                    keyName = 'default';
                }
                else {
                    keyName = 'operation';
                }
            }
            _routeContext[keyName].push(currentRouteContext);
        });
        if (_routeContext['default'].length === 0) {
            _routeContext['default'].push({ [utils_1.DEFAULT_ROUTE_RULE]: this.generateInstance(lookUpServices.instances) });
        }
        this.routeContext = _routeContext['customConstraints']
            .concat(_routeContext['operationConstraints'])
            .concat(_routeContext['defaultConstraints'])
            .concat(_routeContext['custom'])
            .concat(_routeContext['operation'])
            .concat(_routeContext['default']);
    }
    _getAvailableServers(instances, logicInstances, routeRule, ucs_strategy, subEnv) {
        let routesGroups_Arr = [], routesGroups_close_Arr = [], routesGroups_close_force_Arr = [], routesGroups_ucs_Arr = [];
        const routesArr = routeRule.groups;
        let _firstPrioritySubEnv = null;
        const _subEnv = subEnv || this.subEnv;
        for (let item = 0; item < routesArr.length; item++) {
            if (routesArr[item].weight == 0) {
                continue;
            }
            const routes_item = routesArr[item], group_new = {
                weight: routes_item['weight'],
                urls: [],
                zone: null,
                strategy: routeRule.strategy
            }, group_close_new = {
                weight: routes_item['weight'],
                urls: [],
                zone: this.zoneId,
                strategy: null
            }, group_close_force_new = {
                weight: routes_item['weight'],
                urls: [],
                zone: this.zoneId,
                strategy: null
            }, group_ucs_new = {
                weight: routes_item['weight'],
                urls: [],
                zone: null,
                strategy: null
            };
            const filterInstances = (ins, type) => {
                for (let _item = 0; _item < ins.length; _item++) {
                    const ins_item = ins[_item];
                    const reg = `${ins_item.regionId}/${ins_item.zoneId.toLowerCase()}/${ins_item.groupId}`;
                    const groupKey_match = routes_item['groupKey'].endsWith(reg);
                    const matchInstance = type == 'instances' ? (groupKey_match || routes_item.ips.includes(ins_item.ip)) : routes_item.instanceIds.includes(ins_item.instanceId);
                    if (matchInstance) {
                        // aws (没有ins_item.metadata.subenv),pro|| fws,uat || fatX,lptX
                        let isMatchRoute = false;
                        if (/(pr[od]d?)/.test(appConfig_1.appConfig['Env']) || appConfig_1.appConfig['Env'] == 'uat' || !_subEnv && !ins_item.metadata.subenv) {
                            isMatchRoute = true;
                        }
                        else if (ins_item.metadata.subenv == '*') { //标识匹配所有子环境(fws/fatX)
                            isMatchRoute = true;
                        }
                        else if (!_subEnv && new RegExp(`\\b${appConfig_1.appConfig['Env']}\\b`, 'i').test(ins_item.metadata.subenv) || _subEnv && new RegExp(`\\b${_subEnv}\\b`, 'i').test(ins_item.metadata.subenv)) {
                            isMatchRoute = true;
                        }
                        if (isMatchRoute) {
                            // 就近访问(开启ucs策略一定开启了就近访问): 
                            if (ucs_strategy) {
                                group_ucs_new['strategy'] = routeRule.strategy;
                                group_ucs_new['zone'] = ins_item.zoneId.toLowerCase();
                                !group_ucs_new['urls'].includes(ins_item.url) && group_ucs_new['urls'].push(ins_item.url);
                            }
                            if (routeRule.strategy === utils_1.STRATEGY) {
                                group_close_new['strategy'] = routeRule.strategy;
                                if (this.zoneId === ins_item.zoneId.toLowerCase()) {
                                    !group_close_new['urls'].includes(ins_item.url) && group_close_new['urls'].push(ins_item.url);
                                }
                                // 2024/1/18: 就近访问支持从idc降级到region 匹配
                                if ((ins_item.zoneId || '').toLowerCase().startsWith(this.region)) {
                                    !group_close_force_new['urls'].includes(ins_item.url) && group_close_force_new['urls'].push(ins_item.url);
                                }
                            }
                            if (!group_new['urls'].includes(ins_item.url)) {
                                group_new['urls'].push(ins_item.url);
                            }
                        }
                        // 在该路由分组对应的instances/logicInstances下取优先级最高的子环境对应的机器(只有默认路由执行该过程)
                        //2020/4/24 修改：fws应用可以访问子环境的实例,和webapi对齐（不再参考这个文档：http://conf.ctripcorp.com/pages/viewpage.action?pageId=159208306）
                        if ((this.subEnv || appConfig_1.appConfig['Env'] === 'fws') && ins_item.metadata.subenv && routeRule.routeId === 'default-route-rule') {
                            _firstPrioritySubEnv = (0, utils_1.getFirstPrioritySubEnv)(ins_item.metadata.subenv, null, _firstPrioritySubEnv);
                        }
                    }
                }
            };
            filterInstances(instances, 'instances');
            filterInstances(logicInstances, 'logicInstances');
            if (group_close_new.urls.length > 0) {
                routesGroups_close_Arr.push(group_close_new);
            }
            if (group_close_force_new.urls.length > 0) {
                routesGroups_close_force_Arr.push(group_close_force_new);
            }
            if (group_new.urls.length > 0) {
                routesGroups_Arr.push(group_new);
            }
            if (ucs_strategy && group_ucs_new.urls.length > 0) {
                routesGroups_ucs_Arr.push(group_ucs_new);
            }
        }
        // 2024/1/18: 就近访问支持从idc降级到region 匹配
        if (routesGroups_close_Arr.length === 0)
            routesGroups_close_Arr = routesGroups_close_force_Arr;
        //优先就近访问匹配实例
        const serverList = routesGroups_close_Arr.length > 0 ? routesGroups_close_Arr : routesGroups_Arr;
        // 当前环境为子环境时：若默认路由中找不到对应子环境的服务，则按照优先级从fws及其他子环境中查找
        if (serverList.length === 0 && _firstPrioritySubEnv) {
            return this._getAvailableServers(instances, logicInstances, routeRule, ucs_strategy, _firstPrioritySubEnv.subEnv);
        }
        return {
            serverList,
            ucsServerList: routesGroups_ucs_Arr
        };
    }
    /**
     * 匹配路由规则
     * @param routeContext
     * @param operationName
     * @param routeId
     * @param isUcs
     * @returns
     */
    static reRoute(routeContext, operationName, routeId, isUcs = false) {
        // constraints请求路由 > constraints操作路由 > constraints默认路由> 请求路由 > 操作路由 > 默认路由 
        //2024/1/17注释掉,因为nodejs层不再处理ucs: const _key = isUcs ? 'ucsServerList' : 'serverList';
        const _key = 'serverList';
        operationName && (operationName = operationName.toLowerCase());
        let reRouteMsg = null;
        for (const item of routeContext) {
            let isMatchRoute = true;
            if (item.context) {
                isMatchRoute = CheckRouteRules.tryMatch(item.context);
            }
            if (routeId &&
                routeId == Object.keys(item)[0] &&
                isMatchRoute &&
                item[routeId] &&
                item[routeId][_key] &&
                item[routeId][_key].length > 0) {
                reRouteMsg = item[routeId][_key];
                break;
            }
            else if (operationName && operationName == Object.keys(item)[0] && isMatchRoute && item[operationName] && item[operationName][_key].length > 0) {
                reRouteMsg = item[operationName][_key];
                break;
            }
            else if (isMatchRoute && item[utils_1.DEFAULT_ROUTE_RULE] && item[utils_1.DEFAULT_ROUTE_RULE][_key].length > 0) {
                reRouteMsg = item[utils_1.DEFAULT_ROUTE_RULE][_key];
                break;
            }
        }
        return reRouteMsg;
    }
    static tryMatch(values) {
        // x-ctx-${key}:${value} 匹配
        const span = node_vampire_cat_1.default.getActiveSpan() || node_vampire_cat_1.default.span(null, 'InterSpan', '');
        const traceContext = span.getTraceContext ? span.getTraceContext(true).getContext() : false;
        for (let key of values) {
            key = key.split(':');
            if (traceContext[key[0]] === key[1]) {
                return true;
            }
        }
        return false;
    }
    /**
     *
     * @param instances {Array}
     * @returns Generate a default route
     */
    generateInstance(instances) {
        const serverList = {
            weight: 1,
            urls: []
        };
        instances.forEach((item) => {
            serverList.urls.push(item.url);
        });
        return {
            serverList: [serverList],
            ucsServerList: []
        };
    }
}
exports.CheckRouteRules = CheckRouteRules;
