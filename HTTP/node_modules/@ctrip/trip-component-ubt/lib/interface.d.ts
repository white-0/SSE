declare global {
    interface Window {
        __bfi?: any;
    }
}
export interface UBTConfig {
    markting?: boolean;
    rms?: boolean;
    [key: string]: any;
}
export interface UBTSettings {
    loginName?: string;
    'traffic:source'?: string;
    [key: string]: any;
}
export interface PVStatus {
    abtest: string;
    pid: number;
    ps: boolean;
    pv: boolean;
    pvid: number;
    sid: number;
    vid: number;
}
export interface AsyncRefreshOption {
    page_id?: string;
    url?: string;
    orderid?: string;
    refer?: string;
}
export interface TrackMetricOption<T extends object = any> {
    name: string;
    value: number;
    tag?: T;
    sample?: number;
    callback?: (status: number) => void;
}
export declare type TrackMetricStatus = number;
export interface ErrorData {
    line: number;
    column: number;
    file: string;
    message: string;
    category?: string;
    framework?: string;
    stack?: string;
    page_id?: string;
}
declare type EmptyCallback = () => void;
export interface UBT {
    _config<K extends keyof UBTConfig>(key: K, value: UBTConfig[K]): void;
    _set<K extends keyof UBTSettings>(key: K, value: UBTSettings[K]): void;
    _getFullPV(cb: (pv: string) => void): void;
    _getStatus(cb: (status: PVStatus) => void): void;
    _getPageid(cb: (error: Error | null, pageId: string | number) => void): void;
    _getFP(cb: (fp: string) => void): void;
    _asynRefresh(opt: AsyncRefreshOption, cb?: EmptyCallback): void;
    _tracklog(key: string, val: string, cb?: EmptyCallback): void;
    _trace(key: string, val: {
        [s: string]: string;
    }, cb?: EmptyCallback): void;
    _devTrace(key: string, val: {
        [s: string]: string;
    }): void;
    _privateTrace(key: string, val: string): void;
    _trackMetric(opt: TrackMetricOption): void;
    _trackError(data: ErrorData): void;
    _require(name: string, cb?: EmptyCallback): void;
    [customKey: string]: any;
}
export declare type UBTMethods = keyof UBT | string;
export declare type UBTGetMethods = {
    [K in keyof UBT]: ArgumentTypes<UBT[K]> extends [Function] ? K : never;
}[keyof UBT];
export declare type ArgumentTypes<F extends Function> = F extends (...args: infer A) => any ? A : never;
declare type UBTApiFnType<K extends keyof UBT> = (name: K, ...args: ArgumentTypes<UBT[K]>) => any;
export interface BFI extends Array<any[]> {
    push<K extends UBTMethods>(action: ArgumentTypes<UBTApiFnType<K>>): number;
    push(action: any[]): number;
}
export {};
