const { ttypes } = require("@ctrip/node-vampire-thrift");
const cat = require("../selectCatVersion.js");
const cUtil = require("@ctrip/node-vampire-util");
const appConfig = require("../appConfig.js");
const commonThriftHelper = require("../commonThriftHelper");
const METRIC = "Metric";

let _metric_timer = null;
const Metric = function (opts) {
    console.warn('\x1B[31m%s\x1B[0m', 'cat.Metric has been deprecated, refer to: https://node.fx.ctripcorp.com/docs/api/ctriputil/MonitorLogs/metric');
    if (_metric_timer === null) {
        _metric_timer = setInterval(_metric._checkQueue, 1000).unref();
    }

    this._init(opts);
};

let _metric = {};

_metric._queue = [];

_metric._defaultMetricOpt = {
    namespace: '',
    name: '',
    interval: 60000
};

_metric._fix = function (str) {
    let ret = (str || '').toString().replace(/[=\r\n]/g, ' ');
    return ret;
};

_metric._addToQueue = function (metric) {
    _metric._queue.push(metric);
    if (_metric._queue.length > 5000) {
        cat.event('metricQueue.full', _metric._queue.length);
    }
    while (_metric._queue.length > 5000) {
        console.log("[ Vampire-Metric ] delete messge: ", _metric._queue.length);
        _metric._queue.shift();
    }
    _metric._checkQueue();
};

_metric._checkQueue = function () {
    appConfig.init().then(() => {
        if (_metric._queue.length > 0 && +new Date() - _metric._sendTs > 5000 || _metric._queue.length > 100) {
            _metric._sendTs = +new Date();
            commonThriftHelper.send(_metric._queue, METRIC, 0);
            _metric._queue = [];
        }
    }).catch((err) => {
        console.log('[node-vampire-metric] error:', err);
    });
};

_metric._sendTs = +new Date();

Metric.prototype._init = function (opts) {
    this.namespace = opts.namespace || _metric._defaultMetricOpt.namespace;
    this.name = opts.name || _metric._defaultMetricOpt.name;
    this.fullName = (this.namespace ? '__' + this.namespace + '__' : '') + this.name;
    this.tags = {};
    if (opts.tags) {
        Object.getOwnPropertyNames(opts.tags).forEach((key) => {
            this.tags[_metric._fix(key)] = _metric._fix(opts.tags[key]);
        });
    }
    this.interval = Math.max(opts.interval || _metric._defaultMetricOpt.interval, _metric._defaultMetricOpt.interval);
};

Metric.prototype.add = function (val, tags) {
    if (cUtil.type(val) != 'number' || isNaN(val)) {
        return;
    }
    tags = tags || {};
    let tTags = {},
        aTags = [];
    Object.getOwnPropertyNames(tags).forEach((key) => {
        let tKey = _metric._fix(key);
        let tVal = _metric._fix(tags[key]);
        if (Object.prototype.hasOwnProperty.call(this.tags, tKey)) {
            tTags[tKey] = tVal;
        }
    });
    tTags = cUtil.extendMap({}, this.tags, tTags);
    Object.getOwnPropertyNames(tTags).forEach((key) => {
        aTags.push(key + '=' + tTags[key]);
    });
    let rowKey = JSON.stringify(tTags);
    let d = this.data[rowKey] = this.data[rowKey] || {
        tags: aTags,
        min: 0,
        max: 0,
        sum: 0,
        count: 0
    };
    d.min = Math.min(d.min, val);
    d.max = Math.max(d.max, val);
    d.sum += val;
    d.count++;
};

const SetFeatureTypes = ['min', 'max', 'sum', 'count'];
const getValueType = (value) => cUtil.isInt(value) ? ttypes.MetricValueType['TYPE_LONG'] : ttypes.MetricValueType['TYPE_FLOAT'];

Metric.prototype._write = function () {
    const appId = _metric._fix(appConfig['AppID']);
    const hostIp = _metric._fix(cUtil.getHostIp());
    const name = this.fullName;
    const createdTime = parseInt((+new Date()) / 1000, 10);
    const data = this.data;
    this.clear();

    Object.values(data).forEach((row) => {
        const commonTags = ['appid=' + appId, 'hostip=' + hostIp].concat(row.tags);

        SetFeatureTypes.forEach((type) => {
            const value = row[type].toString();
            const valueType = getValueType(row[type]);
            const tags = commonTags.concat(`SetFeatureType=${type}`);
            _metric._addToQueue(new ttypes.MetricEvent({
                createdTime,
                name,
                value,
                valueType,
                tags,
                sequenceNo: 0,
                route: ''
            }));
        });
    });
};

Metric.prototype.clear = function () {
    this.data = Object.create(null);
};

Metric.prototype.start = function () {
    this.end();
    this.clock = setInterval(() => {
        this._write();
    }, this.interval).unref();
};

Metric.prototype.end = function () {
    clearTimeout(this.clock);
    delete this.clock;
    this.clear();
};


module.exports = Metric;