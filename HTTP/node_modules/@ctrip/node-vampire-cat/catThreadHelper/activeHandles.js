const util = require("util");
const EventEmitter = require("events");

function ActiveHandles() {}

util.inherits(ActiveHandles, EventEmitter);

ActiveHandles.prototype.dump = function (callback) {
  let statistics = {
    count: {},
    detail: {},
  };

  let pArr = [];

  let p;

  if (process._getActiveHandles) {
    p = this._getActiveType(statistics, process._getActiveHandles());
    pArr.push(p);
  }
  if (process._getActiveRequests) {
    p = this._getActiveType(statistics, process._getActiveRequests());
    pArr.push(p);
  }

  let wrapCallback = function () {
    callback && callback(statistics);
  };

  Promise.all(pArr).then(wrapCallback).catch(wrapCallback);
};

ActiveHandles.prototype._getActiveType = function (statistics, actives) {
  let pArr = [];
  let detailCount = {};
  actives.forEach((active) => {
    let type = null;
    if (active.constructor) {
      type = active.constructor.name || "Unknown";
    } else {
      type = "" + active || "Unknown";
    }

    let detail = null;
    let subPArr = [];

    if (!Object.prototype.hasOwnProperty.call(type)) {
      detailCount[type] = 0;
    }
    detailCount[type]++;

    this.emit(type, active);

    let p, t;

    if (detailCount[type] < 100) {
      switch (type) {
        case "Server":
          if (active._pipeName) {
            p = new Promise(function (resolve) {
              active.getConnections(function (err, count) {
                detail = active._pipeName + " (" + (err ? 0 : count) + ")";
                resolve();
              });
            });
            subPArr.push(p);
          } else {
            t = active.address();
            // fix: http://sentry.ubt.ctripcorp.com/share/issue/6af344ab43bd4b40aa5cdec15b6ed122/
            if (t && t.address) {
              p = new Promise(function (resolve) {
                active.getConnections(function (err, count) {
                  detail =
                    t.address + ":" + t.port + " (" + (err ? 0 : count) + ")";
                  resolve();
                });
              });
              subPArr.push(p);
            } else {
              detail = "idle";
            }
          }
          break;
        case "ChildProcess":
          detail = active.spawnargs.join(" ");
          break;
        case "Timer": {
          if (!active._list) {
            type = "Timer::Unknown";
          } else if (active._list.nextTick) {
            type = "Timer::nextTick";
          } else if (active._list._idleNext && active._list._idleNext._repeat) {
            type = "Timer::setInterval";
          } else {
            type = "Timer::setTimeout";
          }
          t =
            active._list &&
            active._list._idleNext &&
            active._list._idleNext._onTimeout;
          let tName = (t && t.name) || "anonymous";
          let tMSecs = active._list ? active._list.msecs || 0 : 0;
          detail = tName + " (" + tMSecs + ")";
          break;
        }
        case "Socket":
          if (active.localAddress && active.remoteAddress) {
            t = active.connecting ? " (connecting)" : "";
            if (active.server) {
              detail =
                active.remoteAddress +
                ":" +
                active.remotePort +
                " --> " +
                active.localAddress +
                ":" +
                active.localPort +
                t;
            } else {
              detail =
                active.localAddress +
                ":" +
                active.localPort +
                " --> " +
                active.remoteAddress +
                ":" +
                active.remotePort +
                t;
            }
          } else if (active.server && active.server._pipeName) {
            detail = active.server._pipeName;
          } else {
            detail = "idle / ipc";
          }
          break;
        default:
          break;
      }
    }

    function done() {
      if (type) {
        if (!Object.prototype.hasOwnProperty.call(statistics.count, type)) {
          statistics.count[type] = 0;
        }
        statistics.count[type]++;
      }

      if (detail) {
        if (!Object.prototype.hasOwnProperty.call(statistics.detail, type)) {
          statistics.detail[type] = [];
        }
        statistics.detail[type].push(detail);
      }
    }

    p = Promise.all(subPArr).then(done).catch(done);
    pArr.push(p);
  });

  return Promise.all(pArr);
};

module.exports = new ActiveHandles();
