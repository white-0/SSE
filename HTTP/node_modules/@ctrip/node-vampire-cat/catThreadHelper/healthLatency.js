const dns = require("dns");

const health = {};

class DataCircle {
  constructor(size) {
    this.size = size;
    this.avgSlots = new Array(size);
    this.maxSlots = new Array(size);
    this.index = 0;
    this.length = 0;
  }
  add(value) {
    if (value instanceof DataCircle) {
      this.avgSlots[this.index] = value.avg();
      this.maxSlots[this.index] = value.max();
    } else {
      this.avgSlots[this.index] = this.maxSlots[this.index] = value;
    }
    this.index++;
    if (this.index >= this.size) {
      this.index = 0;
    }
    if (this.length < this.size) {
      this.length++;
    }
  }
  avg() {
    if (!this.length) {
      return 0;
    }
    let sum = 0;
    for (let i = 0; i < this.length; i++) {
      sum += this.avgSlots[i];
    }
    return sum / this.length;
  }
  max() {
    if (!this.length) {
      return 0;
    }
    let max = 0;
    for (let i = 0; i < this.length; i++) {
      if (this.maxSlots[i] > max) {
        max = this.maxSlots[i];
      }
    }
    return max;
  }
  stat() {
    return {
      avg: this.format(this.avg()),
      max: this.format(this.max()),
    };
  }
  format(time) {
    return Math.round(time * 1e3) / 1e3;
  }
  reset() {
    this.index = 0;
    this.length = 0;
  }
}

let eventLoopCircleSec = new DataCircle(10);
let eventLoopCircleMin = new DataCircle(60);

function startEventLoopTest() {
  const interval = 1000 / eventLoopCircleSec.size;
  let st = Date.now();
  setInterval(() => {
    let ed = Date.now();
    let latency = Math.max(0, ed - st - interval);
    eventLoopCircleSec.add(latency);
    st = Date.now();
  }, interval).unref();

  setInterval(() => {
    eventLoopCircleMin.add(eventLoopCircleSec);
  }, interval * eventLoopCircleSec.size).unref();
}

let libuvThreadPoolCircleSec = new DataCircle(5);
let libuvThreadPoolCircleMin = new DataCircle(60);

function dnsLookup() {
  let clock = null;
  return Promise.race([
    new Promise((resolve) => {
      if (clock) {
        clearTimeout(clock);
      }
      dns.lookup("localhost", resolve);
    }),
    new Promise((resolve, reject) => {
      clock = setTimeout(() => {
        clock = null;
        reject();
      }, 3000).unref();
    }),
  ]);
}

function startLibuvThreadPoolTest() {
  const interval = 1000 / libuvThreadPoolCircleSec.size;
  setInterval(() => {
    let st = Date.now();
    dnsLookup()
      .then(() => {
        let ed = Date.now();
        let latency = ed - st;
        libuvThreadPoolCircleSec.add(latency);
      })
      .catch(() => {
        libuvThreadPoolCircleSec.add(3000);
      });
  }, interval).unref();

  setInterval(() => {
    libuvThreadPoolCircleMin.add(libuvThreadPoolCircleSec);
  }, interval * libuvThreadPoolCircleSec.size).unref();
}

startEventLoopTest();
startLibuvThreadPoolTest();

health.reset = () => {
  eventLoopCircleSec.reset();
  eventLoopCircleMin.reset();
  libuvThreadPoolCircleSec.reset();
  libuvThreadPoolCircleMin.reset();
};

health.getEventLoopLatencySec = () => {
  return eventLoopCircleSec.stat();
};

health.getEventLoopLatencyMin = () => {
  return eventLoopCircleMin.stat();
};

health.getLibuvThreadPoolLatencySec = () => {
  return libuvThreadPoolCircleSec.stat();
};

health.getLibuvThreadPoolLatencyMin = () => {
  return libuvThreadPoolCircleMin.stat();
};

let libuvThreadPoolSize = process.env.UV_THREADPOOL_SIZE;

health.getLibuvThreadPoolSize = () => {
  return libuvThreadPoolSize;
};

module.exports = health;
