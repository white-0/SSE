const os = require("os");
const zlib = require("zlib");
const cUtil = require("@ctrip/node-vampire-util");
const {
  thrift,
  ttypes,
  collector
} = require("@ctrip/node-vampire-thrift");
const appConfig = require("@ctrip/node-vampire-appconfig");

class CommonThriftHelper {
  constructor() {
    this.connPromise = null;
  }

  _getCollectorClient() {
    if (this.connPromise) {
      return this.connPromise;
    } else {
      this.connPromise = new Promise((resolve, reject) => {
        let conn = thrift.createConnection(
          appConfig["LoggingServer.V2.IP"],
          appConfig["LoggingServer.V2.Port"]
        );
        let destoryed = false;
        let destroyConn = (err) => {
          if (destoryed) {
            return;
          }
          destoryed = true;
          this.connPromise = null;
          try {
            conn.end();
          } catch (e) {
            // empty
          }
          if (appConfig.debug) {
            console.log('[node-vampire-cat] thrift destroyConn: ' + appConfig["LoggingServer.V2.IP"] + ':' + appConfig["LoggingServer.V2.Port"]);
          }
          // 当断开重连时更换地址
          const randomIp = appConfig["LoggingServer.Bootstrap.IPList"] ? appConfig["LoggingServer.Bootstrap.IPList"][Math.floor(Math.random() * appConfig["LoggingServer.Bootstrap.IPList"].length)] : null;
          appConfig["LoggingServer.V2.IP"] = randomIp || appConfig["LoggingServer.V2.IP"];
          appConfig["LoggingServer.V2.Port"] = appConfig["LoggingServer.Bootstrap.Port"] || appConfig["LoggingServer.V2.Port"];
          conn = null;
          reject(err);
        };
        let IntervalUpdateServer = setTimeout(() => {
          destroyConn();
          clearTimeout(IntervalUpdateServer);
        }, 300000).unref(); //5min 重连一次
        conn.on("error", destroyConn);
        conn.on("close", () => {
          destroyConn(new Error("Connection Closed"));
        });
        conn.on("timeout", () => {
          destroyConn(new Error("Connection Timeout"));
        });
        conn.on("connect", () => {
          let collectorClient = thrift.createClient(collector, conn);
          collectorClient.connection = conn;
          resolve(collectorClient);
        });
      });
      return this.connPromise;
    }
  }

  /**
   *
   * @param {Array} logEvents 待发送数据
   * * @param {string} flag 数据类型，clogging/Metric
   * @param {Number} retryTimes  //重试次数
   */
  send(datas, flag, retryTimes) {
    retryTimes = retryTimes || 0;
    const logEvents = flag.toLowerCase() === "clogging" ? datas : [];
    const metrics = flag.toLowerCase() === "metric" ? datas : [];
    this._getCollectorClient()
      .then((collectorClient) => {
        if (flag.toLowerCase() === "clogging" && logEvents.length == 0) {
          collectorClient.connection.connection &&
            collectorClient.connection.connection.unref();
          return Promise.resolve();
        }
        return new Promise((resolve, reject) => {
          let callback = (err, data) => {
            if (err) {
              reject(err);
            } else if (!data || data.resultCode) {
              reject(new Error("Invalid Result Code"));
            } else {
              resolve();
            }
          };

          let chunk = new ttypes.Chunk({
            hostIp: cUtil.getHostIp(),
            hostName: os.hostname() || "UNKNOWN",
            appId: appConfig["AppID"],
            processId: process.pid,
            logEvents: logEvents,
            metrics: metrics,
            events: [],
            sequenceNo: 0,
            route: "",
          });

          // collectorClient.produce(chunk, callback);

          let buff = thrift.serialize(chunk);
          zlib.gzip(
            buff, {
              level: 6,
            },
            (err, compressed) => {
              if (err) {
                reject(err);
              } else {
                collectorClient.send(
                  compressed,
                  ttypes.CompressionType.GZIP,
                  buff.length,
                  callback
                );
              }
            }
          );
        });
      })
      .catch((err) => {
        if (logEvents.length === 0) {
          return;
        }
        if (retryTimes < 3) {
          retryTimes++;
          let timeout = retryTimes * 1000;
          setTimeout(() => {
            console.log(
              `[${flag}] Send ${flag} failed: ${err}, retry after ` +
              timeout +
              `ms (` +
              retryTimes +
              `)`
            );
            this.send(datas, flag, retryTimes);
          }, timeout).unref();
        } else {
          console.log(
            `[${flag}] Send ${flag} failed, ` + (metrics.length || logEvents.length) + ` events lost`
          );
        }
      });
  }
}

module.exports = new CommonThriftHelper();