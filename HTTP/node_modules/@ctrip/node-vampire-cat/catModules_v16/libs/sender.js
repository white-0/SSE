const net = require("net");
const appConfig = require("../../appConfig");
const util = require("@ctrip/node-vampire-util");
const pm2 = require("./pm2id");
const fetchServerConfig = require("./fetchServerConfig.js");
// const validServerConfig = require('./validServerConfig.js');
const queue = require("./queue.js");
const activeHandles = require("../../catThreadHelper/activeHandles");
const healthLatency = require("../../catThreadHelper/healthLatency");
const moduleHelper = require("./moduleHelper.js");
const CatSpan = require("../types/CatSpan.js");
const CatHeartbeat = require("../types/CatHeartbeat.js");
const bt6 = require("../protocols/bt6.js");
const st1 = require("../protocols/st1.js");
const np1 = require("../protocols/np1.js");
const log = require('../../LogFile');
let useRemoteConfig = true;
let available = false;
let isSending = false;
let sendBytes = 0;
let conn = null,
  tagsConn = null;
let reSendClock = null;
let currentCatServerLists = null;
let currentEsServerLists = null;

// 是否已经触发了高水位线事件
let highWaterMarkSwitch = false;
// 设置高水位线为4M，同JAVA一致
const highWaterMark = 4 * 1024 * 1024
// 设置低水位线为1M
const lowWaterMark = 1 * 1024 * 1024;
//记录建连成功的时间点
let connectionTime = 0;
let CONN_TIMEOUT=5*60*1000;

function sendPackage() {
  if (!available || isSending) {
    return;
  }
  isSending = true;
  if (reSendClock) {
    clearTimeout(reSendClock);
    reSendClock = null;
  }
  let item = queue.consumeFromSendQueue();
  if (item) {
    let serverList = null,
      isTags = false;
    if (
      item.__type === "tags" &&
      appConfig["esServer"] &&
      appConfig["es.bizLogEnable"]
    ) {
      serverList = appConfig["esServer"];
      isTags = true;
    } else if (
      item.__type != "tags" &&
      appConfig["CatServer"] &&
      appConfig["cat.enable"]
    ) {
      serverList = appConfig["CatServer"];
    }

    if (!serverList) {
      queue.restoreToSendQueue(item);
      reSendClock = setTimeout(sendPackage, 10000).unref();
      isSending = false;
      return;
    }
    let raw = createRaw(item);
    if (raw) {
      sendRaw(serverList, raw, isTags, function (err) {
        if (err) {
          console.log("[ Vampire-CAT ]", "Send Cat Package Failed:", err);
          queue.restoreToSendQueue(item);
          reSendClock = setTimeout(sendPackage, 10000).unref();
          isSending = false;
        } else {
          isSending = false;
          process.nextTick(sendPackage);
        }
      });
    } else {
      isSending = false;
    }
  } else {
    isSending = false;
  }
}


function createRaw(item) {
  if (appConfig.debug && !item.__type.startsWith("statMessage")) {
    console.log(item.toString());
  }
  let ret = null;
  if (item.__type == "tags") {
    ret = np1(item);
  } else if (item.__type.startsWith("statMessage")) {
    ret = st1(item);
  } else {
    // ret = pt1(item);
    ret = bt6(item);
  }
  return ret;
}

function sendRaw(ServerLists, raw, isTags, callback) {
  prepareConn(ServerLists, isTags, function (err, conn) {
    if (err) {
      callback(err);
    } else {
      try {
        if ((highWaterMarkSwitch && conn.writableLength < lowWaterMark) || !highWaterMarkSwitch) {
          sendBytes += raw.length;
          conn.write(raw);
          highWaterMarkSwitch = conn.writableLength > highWaterMark;
        } else {
          log(`[ Vampire-CAT ] Send Cat Package Failed.The writableLength is ${conn.writableLength} and rawBytes is ${raw.length}`);
          raw = null;
        }
      } catch (e) {
        try {
          conn.end();
        } catch (e) {
          // empty
        }
        try {
          conn.destroy();
        } catch (e) {
          // empty
        }
        conn = null;
        callback(e);
        return;
      }
      callback(null);
    }
  });
}

function prepareConn(ServerLists, isTags, callback) {
  const _currentCatServerLists = isTags ?
    currentEsServerLists :
    currentCatServerLists;
  // 当ip变更或连接断开或连接超过五分钟时：重新建连
  const connectionDuration = connectionTime && (new Date().getTime() - connectionTime) || 0;
  if (connectionDuration >= CONN_TIMEOUT) log("[ Vampire-CAT ] connected for more than five minutes: " + connectionDuration);
  if (_currentCatServerLists != ServerLists.toString() || connectionDuration >= CONN_TIMEOUT) {
    if (isTags) {
      currentEsServerLists = ServerLists.toString();
      if (tagsConn) {
        try {
          tagsConn.end();
        } catch (e) {
          // empty
        }
        try {
          tagsConn.destroy();
        } catch (e) {
          // empty
        }
      }
    } else {
      currentCatServerLists = ServerLists.toString();
      if (conn) {
        try {
          conn.end();
        } catch (e) {
          // empty
        }
        try {
          conn.destroy();
        } catch (e) {
          // empty
        }
      }
    }
    let servers = ServerLists.slice(0);
    tryConnectServer(servers, isTags, callback);
  } else if ((!isTags && !conn) || (isTags && !tagsConn)) {
    let servers = ServerLists.slice(0);
    tryConnectServer(servers, isTags, callback);
  } else {
    callback(null, isTags ? tagsConn : conn);
  }
}

function tryConnectServer(servers, isTags, callback) {
  log("[ Vampire-CAT ] Server List: " + servers);
  let server = servers.shift();
  if (server) {
    let arr = server.split(":");
    let host = arr[0];
    let port = parseInt(arr[1], 10);
    let newConn = net.connect(port, host).unref();
    newConn.isConnected = false;
    newConn.on("error", function () {
      if (newConn.isConnected) {
        try {
          newConn.end();
        } catch (e) {
          // empty
        }
        try {
          newConn.destroy();
        } catch (e) {
          // empty
        }
        if (tagsConn == newConn) {
          tagsConn = null;
        } else if (conn == newConn) {
          conn = null;
        }
        console.log(
          "[ Vampire-CAT ]",
          "Connection Lost, Cat Server: " + server
        );
      } else {
        try {
          newConn.destroy();
        } catch (e) {
          // empty
        }
        if (tagsConn == newConn) {
          tagsConn = null;
        } else if (conn == newConn) {
          conn = null;
        }
        console.log(
          "[ Vampire-CAT ]",
          "Connect To Cat Server Error: " + server
        );
        tryConnectServer(servers, isTags, callback);
      }
    });
    newConn.on("connect", function () {
      newConn.isConnected = true;
      isTags ? (tagsConn = newConn) : (conn = newConn);
      console.log(
        "[ Vampire-CAT ]",
        "Connect To Cat Server Success: " + server
      );
      connectionTime = new Date().getTime();
      callback(null, isTags ? tagsConn : conn);
    });
    newConn.on("end", function () {
      if (tagsConn == newConn) {
        tagsConn = null;
      } else if (conn == newConn) {
        conn = null;
      }
    });
  } else {
    callback("None Available Cat Server");
  }
}

function sendHeartbeat() {
  let span = new CatSpan(null, "System", "Status");
  span.__splitProcess = true;
  span.run(function (done) {
    new CatHeartbeat(span, function () {
      let pArr = [];
      let eventLoopLatencyMin = healthLatency.getEventLoopLatencyMin();
      let libuvThreadPoolLatencyMin =
        healthLatency.getLibuvThreadPoolLatencyMin();
      pArr.push(
        new Promise(function (resolve) {
          activeHandles.dump(function (statistics) {
            span.event(
              "ThreadDump",
              util.getHostIp() + "@@" + pm2.id,
              JSON.stringify({
                  activeHandles: statistics,
                  eventLoopLatency: eventLoopLatencyMin,
                  libuvThreadPoolLatency: libuvThreadPoolLatencyMin,
                },
                null,
                "\t"
              )
            );
            span.__splitProcess = true;
            resolve();
          });
        })
      );
      /* send pkginfo
       * only when the pid of current process is 0(master)
       */
      if (pm2.id == 0) {
        pArr.push(
          new Promise(function (resolve) {
            moduleHelper.getVersions(function (versions) {
              for (let key in versions) {
                if (Object.prototype.hasOwnProperty.call(versions, key)) {
                  span.event("Node." + key + ".Version", versions[key]);
                }
              }
              resolve();
            });
          })
        );
      }

      Promise.all(pArr).then(function () {
        done(true);
      });
    });
  });
}

function senderReady() {
  available = true;
  queue.on("exceed", sendPackage);
  setInterval(() => {
    fetchServerConfig()
      .then(() => {
        if (appConfig.debug) {
          console.log(
            "[ Vampire-CAT ] Sender.js fetch server config success in setInterval function"
          );
        }
      })
      .catch((e) => {
        if (appConfig.debug) {
          console.log(
            "[ Vampire-CAT ] Sender.js fetch server config error in setInterval function",
            e
          );
        }
      });
  }, 1200000).unref();
  sendPackage();
}

let initSender = function () {
  if (useRemoteConfig) {
    fetchServerConfig()
      .then(() => {
        senderReady();
      })
      .catch(() => {
        setTimeout(initSender, 10000).unref();
      });
  } else {
    senderReady();
  }
};

appConfig
  .init()
  .then(() => {
    initSender();
  })
  .catch((err) => {
    console.error("[Cat] Cat sender.js error.", err);
  });

let sender = {
  sendHeartbeat: function () {
    setInterval(sendHeartbeat, 60000).unref();
    setTimeout(sendHeartbeat, 200).unref();
  },
  sendPackage: function () {
    process.nextTick(sendPackage);
  },
  getSendBytes: function () {
    return sendBytes;
  },
};

module.exports = sender;