const storage = require("./storage");
const fs = require("fs");
const EventEmitter = require("events");
const util = require("@ctrip/node-vampire-util");
const appConfigModule = require("@ctrip/node-vampire-appconfig");
let waitQueue = [];
waitQueue.push = function () {
  if (
    appConfigModule["env"] !== "prod" &&
    appConfigModule["cat.client.unEnabled"]
  ) {
    return;
  }
  let args = Array.prototype.slice.call(arguments, 0);
  Array.prototype.push.apply(waitQueue, args);
};

let sendQueue = [];
sendQueue.__batchUpdate = false;

sendQueue.push = function () {
  if (
    appConfigModule["env"] !== "prod" &&
    appConfigModule["cat.client.unEnabled"]
  ) {
    return;
  }
  let args = Array.prototype.slice.call(arguments, 0);
  Array.prototype.push.apply(sendQueue, args);

  storage.exit(() => {
    if (sendQueue.length > 150) {
      let overflowQueue = sendQueue.splice(0, 30);
      countMessage(overflowQueue, function (count, total) {
        console.log(
          "[ Vampire-CAT ] Drop Cat " + count + " Messages (" + total + ")"
        );
        dropMessageCount += count;
        if (!appConfigModule["isIgnoreDropMsgsError"]) {
          let error = require("../export.js").error(
            "Drop Messages",
            "Total: " + total
          );
          error.__overCount = count;
        } else {
          require("../export.js").event("Drop Messages", "Total: " + total);
        }
      });
    } else if (!sendQueue.__batchUpdate) {
      queue.emit("exceed");
    }
  });
};

let dropMessageCount = 0;

function countMessage(items, callback) {
  let count = 0;
  let total = 0;
  items.forEach(function (item) {
    switch (item.__type) {
      case "span":
        count++;
        total++;
        countMessage(item.__children, function (subCount, subTotal) {
          count += subCount;
          total += subTotal;
        });
        break;
      case "statMessage":
        count++;
        total++;
        break;
      case "event":
        count++;
        total++;
        break;
      case "error":
        count += item.__overCount ? 0 : 1;
        total += item.__overCount || 1;
        break;
      default:
        break;
    }
  });
  callback(count, total);
  return count;
}

let queue = new EventEmitter();
queue.addToWaitQueue = waitQueue.push;

queue.moveToSendQueue = function (item) {
  if (!item.__parent) {
    let idx = waitQueue.indexOf(item);
    if (idx != -1) {
      waitQueue.splice(idx, 1);
      sendQueue.push(item);
    }
  }
};

queue.addToSendQueue = sendQueue.push;

queue.consumeFromSendQueue = function () {
  let item = null;
  if (!sendQueue.__batchUpdate) {
    item = sendQueue.shift();
    if (!item) {
      queue.emit("idle");
    }
  }
  return item;
};

queue.restoreToSendQueue = function (item) {
  return sendQueue.unshift(item);
};

queue.getDropMessageCount = function () {
  return dropMessageCount;
};

queue.saveToDisk = function (queueFile) {
  sendQueue.__batchUpdate = true;
  for (let i = waitQueue.length - 1; i >= 0; i--) {
    waitQueue[i].end(true);
  }
  sendQueue.__batchUpdate = false;
  let ret = 0;
  if (sendQueue.length > 0) {
    let content = queue.serialize();
    try {
      fs.writeFileSync(queueFile, content);
      ret = sendQueue.length;
    } catch (e) {
      // empty
    }
  }
  return ret;
};

queue.loadFromDisk = function (queueFile) {
  let ret = 0;
  try {
    let content = fs.readFileSync(queueFile).toString();
    let tmpQueue = queue.deserialize(content);
    if (tmpQueue) {
      sendQueue.__batchUpdate = true;
      sendQueue = sendQueue.concat(tmpQueue);
      sendQueue.__batchUpdate = false;
      queue.emit("exceed");
      ret = sendQueue.length;
    }
  } catch (e) {
    // empty
  }
  return ret;
};

queue.serialize = function () {
  return JSON.stringify(sendQueue, function (k, v) {
    if (
      k == "__parent" ||
      k == "__root" ||
      k == "__inheritValue" ||
      k == "__traceContext" ||
      k == "__members" ||
      k == "__membersWeakMap"
    ) {
      return void 0;
    } else {
      return v;
    }
  });
};

queue.deserialize = function (content) {
  let ret = [];
  let tmpQueue = null;
  try {
    tmpQueue = JSON.parse(content);
  } catch (e) {
    // empty
  }
  if (tmpQueue && util.type(tmpQueue) == "array") {
    let CatSpan = require("../types/CatSpan.js");
    tmpQueue.forEach(function (item) {
      if (item.__type == "span") {
        ret.push(new CatSpan(item));
      }
      if (item.__type.startsWith("statMessage")) {
        ret.push(item);
      }
    });
  }
  return ret.length ? ret : null;
};

module.exports = queue;
