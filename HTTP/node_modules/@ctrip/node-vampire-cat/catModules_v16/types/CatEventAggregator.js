const util = require('@ctrip/node-vampire-util');
const StatMessageEventTree = require('./CatStatMessageEvents');

let eventAggregatorQueue = Object.create(null); ////{ timestamp: {statMessageTree} }; 

function CatEventAggregator() {
    this.addQueueInternal();
}

/**
 * 注：java cat transaction可以统计error,nodejs没有
 */
CatEventAggregator.prototype.aggregate = function (event) {
    const aggregatorData = this.makeSurSpanExist(event.type, event.name, event.__startTime);
    aggregatorData.add(event.__messageId, event.__type);
}

CatEventAggregator.prototype.makeSurSpanExist = function (_type, _name, _timestamp) {
    const timestamp = this.getTimeTampMm(_timestamp);
    let timeItem = eventAggregatorQueue[timestamp];
    if (!timeItem) {
        timeItem = eventAggregatorQueue[timestamp] = {
            ['statMessageTree']: this.createStatMessageTree()
        };
        const span = new StatMessageEventTree('System', 'CatEventAggreator');
        span.__timeStamp = timestamp;
        span.durationInMicro = 100 * 1000; //ms
        timeItem['statMessageTree'].message = span;
        timeItem['statMessageTree'].__timeStamp=timestamp;
        const _eventItem = new EventData(_type, _name);
        timeItem['statMessageTree']._itemAggregator = {
            [_type]: {
                [_name]: _eventItem
            }
        };
        return _eventItem;
    }
    let typeItem = timeItem['statMessageTree']._itemAggregator[_type];
    if (!typeItem) {
        const _eventItem = new EventData(_type, _name);
        timeItem['statMessageTree']._itemAggregator[_type] = {
            [_name]: _eventItem
        };
        return _eventItem;
    }

    let nameItem = typeItem[_name];
    if (!nameItem) {
        const _eventItem = new EventData(_type, _name);
        typeItem[_name] = _eventItem;
        return _eventItem;
    }

    return nameItem;
}

//send data
CatEventAggregator.prototype.sendSpanData = function () {
    if (Object.keys(eventAggregatorQueue).length > 0) {
        const _eventAggregatorQueue = eventAggregatorQueue;
        eventAggregatorQueue = Object.create(null);
        for (const timeStamp in _eventAggregatorQueue) {
            if (Object.prototype.hasOwnProperty.call(_eventAggregatorQueue, timeStamp)) {
                const {
                    statMessageTree
                } = _eventAggregatorQueue[timeStamp];
                statMessageTree.end();
            }
        }
    }
}

CatEventAggregator.prototype.addQueueInternal = function () {
    setInterval(() => {
        this.sendSpanData();
    }, 5000).unref();
}
CatEventAggregator.prototype.createStatMessageTree = function () {
    const statMessageTree = new StatMessageEventTree();
    return statMessageTree;
}
CatEventAggregator.prototype.getTimeTampMm = function (timestamp) {
    try {
        return new Date(util.formatDateTime(new Date(timestamp), "yyyy-MM-dd hh:mm")).getTime();
    } catch (e) {
        return new Date(util.formatDateTime(new Date(), "yyyy-MM-dd hh:mm")).getTime();
    }
}

function EventData(type, name) {
    this.type = type;
    this.name = name;
    this.count = 0;
    this.sum = 0;
    this.error = 0;
    this.messageId = null;
}

EventData.prototype.add = function (messageId, type) {
    this.count++;
    (messageId && !this.messageId) && (this.messageId = messageId);
    (type && type === 'error') && this.error++;
}

module.exports = new CatEventAggregator();