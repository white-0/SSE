const util = require("@ctrip/node-vampire-util");
const truncateString = require("../libs/truncateString.js");
const CatEventAggregator = require("./CatEventAggregator.js");

function createError(err, stack) {
  let message = "Error Unknown";
  stack = stack || "";
  let messages, stacks;
  if (util.type(stack) != "string") {
    stack = JSON.stringify(stack);
  }
  if (err === null) {
    message = "Error Null";
  } else if (err === void 0) {
    message = "Error Undefined";
  } else {
    switch (util.type(err)) {
      case "error":
        message = "" + err.message;
        stack = (stack ? stack + " ||| " : "") + err.stack;
        break;
      case "string":
      case "number":
        message = "" + err;
        stack = (stack ? stack + " ||| " : "") + err;
        break;
      case "array":
        messages = ["Error Array"];
        stacks = [];
        err.map(createError).forEach(function (err) {
          messages.push("" + err.message);
          stacks.push("[" + err.message + "] " + err.stack);
        });
        message = messages.join(" ||| ");
        stack = (stack ? stack + " ||| " : "") + stacks.join(" ||| ");
        break;
      case "object":
        messages = ["Error Object"];
        stacks = [];
        for (let key in err) {
          if (Object.prototype.hasOwnProperty.call(err, key)) {
            let subErr = createError(err[key]);
            if (util.type(err[key]) == "error") {
              messages.push("" + subErr.message);
            }
            stacks.push("[" + subErr.message + "] " + subErr.stack);
          }
        }
        message = messages.join(" ||| ");
        stack = (stack ? stack + " ||| " : "") + stacks.join(" ||| ");
        break;
      case "date":
        message = "Error Date";
        stack = (stack ? stack + " ||| " : "") + err.toLocaleString();
        break;
      default:
        message = "" + err;
        stack = (stack ? stack + " ||| " : "") + err;
        break;
    }
  }
  if (message.length > 100) {
    message = message.slice(0, 97) + "...";
  }
  let newErr = new Error(message);
  try {
    newErr.type = message;
    newErr.stack = stack;
  } catch (e) {
    // empty
  }
  return newErr;
}

function CatError(parent, message, stack) {
  if (!parent) {
    throw new Error("Invalid Error Parent Span");
  }

  if (parent.constructor && parent.constructor.name == "Object") {
    for (let key in parent) {
      if (Object.prototype.hasOwnProperty.call(parent, key)) {
        this[key] = parent[key];
      }
    }
  } else if (parent.__close) {
    throw new Error("Invalid Event Parent Span Status");
  } else {
    let err = createError(message, stack);
    message = err.message;
    stack = err.stack;

    this.__id = util.uid();
    this.__messageId = parent.__messageId;
    this.__type = "error";
    this.__close = true;
    this.__parent = parent;
    this.__root = parent.__root;
    this.__startTime = this.__endTime = +new Date();
    this.__startMicroSeconds = this.__endMicroSeconds = util.getMicroSeconds();
    this.type = this.isInfoSec(this.__root)
      ? this.isInfoSec(this.__root) + "Error"
      : "Error";
    this.name = message || "Unknown Name";
    this.status = "ERROR";
    let t = this;
    while ((t = t.__parent)) {
      !this.isInfoSec(this.__root) && (t.status = "ERROR");
    }
    this.data = stack || "";

    this.__parent.__children.push(this);
    CatEventAggregator.aggregate(this);
  }
}
CatError.prototype.isInfoSec = function (tree) {
  return tree != null && tree["trace-source"];
};
CatError.prototype.toString = function () {
  return (
    "ERROR " +
    util.formatDateTime(this.__startTime, "hh:mm:ss,SSS") +
    " " +
    this.type +
    " " +
    this.name +
    " " +
    truncateString(util.stringify(this.data), 50)
  );
};

module.exports = CatError;
