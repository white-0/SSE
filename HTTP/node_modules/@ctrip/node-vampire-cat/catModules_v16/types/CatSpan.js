"use strict";

const storage = require("../libs/storage");
const util = require("@ctrip/node-vampire-util");
const ff = require("@ctrip/node-vampire-foundation-framework");
const messageId = require("../libs/messageId.js");
const queue = require("../libs/queue.js");
const CatEvent = require("./CatEvent.js");
const CatError = require("./CatError.js");
const CatHeartbeat = require("./CatHeartbeat.js");
const CatTags = require("./CatTags.js");
const CatLogging = require("./CatLogging.js");
const truncateString = require("../libs/truncateString.js");
const TraceContext = require("./TraceContext.js");
const CatConstants = require("./CatConstants");
const CatSpanAggregator = require("./CatSpanAggregator.js");
const appConfig = require("../../appConfig.js");

let placeHolder = new WeakMap();
let asyncRoot = new WeakMap();

let memorySpan = null;
let fr = null;
if (appConfig.debug) {
  const {
    setFlagsFromString
  } = require("v8");
  const {
    runInNewContext
  } = require("vm");
  let gc = global.gc;
  if (!gc) {
    setFlagsFromString("--expose_gc");
    try {
      gc = runInNewContext("gc");
    } catch (_) {
      gc = () => {};
    }
  }
  memorySpan = {
    increase: 0,
    decrease: 0,
  };
  // eslint-disable-next-line no-undef
  fr = new FinalizationRegistry((type) => {
    if (type == "span") {
      memorySpan.decrease++;
    }
  });
  setInterval(() => {
    gc();
    process.nextTick(() => {
      let diff = memorySpan.increase - memorySpan.decrease;
      console.log(
        `Span Increase: ${memorySpan.increase}, Decrease: ${memorySpan.decrease}, Diff: ${diff}`
      );
      if (diff > 100) {
        console.warn("Memory Leak Detected");
      }
    });
  }, 10000).unref();
}

function CatSpan(parent, type, name, data) {
  if (parent && parent.constructor && parent.constructor.name == "Object") {
    this.__parent = null;
    this.__root = this;
    for (let key in parent) {
      if (Object.prototype.hasOwnProperty.call(parent, key)) {
        switch (key) {
          case "__inheritValue":
            this.__inheritValue = {};
            break;
          case "__traceContext":
            this.__traceContext = {};
            break;
          case "__children":
            this.__children = [];
            if (util.type(parent.__children) == "array") {
              this.__children = [];
              parent.__children.forEach((item) => {
                let ret = null;
                item.__parent = this;
                item.__root = this.__root;
                switch (item.__type) {
                  case "span":
                    ret = new CatSpan(item);
                    break;
                  case "event":
                    ret = new CatEvent(item);
                    break;
                  case "error":
                    ret = new CatError(item);
                    break;
                  case "heartbeat":
                    ret = new CatHeartbeat(item);
                    break;
                  case "tags":
                    ret = new CatTags(item);
                    break;
                  case "logging":
                    ret = new CatLogging(item);
                    break;
                  default:
                    break;
                }
                if (ret) {
                  this.__children.push(ret);
                }
              });
            }
            break;
          default:
            this[key] = parent[key];
            break;
        }
      }
    }
  } else {
    if (appConfig.debug) {
      memorySpan.increase++;
      fr.register(this, "span");
    }
    this.__id = util.uid();
    this.__messageId =
      parent && !parent.__close ? parent.__messageId : messageId.getMessageId();
    this.__type = "span";
    this.__close = false;
    this.__parent = parent && !parent.__close ? parent : null;
    if (parent && !parent.__close && parent.__root) {
      this.__root = parent.__root;
      !this.__properties && (this.__properties = {});
    } else {
      this.__root = this;
      this.__properties = {
        "Tree.Begin": new Date().getTime(),
        idc: ff.getServerPropertiesSync("idc"),
        region: ff.getServerPropertiesSync("region"),
        az: ff.getServerPropertiesSync("az"),
      };
    }
    this.__startTime = Date.now();
    this.__startMicroSeconds = util.getMicroSeconds();
    this.__members = [];
    this.__membersWeakMap = new WeakMap();
    this.__children = [];

    this.type =
      (this.isInfoSec(this.__root) ?
        this.isInfoSec(this.__root) + type :
        type) || "Unknow Type";
    this.name = name || "Unknow Name";
    this.status = "0";
    this.data = data || "";

    this.__timeout = null;
    this.setTimeout(CatSpan.__timeout);

    this.__traceContext = parent ? parent.__traceContext : {};
    this.__inheritValue = parent ? parent.__inheritValue : {};
    let ret = null;
    if (parent && parent.__close && (placeHolder.has(parent.__root))) {
      const parentRemote = placeHolder.get(parent.__root);
      ret = parentRemote;
      }
    ret && this.updateIds(ret);
    if (parent && !parent.__close) {
      this.__parent.__children.push(this);
    } else {
      queue.addToWaitQueue(this);
    }

    this._modify();
  }
}

/**2018/11/08 初始化messageId, parentId 和 rootId(根据header中的X-CAT-TRACE-MODE来判断是否需要从头部获取相关id)
 * @param {object} headers 头部信息
 */
CatSpan.prototype.updateIds = function (headers) {
  // return false;
  if (
    headers &&
    "" + headers["x-cat-trace-mode"] === "true" &&
    !this.__parent
  ) {
    //需要从调用方获取cat的messageid，将整条链路串联起来
    /** java的逻辑代码
     * ctx.setRootId(req.getHeader('X-CAT-ROOT-ID'));
     * ctx.setParentId(req.getHeader('X-CAT-PARENT-ID'));
     * ctx.setId(req.getHeader('X-CAT-ID'));
     */
    // console.log('==updateIds==', headers);
    /* 2019/02/11 判断header['x-cat-id']是否存在，如果不存在则不做替换。x-cat-parent-id和x-cat-root-id做过兼容处理，这边可以不用判断 */
    if (headers["x-cat-id"] != null && headers["x-cat-id"].length > 0) {
      this.__messageId = headers["x-cat-id"];
      this.__outerIds = {
        "x-cat-id": headers["x-cat-id"],
        "x-cat-parent-id": headers["x-cat-parent-id"],
        "x-cat-root-id": headers["x-cat-root-id"],
      };
    }
  }
};

/**设置可继承的属性, 比如用在灰度测试上**/
CatSpan.prototype.setInheritValue = function (key, data, appConfig, isInfoSec) {
  this.__inheritValue[key] = data;
  this["trace-source"] = isInfoSec;
  if (key == "reqEntity") {
    this.restoreTraceContext(data["headers"]); //如果设置的request内容，那么需要更新一下traceContext
    this.checkUcsContext(appConfig);
    this.updateIds(data["headers"]); //根据头部信息，决定是否更新messageId, parentId, rootId
  }
};

CatSpan.prototype.getInheritValue = function (key) {
  return this.__inheritValue[key];
};

/** 新增设置路由策略的判断，暂时不做处理，只是做一下not set/not match的记录 */
CatSpan.prototype.checkUcsContext = function (appConfig) {
  let __traceContext = this.getTraceContext(false);
  let isZoneRequestFromHeaders =
    __traceContext &&
    __traceContext.get &&
    __traceContext.get(CatConstants.UCS_HEADER_IS_ZONE_REQUEST);
  let zoneFromHeaders =
    __traceContext &&
    __traceContext.get &&
    __traceContext.get(CatConstants.UCS_HEADER_ZONE_CODE);
  let zoneFromFoundation = appConfig && appConfig.zone;
  if (isZoneRequestFromHeaders == "true") {
    if (zoneFromHeaders == "" || util.type(zoneFromHeaders) == "undefined") {
      this.event(
        CatConstants.UCS_CHECK_FAIL,
        CatConstants.UCS_ZONE_NOT_SET,
        "zoneFromHeaders : " + zoneFromHeaders
      );
    } else if (zoneFromHeaders != zoneFromFoundation) {
      this.event(
        CatConstants.UCS_CHECK_FAIL,
        CatConstants.UCS_ZONE_MISMATCH,
        JSON.stringify({
          zoneFromHeaders,
          zoneFromFoundation,
        })
      );
    }
  }
};

/** 新增全链路需求 参照 http://conf.ctripcorp.com/display/FRAM/TraceContext */
// 获取当前TraceContext，没有则创建
CatSpan.prototype.getOrCreateTraceContext = function () {
  this.__traceContext = new TraceContext(this);
  return this.__traceContext;
};

// 获取当前TraceContext，createIfAbsent为true的话，没有则创建
CatSpan.prototype.getTraceContext = function (createIfAbsent) {
  if (
    this.__traceContext &&
    Object.keys(this.__traceContext).length === 0 &&
    createIfAbsent
  ) {
    return this.getOrCreateTraceContext();
  }
  return this.__traceContext;
};

CatSpan.prototype.restoreTraceContext = function (headers) {
  if (!headers) {
    return false;
  }
  let headerPrefix = "x-ctx-";
  let contextHash = {};
  for (let key in headers) {
    if (Object.prototype.hasOwnProperty.call(headers, key)) {
      let lowerCaseKey = key.toLowerCase(); //this step can be ignored.
      if (
        /^x-ctx-/.test(lowerCaseKey) &&
        lowerCaseKey.length > headerPrefix.length
      ) {
        let newKey = key.replace(headerPrefix, "");
        contextHash[newKey] = headers[key];
      }
    }
  }

  if (Object.keys(contextHash).length > 0) {
    this.getOrCreateTraceContext().restore(contextHash);
  }
};

/**currrent request is canary status
 * header "x-ctx-canaryreq" - (case-insensitive) */
CatSpan.prototype.isCanaryRequest = function () {
  let context = this.getTraceContext();
  if (context && context.containsKey) {
    return context.containsKey("canaryreq");
  }
  return false;
};

CatSpan.prototype._modify = function () {
  this.__root.__lastModifyTime = +new Date();
};

CatSpan.prototype.isFromInfoSec = function () {
  if (this.__root) {
    return this.__root["trace-source"] === "infoSec-";
  }
  return false;
};

CatSpan.prototype.isOriginatedFromInfoSec = function () {
  let context = this.getTraceContext();
  if (context && context.containsKey) {
    return context.containsKey("trace-source") ? true : false;
  }
  return false;
};

CatSpan.prototype.isInfoSec = function (tree) {
  return tree != null && tree["trace-source"];
};

CatSpan.prototype.run = function (handler) {
  let ret;
  if (this.__close) {
    ret = handler(() => {});
  } else {
    let isDone = false;
    let done = (force) => {
      if (!isDone) {
        isDone = true;
        this.end(force);
      }
    };
    ret = storage.run(this, handler.bind(this), done);
    this._modify();
  }
  return ret;
};

CatSpan.prototype.add = function (emitter) {
  if (!emitter.__spanEmit) {
    emitter.__spanEmit = true;
    this.__members.push(emitter);
    let memberProperties = {
      hasOwnEmit: Object.prototype.hasOwnProperty.call(emitter, "emit"),
      emit: emitter.emit,
    };
    this.__membersWeakMap.set(emitter, memberProperties);
    emitter.emit = (...args) => {
      return storage.run(this, () =>
        memberProperties.emit.apply(emitter, args)
      );
    };
    this._modify();
  }
};

CatSpan.prototype.setTimeout = function (timeout, callback) {
  if (!this.__close) {
    if (this.__timeout) {
      clearTimeout(this.__timeout);
      this.__timeout = null;
    }
    let wrapCallback = () => {
      if (callback) {
        callback();
      } else {
        this.error("TIMEOUT");
      }
      this.end();
    };
    this.__timeout = setTimeout(wrapCallback, timeout).unref();
  }
};

CatSpan.prototype._createPlaceHolder = function () {
  if (!placeHolder.has(this.__root) && !this.__RemoteCall && (this.__root != this || !this.__parent)) { //(this.__root != this || !this.__parent) 非子__catMergeTree || 根节点
    let mid = messageId.getMessageId();
    this.event("RemoteCall", "RunAway", `${mid}=查看更多`);
    this.__RemoteCall = true;
    placeHolder.set(this.__root, {
      "x-cat-id": mid,
      "x-cat-parent-id": this.__root.__messageId,
      "x-cat-root-id": this.__root.__outerIds && this.__root.__outerIds["x-cat-root-id"] ?
        this.__root.__outerIds["x-cat-root-id"] : this.__root.__messageId,
      "x-cat-trace-mode": "true",
    });
  }
};

CatSpan.prototype.end = function () {
  if (!this.__close) {
    if (this.__timeout) {
      clearTimeout(this.__timeout);
      this.__timeout = null;
    }
    this.__endTime = +new Date();
    this.__endMicroSeconds = util.getMicroSeconds();
    this.__children.forEach((item) => {
      if (item.__type == "span" && !item.__close) {
        item.end();
      }
    });
    this._createPlaceHolder();
    if (this.__properties["Tree.Begin"]) {
      this.__properties["Tree.End"] = new Date().getTime();
    }
    this.__close = true;
    queue.moveToSendQueue(this);
    CatSpanAggregator.aggregate(this);
    this.__members.forEach((emitter) => {
      delete emitter.__spanEmit;
      let memberProperties = this.__membersWeakMap.get(emitter);
      if (memberProperties) {
        if (memberProperties.hasOwnEmit) {
          emitter.emit = memberProperties.emit;
        } else {
          delete emitter.emit;
        }
        this.__membersWeakMap.delete(emitter);
      }
    });
    this.__members = [];
    return this.__parent || require("../export.js");
  }
};
function wrapperParent(parent) {
  if (parent && parent.__close) {
    if (asyncRoot.has(parent.__root)) {
      const __root = wrapperParent(asyncRoot.get(parent.__root));
      //if (parent.__root) {
      asyncRoot.set(parent.__root, __root);
      //}
      parent = __root;
    } else {
      let span = new CatSpan(parent, "_CatMergeTree", "_CatMergeTree");
      asyncRoot.set(span, parent.__root);
      const msgId = messageId.getMessageId();
      placeHolder.set(parent.__root, {
        "x-cat-id": msgId,
        "x-cat-parent-id": span.__root.__messageId,
        "x-cat-root-id": span.__root.__outerIds && span.__root.__outerIds["x-cat-root-id"] ?
          span.__root.__outerIds["x-cat-root-id"] : span.__root.__messageId,
        "x-cat-trace-mode": "true",
      });
      span.setTimeout(CatSpan.__timeout, () => {
        span.event("RemoteCall", "RunAway", `${msgId}=查看更多`);
        span.__RemoteCall = true;
        asyncRoot.delete(span);
      });
      return span;
      //parent = span;
    }
  }
  return parent;
}

CatSpan.prototype.span = function (type, name, data) {
  return new CatSpan(wrapperParent(this), type, name, data);
};

CatSpan.prototype.event = function (type, name, data) {
  return new CatEvent(wrapperParent(this), type, name, data);
};

CatSpan.prototype.error = function (message, stack) {
  return new CatError(wrapperParent(this), message, stack);
};

CatSpan.prototype.tags = function (scenario, indexedTags, storedTags) {
  return new CatTags(wrapperParent(this), scenario, indexedTags, storedTags);
};

CatSpan.prototype._logging = function (message) {
  return new CatLogging(wrapperParent(this), message);
};

CatSpan.prototype.toString = function () {
  let ret = [
    "SPAN " +
    util.formatDateTime(this.__startTime, "hh:mm:ss,SSS") +
    " " +
    (this.__endTime - this.__startTime) +
    "ms " +
    this.type +
    " " +
    this.name +
    " " +
    truncateString(util.stringify(this.data), 50),
  ];
  let lastIdx = this.__children.length - 1;
  this.__children.forEach((item, i) => {
    let prefix = "";
    let lines = item.toString().split(/\r?\n/g);
    lines.forEach((line, j) => {
      if (j == 0) {
        prefix = i == lastIdx ? "┗━┈" : "┣━┈";
      } else {
        if (i == lastIdx) {
          prefix = "┈┈┈";
        } else {
          prefix = "┃┈┈";
        }
      }
      ret.push(prefix + line);
    });
  });

  if (!this.__parent) {
    let lastIndex = ret.length - 1;
    ret = ret.map((line, i) => {
      let prefix =
        i == 0 ?
        lastIndex == 0 ?
        "━━┈" :
        "┏━┈" :
        i == lastIndex ?
        "┗━┈" :
        "┃┈┈";
      return prefix + line;
    });
  }
  return ret.join("\r\n");
};

CatSpan.__timeout = 30000;

module.exports = CatSpan;