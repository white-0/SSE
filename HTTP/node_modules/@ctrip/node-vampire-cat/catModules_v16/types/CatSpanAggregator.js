const util = require('@ctrip/node-vampire-util');
const StatMessageTree = require('./CatStatMessageSpans');

function CatSpanAggregator() {
    this.addQueueInternal();
    this.SpanAggregatorQueue = Object.create(null); //{ timestamp: {statMessageTree} }; 
    this.aggregatorRules = {};
}

/**
 * 注：java cat transaction可以统计error,nodejs没有
 */
CatSpanAggregator.prototype.aggregate = function (originSpan) {
    const {
        type,
        name
    } = this.aggregateFilter({
        type: originSpan.type,
        name: originSpan.name
    });
    const aggregatorData = this.makeSurSpanExist(type, name, originSpan.__startTime);
    aggregatorData.add(originSpan);
}
CatSpanAggregator.prototype.aggregateFilter = function ({
    type,
    name
}) {
    if (this.aggregatorRules[type]) {
        const rules = this.aggregatorRules[type];
        if (rules && util.type(rules) === 'array') {
            for (const {
                    rule,
                    aggregateName
                } of rules) {
                if (rule && util.type(rule) === 'regexp' && rule.test(name)) return {
                    type,
                    name: name.replace(rule, aggregateName || 'CAT_TREE_AGGREGATOR')
                };
                if (rule && util.type(rule) === 'function') {
                    const _name = rule(name);
                    return {
                        type,
                        name: _name || 'CAT_TREE_AGGREGATOR'
                    }
                }
            }
        } else {
            console.log('[@ctrip/node-vampire-cat] aggregatorRules invalid,rules must be in array format.');
        }
    }
    return {
        type,
        name
    }
}
/**
 * 聚合一颗statMessageTree,以三个维度聚合
 * @param {string} _type 
 * @param {string} _name 
 * @param {number} _timestamp 
 * @returns 
 */
CatSpanAggregator.prototype.makeSurSpanExist = function (_type, _name, _timestamp) {
    const timestamp = this.getTimeTampMm(_timestamp);
    let timeItem = this.SpanAggregatorQueue[timestamp]
    if (!timeItem) {
        timeItem = this.SpanAggregatorQueue[timestamp] = {
            ['statMessageTree']: this.createStatMessageTree()
        };
        const sendSpan = new StatMessageTree('System', 'CatSpanAggregator');
        sendSpan.__timeStamp = timestamp;
        sendSpan.durationInMicro = 100 * 1000; //ms
        timeItem['statMessageTree'].message = sendSpan;
        timeItem['statMessageTree'].__timeStamp = timestamp;
        const _itemAggregator = new SpanData(_type, _name);
        timeItem['statMessageTree']._itemAggregator = {
            [_type]: {
                [_name]: _itemAggregator
            }
        };
        return _itemAggregator;
    }

    let typeItem = timeItem['statMessageTree']._itemAggregator[_type];
    if (!typeItem) {
        const _itemAggregator = new SpanData(_type, _name);
        timeItem['statMessageTree']._itemAggregator[_type] = {
            [_name]: _itemAggregator
        };
        return _itemAggregator;
    }

    let nameItem = typeItem[_name];
    if (!nameItem) {
        const _itemAggregator = new SpanData(_type, _name);
        typeItem[_name] = _itemAggregator;
        return _itemAggregator;
    }

    return nameItem;
}

//send data
CatSpanAggregator.prototype.sendSpanData = function () {
    if (Object.keys(this.SpanAggregatorQueue).length > 0) {
        const _SpanAggregatorQueue = this.SpanAggregatorQueue;
        this.SpanAggregatorQueue = Object.create(null);
        for (const timeStamp in _SpanAggregatorQueue) {
            if (Object.prototype.hasOwnProperty.call(_SpanAggregatorQueue, timeStamp)) {
                const {
                    statMessageTree
                } = _SpanAggregatorQueue[timeStamp];
                statMessageTree.end();
            }
        }
    }
}

CatSpanAggregator.prototype.addQueueInternal = function () {
    setInterval(() => {
        this.sendSpanData();
    }, 5000).unref();
}
CatSpanAggregator.prototype.createStatMessageTree = function () {
    const statMessageTree = new StatMessageTree();
    return statMessageTree;
}
CatSpanAggregator.prototype.getTimeTampMm = function (timestamp) {
    try {
        return new Date(util.formatDateTime(new Date(timestamp), "yyyy-MM-dd hh:mm")).getTime();
    } catch (e) {
        return new Date(util.formatDateTime(new Date(), "yyyy-MM-dd hh:mm")).getTime();
    }
}

function SpanData(type, name) {
    this.type = type;
    this.name = name;
    this.count = 0;
    this.sum = 0;
    this.max = {
        messageId: '',
        value: -1
    };
    this.min = 2147483647;
    this.self = 0;
    this.fail = 0;
    this.messageId = null;
    this.durations = new Map();
    this.distribution = new Map();
}

SpanData.prototype.add = function (span) {
    const messageId = span.__messageId;
    this.count++;
    (messageId && !this.messageId) && (this.messageId = messageId);
    const duration = parseInt((span.__endMicroSeconds - span.__startMicroSeconds) / 1000);
    this.sum = this.sum + duration;
    const oneDuration = parseInt(duration / this.count);
    if (oneDuration < this.min) {
        this.min = oneDuration;
    }
    if (span.status == 'ERROR' && !span.type.includes('infoSec-')) {
        this.fail++;
    }
    if (oneDuration >= this.max.value) {
        this.max.value = oneDuration;
        this.max.messageId = span.__messageId || null;
    }
    const durations_count = this.adgetOrCreateCountd(this.durations, this.computeDuration(oneDuration));
    this.durations.set(this.computeDuration(oneDuration), durations_count + this.count);
    const distribution_count = this.adgetOrCreateCountd(this.distribution, this.computeDistribution(oneDuration));
    this.distribution.set(this.computeDistribution(oneDuration), distribution_count + this.count)
}
SpanData.prototype.adgetOrCreateCountd = function (durations, position) {
    let count = durations.get(position);
    if (count == null) {
        count = 0;
        durations.set(position, count);
    }
    return count;
}
SpanData.prototype.computeDuration = function (duration) {
    if (duration < 20) {
        return duration;
    } else if (duration < 200) {
        return duration - duration % 5;
    } else if (duration < 2000) {
        return duration - duration % 50;
    } else {
        return duration - duration % 500;
    }
}
SpanData.prototype.computeDistribution = function (duration) {
    let dk = 1;

    if (duration > 65536) {
        dk = 65536;
    } else {
        while (dk < duration) {
            dk = dk << 1;
        }
    }

    return dk;
}

SpanData.prototype.MapToString = function (map) {
    const str = [];
    map.forEach((value, key) => {
        str.push(key + ',' + value);
    })
    return str.join('|');
}


module.exports = new CatSpanAggregator();