const frameworkFoundation = require('@ctrip/node-vampire-foundation-framework');
const util = require('@ctrip/node-vampire-util');
const pm2 = require('../libs/pm2id');

let procName = process.execPath.replace(/^.*[/\\]/, '');

function createRaw(item) {
    const _context = new Context(item);
    _context.generateMapping();
    let ip = util.getHostIp();
    if (item.__splitProcess) {
        ip += '@@' + pm2.id;
    }
    let head = Buffer.concat([
        Buffer.from('ST1\t'),
        createVarString(frameworkFoundation.getAppID()), // Domain
        createVarString(util.getHostName()), // Host Name
        createVarString(ip), // Client IP
        createVarString(procName), // Thread Group Name
        createVarString(process.pid), // Thread ID

        createVarString(procName), // Thread Name
        createVarString(item.__outerIds ? item.__outerIds['x-cat-id'] : item.__messageId), // Message ID
        createVarString(item.__outerIds ? item.__outerIds['x-cat-parent-id'] : null), // Parent Message ID
        createVarString(item.__outerIds ? item.__outerIds['x-cat-root-id'] : null), // Root Message ID
        createVarString('null'), // Session Token
        _context.encodeTokensFn(),
        _context.writeSkippableProperties(item.__properties)
    ]);
    let body = createItemRaw(_context, item.message);
    let size = Buffer.alloc(4);
    size.writeUIntBE(head.length + body.length, 0, 4);
    return Buffer.concat([
        Buffer.from('zcat'),
        size,
        head,
        body
    ]);
}

function createItemRaw(_context, item) {
    let body = Buffer.alloc(0);
    if (item.__type == 'statMessageEvent') {
        body = Buffer.concat([
            Buffer.from('E'),
            util.varint(item.__timeStamp - _context.baseline),
            _context.writeToken(item.type),
            _context.writeToken(item.name),
            _context.writeStatus(item.status),
            createVarString(util.stringify(item.data))
        ]);
    } else if (item.__type == 'statMessage') {
        body = Buffer.concat([
            Buffer.from('t'),
            util.varint(item.__timeStamp - _context.baseline),
            _context.writeToken(item.type),
            _context.writeToken(item.name),
            Buffer.concat(item.__children.map(function (subItem) {
                return createItemRaw(_context, subItem)
            })),
            Buffer.from('T'),
            _context.writeSkippableProperties(item.__properties),
            _context.writeStatus(item.status),
            createVarString(util.stringify(item.data)),
            util.varint(item.durationInMicro) //这里在CatSpanAggregator中聚合时设置
        ]);
    }
    return body;
}

function Context(item) {
    this.tree = item;
    this.baseline = null;
    this.encodedTokens = new Map();
}

Context.prototype.generateMapping = function () {
    const root = this.tree.message;
    this.baseline = root.__timeStamp;
    this.addEncodedProperties(root.__properties);
    this.addEncodedTokens(root);
}

Context.prototype.writeStatus = function (status) {
    if (status === '0') {
        return Buffer.alloc(1);
    } else {
        return this.writeToken(status);
    }
}

Context.prototype.addEncodedTokens = function (msg) {
    this.addEncodedToken(msg.type);
    this.addEncodedToken(msg.name);
    if (!msg.status === '0') {
        this.addEncodedToken(msg.status);
    }
    if (msg.__type === 'statMessage') {
        this.addEncodedProperties(msg.__properties);
        for (const item of msg.__children) {
            this.addEncodedTokens(item);
        }
    }
}

Context.prototype.addEncodedProperties = function (properties) {
    if (!properties || Object.keys(properties).length === 0) {
        return;
    }
    for (const item in properties) {
        this.addEncodedToken(item);
        this.addEncodedToken(properties[item]);
    }
}

Context.prototype.addEncodedToken = function (token) {
    if (this.encodedTokens.get(token) == null) {
        this.encodedTokens.set(token, this.encodedTokens.size)
    }
}

Context.prototype.reset = function (tree) {
    this.tree = tree;
    this.encodedTokens.clear();
}

Context.prototype.encodeTokensFn = function () {
    const token_size = this.encodedTokens.size;
    let _ret = [];
    _ret.push(util.varint(this.baseline));
    _ret.push(util.varint(token_size));
    this.encodedTokens.forEach((value, key) => {
        _ret.push(createVarString(key))
    })
    return Buffer.concat(_ret);
}

//对应 cat\cat-client\src\main\java\com\dianping\cat\message\spi\codec\CodecHelper.java
Context.prototype.writeSkippableProperties = function (properties) {
    if (!properties || Object.keys(properties).length === 0) {
        return Buffer.alloc(4);
    }
    const buf_len = util.varint(Object.keys(properties).length);
    let encodedToken_buf = [];
    for (const item in properties) {
        encodedToken_buf.push(this.writeToken(item));
        encodedToken_buf.push(this.writeToken(properties[item]));
    }
    encodedToken_buf = Buffer.concat(encodedToken_buf)
    const payloadLen = util.intToBuff(buf_len.length + encodedToken_buf.length, 4);
    return Buffer.concat([payloadLen, buf_len, encodedToken_buf])
}

Context.prototype.writeToken = function (token) {
    let index = this.encodedTokens.get(token);
    return util.varint(index);
}

function createVarString(str) {
    if (util.type(str) != 'string') {
        str = '' + str;
    }
    let buff = Buffer.from(str);
    return Buffer.concat([
        util.varint(buff.length),
        buff
    ]);
}

module.exports = createRaw;
