'use strict'
const fs = require('fs')
const pm2 = require('@ctrip/node-vampire-pm2')
const Locker = require('@ctrip/node-vampire-locker')
const {
  FILE_META_FILENAME,
  ROLE,
  IGNITION_TIMEOUT_MILLISECONDS,
  IPC_MESSAGE
} = require('../common/constants')
const foundation = require('../common/foundation')
const { generateFileLockerID, generateDirPath, checkFileExistSync } = require('../util')
const timer = require('../timer')
const BaseIgnition = require('./base')
const ignitionLog = require('./log')
const path = require('path')
const FIRE_UP = Symbol.for('SHARK#IGNITION_FIRE_UP')

class MasterIgnition extends BaseIgnition {
  constructor () {
    super(
      IGNITION_TIMEOUT_MILLISECONDS.MASTER,
      ROLE.MASTER
    )
  }

  // to follow Ctrip NodeJS Standard (node_modules read only at runtime)
  // copy file-cache from @ctrip/shark-sdk/file-cache/{sharkAppID} to /opt/data/{appID}/shark-{sharkAppID}
  // when former exist and latter not exist
  copyFileCache () {
    const postInstallFileCachePath = path.resolve(__dirname, `../../file-cache/${foundation.appID}`)
    const fileCachePath = generateDirPath(foundation.appID)
    if (checkFileExistSync(`${postInstallFileCachePath}/${FILE_META_FILENAME}`) && !checkFileExistSync(`${fileCachePath}/${FILE_META_FILENAME}`)) {
      fs.readdirSync(postInstallFileCachePath).forEach(filename => {
        if (/\.json$/.test(filename)) {
          fs.copyFileSync(`${postInstallFileCachePath}/${filename}`, `${fileCachePath}/${filename}`)
        }
      })
    }
  }

  [FIRE_UP] () {
    foundation.fileLocker = new Locker(generateFileLockerID(foundation.appID))
    foundation.fileLocker.lockSync()

    try {
      fs.mkdirSync(generateDirPath(foundation.appID), { recursive: true })
    } catch (error) {
      throw new Error(`Shark SDK will read and write data in the /opt/data directory[${generateDirPath(foundation.appID)}]. Please ensure the directory exists and has read and write permissions.`)
    }

    this.copyFileCache()
    ignitionLog.setLog()
    foundation.fileLocker.unlockSync()

    return this.fetchFullFromFileAndTalos()
      .then(() => {
        pm2.broadcast(IPC_MESSAGE.TALOS_FULL_TRANS)
        new timer.TalosTimer().setup()
        new timer.TalosFullTimer().setup()
        new timer.MetricTimer().setup()
        new timer.UsedKeysTimer().setup()
        new timer.UndefinedKeysTimer().setup()
        ignitionLog.indexedTags.init_process.push('timer')
      })
      .catch(error => {
        throw error
      })
      .finally(() => {
        ignitionLog.report()
      })
  }
}

module.exports = MasterIgnition
