'use strict'
const fs = require('fs')
const is = require('is-type-of')
const qconfig = require('@ctrip/node-vampire-qconfig')
const cat = require('@ctrip/node-vampire-cat')
const foundationFramework = require('@ctrip/node-vampire-foundation-framework')
const constants = require('../common/constants')
const ignitionLog = require('./log')
const logger = require('../log')
const foundation = require('../common/foundation')
const { NPM_VERSION, SDK_VERSION, CAT_NAME, CATSPAN_TYPE, CATEVENT_TYPE, FILE_META_FILENAME } = require('../common/constants')
const addon = require('../store/addon')
const talos = require('../provider/talos')
const file = require('../provider/file')
const { cleanRequire, generateDirPath, extractFullDataFromFile, writeFullDataToFile } = require('../util')
const pkg = require('../../package.json')
const store = require('../store')
const FIRE_UP = Symbol.for('SHARK#IGNITION_FIRE_UP')
const FIRE_UP_TIMEOUT = Symbol.for('SHARK#IGNITION_FIRE_UP_TIMEOUT')

class BaseIgnition {
  constructor (initialTimeout, role) {
    this.initialTimeout = initialTimeout
    this.ignited = false
    this.ignitionPromise = null
    this.role = role
  }

  init (options) {
    if (this.ignited) {
      return Promise.resolve()
    }
    if (this.ignitionPromise !== null) {
      return this.ignitionPromise
    }

    // start ignite
    const startTime = new Date()
    this.ignitionPromise = foundationFramework.getIDC().then(idc => {
      foundation.idc = idc

      return new Promise(resolve => {
        // add cat span for ignition process
        cat.span(CAT_NAME, CATSPAN_TYPE.IGNITION).run((done) => {
          // set options
          if (is.isObject(options)) {
            const { appID, appId, logLevel } = options
            if (is.isString(appID) || is.isNumber(appID)) {
              foundation.appID = parseInt(appID)
            }
            // 兼容旧代码调用
            if (is.isString(appId) || is.isNumber(appId)) {
              foundation.appID = parseInt(appId)
            }

            if (is.isNumber(logLevel)) {
              foundation.logLevel = logLevel
            }
          }
          // init addon globals
          this.initGlobals()
          ignitionLog.indexedTags.init_process.push('appid')
          Promise.race([
            this[FIRE_UP](),
            this[FIRE_UP_TIMEOUT]()
          ]).catch(e => {
            logger.error('ignite error!', e)
            process.exit(1)
          }).then(() => {
            return foundation.isPROD
              ? Promise.resolve()
              : qconfig.getConfig(constants.QCONFIG.FILENAME).get()
          }).then(() => {
            this.ignited = true
            foundation.ignited = true
            logger.info('ignite success!', {
              time: `${+new Date() - startTime}ms`
            })
            cat.event(CATEVENT_TYPE.IGNITE, 'ignite success', {
              sharkAppID: foundation.appID,
              version: pkg.version
            })
            done()
            resolve()
          })
        })
      })
    })

    return this.ignitionPromise
  }

  [FIRE_UP] () {
    return Promise.reject(new Error('to be implemented'))
  }

  [FIRE_UP_TIMEOUT] () {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        reject(new Error('ignite timeout'))
      }, this.initialTimeout)
    })
  }

  /**
   * 初始化全局变量
   */
  initGlobals () {
    return addon.initGlobals(
      foundation.appID,
      SDK_VERSION,
      NPM_VERSION,
      foundation.clientIp,
      this.role
    )
  }

  /**
   * 从 file / talos 获取多语言翻译数据结构
   */
  fetchFullFromFileAndTalos () {
    return talos.initUpdateConfiguration()
      .then(() => file.fetchFullDataStore())
      .then(fileResult => {
        if (fileResult) {
          ignitionLog.indexedTags.init_process.push('data')
          ignitionLog.indexedTags.data_init_way = 0
          ignitionLog.indexedTags.ignite_code = ignitionLog.lossy
            ? 800
            : 200

          return Promise.resolve()
        }

        return talos.fetchBaseLocaleStore()
          .then(([appIds, config]) => Promise.all([
            talos.fetchSharkStore(appIds),
            config
          ]))
          .then(([translations, config]) => {
            const fullResult = {
              config: config.localeConfigs,
              translations: {}
            }
            translations.forEach(({ appID, trans }) => {
              fullResult.translations[appID] = {
                timestamp: trans.length ? trans[trans.length - 1].lastChangeTime : 0,
                translation: trans
              }
            })

            ignitionLog.indexedTags.init_process.push('data')
            ignitionLog.indexedTags.data_init_way = 1
            ignitionLog.indexedTags.ignite_code = ignitionLog.lossy
              ? 800
              : 200

            return new Promise(resolve => {
              foundation.fileLocker.run(done => {
                writeFullDataToFile(foundation.appID, fullResult)
                  .then(() => {
                    resolve()
                    done()
                  })
              })
            })
          })
      })
      .catch(error => {
        if (foundation.isPROD) {
          return new Promise((resolve, reject) => {
            foundation.fileLocker.run(done => {
              const filePath = `${generateDirPath(foundation.appID)}/${FILE_META_FILENAME}`
              try {
                fs.accessSync(filePath, fs.constants.R_OK | fs.constants.W_OK)
              } catch {
                // local file non-exist
                ignitionLog.indexedTags.ignite_code = 901
                cat.event(CATEVENT_TYPE.IGNITE, 'local file non-exist', error && error.stack)
                reject(error)
                done()
                return
              }

              const meta = cleanRequire(filePath)
              meta.ignited = true
              fs.writeFileSync(filePath, JSON.stringify(meta))

              ignitionLog.indexedTags.init_process.push('data')
              ignitionLog.indexedTags.data_init_way = 0
              ignitionLog.indexedTags.ignite_code = 800

              resolve(extractFullDataFromFile(foundation.appID))
              done()
            })
          })
            .then(fileResult => store.updateFullTranslationAndBaseLocaleConfig(fileResult))
        } else {
          ignitionLog.indexedTags.ignite_code = 901
          cat.event(CATEVENT_TYPE.IGNITE, 'local file non-exist', error && error.stack)
          throw error
        }
      })
  }
}

module.exports = BaseIgnition
