'use strict'
const path = require('path')
const fsp = require('fs/promises')
const Piscina = require('piscina')
const ignitionLog = require('../ignition/log')
const talos = require('./talos')
const store = require('../store')
const {
  generateFileDownloadUrl,
  cleanRequire,
  generateDirPath,
  appendIncrementalTransToFile,
  extractFullDataFromFile
} = require('../util')
const foundation = require('../common/foundation')
const { FILE_META_FILENAME } = require('../common/constants')
const soa = require('../soa')
const logger = require('../log')

const unzipWorker = new Piscina({
  filename: path.resolve(__dirname, '../util/unzip.js'),
  minThreads: 1,
  maxThreads: 1,
  maxQueue: 1,
  niceIncrement: 10000
})

class FileProvider {
  /**
   * 获取并解析 S3 / Ceph 文件
   * 目前支持 IBU-VPC / SHA-VPC / OPS-VPC
   * @returns {Promise<void>|Promise<unknown>}
   */
  fetchAndParseFileCache () {
    const fileUrl = generateFileDownloadUrl(foundation.appID, talos.sourceUrl)
    ignitionLog.indexedTags.file_url = fileUrl

    if (!talos.useFileLoader) {
      return Promise.resolve()
    }

    const dir = generateDirPath(foundation.appID)

    return new Promise(resolve => {
      foundation.fileLocker.run(done => {
        unzipWorker.run({ appID: foundation.appID, dir, fileUrl })
          .then(result => {
            if (result.fileResponseCode) {
              ignitionLog.indexedTags.file_response_code = result.fileResponseCode.toString()
            }
            if (result.success) {
              // append incremental trans to file cache
              const meta = cleanRequire(`${dir}/${FILE_META_FILENAME}`)

              return Promise.all(Object.entries(meta.timestamp).map(([_appID, _timestamp]) => this.fetchIncrementalToFull(_appID, _timestamp)))
                .then(incrementalTransList => {
                  const appendPromiseList = []
                  incrementalTransList.forEach(incrementalTrans => {
                    if (incrementalTrans && incrementalTrans.trans && incrementalTrans.trans.length) {
                      const { appID, timestamp, trans } = incrementalTrans
                      meta.timestamp[appID] = timestamp
                      appendPromiseList.push(
                        appendIncrementalTransToFile(`${dir}/${appID}.json`, trans)
                      )
                    }
                  })

                  // mark ignited
                  meta.ignited = true
                  appendPromiseList.push(fsp.writeFile(`${dir}/${FILE_META_FILENAME}`, JSON.stringify(meta)))
                  return Promise.all(appendPromiseList)
                })
            }

            return Promise.resolve()
          }).then(result => {
            resolve(result)
            done()
          }).catch(error => {
            logger.warning(`unzip ${foundation.appID} ${dir} error`, error)
            resolve()
            done()
          })
      })
    })
  }

  fetchIncrementalToFull (appID, timestamp, list = []) {
    return soa.talos.getTrans(appID, timestamp)
      .then(({ timestamp, hasMore, trans }) => {
        list.push(...trans)
        return { timestamp, hasMore }
      })
      .then(({ timestamp, hasMore }) => {
        if (hasMore) {
          return this.fetchIncrementalToFull(appID, timestamp, list)
        }
        return { appID, timestamp, trans: list }
      })
      .catch(error => {
        ignitionLog.hasLossy()
        logger.warning(`talos fetch incremental ${appID} ${timestamp} error`, error)
      })
  }

  fetchFullDataStore () {
    return this.fetchAndParseFileCache()
      .then(result => {
        if (result) {
          return new Promise(resolve => {
            foundation.fileLocker.run(done => {
              resolve(extractFullDataFromFile(foundation.appID))
              done()
            })
          }).then(data => store.updateFullTranslationAndBaseLocaleConfig(data))
        }

        return Promise.resolve()
      })
  }
}

module.exports = new FileProvider()
