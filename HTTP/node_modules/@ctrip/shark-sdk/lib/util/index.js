const fs = require('fs')
const fsp = require('fs/promises')
const crypto = require('crypto')
const bfj = require('bfj')
const cat = require('@ctrip/node-vampire-cat')
const foundationFramework = require('@ctrip/node-vampire-foundation-framework')
const logger = require('../log')
const { FILE_CONFIG_FILENAME, FILE_META_FILENAME, CATEVENT_TYPE } = require('../common/constants')

const generateDirPath = sharkAppID => `/opt/data/${foundationFramework.getAppID()}/shark-${sharkAppID}`

const generateFileLockerID = sharkAppID => crypto.createHash('md5').update(generateDirPath(sharkAppID)).digest('hex')

const generateFileDownloadUrl = (appID, url) => {
  const zipUrl = `${appID}.zip`
  return url
    ? url.replace(/%s.zip$/, zipUrl)
    : zipUrl
}

const cleanRequire = jsonFilePath => {
  const absolutePath = require.resolve(jsonFilePath)

  // clean require cache
  const module = require.cache[absolutePath]
  if (module) {
    if (module.parent) {
      module.parent.children.splice(module.parent.children.indexOf(module), 1)
    }
    delete require.cache[absolutePath]
  }

  try {
    return require(absolutePath)
  } catch (error) {
    cat.event(CATEVENT_TYPE.REQUIRE_ERROR, `require ${absolutePath} error`, error && error.stack)
    logger.error(`require ${absolutePath} error`, error)
  }
}

const appendIncrementalTransToFile = (filePath, trans) => {
  return fsp.stat(filePath)
    .then(stat => fsp.truncate(filePath, stat.size - 1))
    .then(() => bfj.stringify(trans))
    .then(str => fsp.appendFile(filePath, `,${str.replace(/^\[/, '')}`))
}

const extractFullDataFromFile = appID => {
  const dir = generateDirPath(appID)

  const data = {
    config: cleanRequire(`${dir}/${FILE_CONFIG_FILENAME}`),
    translations: {}
  }

  const meta = cleanRequire(`${dir}/${FILE_META_FILENAME}`)

  Object.entries(meta.timestamp).forEach(([_appID, _timestamp]) => {
    data.translations[_appID] = {
      timestamp: _timestamp,
      translation: cleanRequire(`${dir}/${_appID}.json`)
    }
  })

  return data
}

const writeFullDataToFile = (appID, data) => {
  const dir = generateDirPath(appID)

  const meta = {
    timestamp: {},
    ignited: true
  }

  return Promise.all([
    ...Object.entries(data.translations).map(([_appID, { timestamp, translation }]) => {
      meta.timestamp[_appID] = timestamp
      return bfj.write(`${dir}/${_appID}.json`, translation)
    }),
    bfj.write(`${dir}/${FILE_CONFIG_FILENAME}`, data.config),
    bfj.write(`${dir}/${FILE_META_FILENAME}`, meta)
  ])
}

const checkFileExistSync = filePath => {
  let exist = false
  try {
    fs.accessSync(filePath, fs.constants.R_OK | fs.constants.W_OK)
    exist = true
  } catch {}
  return exist
}

module.exports = {
  generateFileLockerID,
  generateDirPath,
  generateFileDownloadUrl,
  cleanRequire,
  appendIncrementalTransToFile,
  extractFullDataFromFile,
  writeFullDataToFile,
  checkFileExistSync
}
