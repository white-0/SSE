const fs = require('fs')
const fsp = require('fs/promises')
const http = require('http')
const https = require('https')
const stream = require('stream')
const yauzl = require('yauzl')
const { FILE_META_FILENAME, FILE_TIMEOUT_MILLISECONDS, TRANS_FILENAME_MATCH } = require('../common/constants')

module.exports = ({ appID, dir, fileUrl }) => new Promise(resolve => {
  let fileResponseCode = null

  const fileStream = new stream.Transform()
  fileStream._transform = function (data, encoding, callback) {
    callback(null, data)
  }

  const bufs = []
  const meta = {
    timestamp: {},
    ignited: false
  }

  fileStream.on('error', err => {
    console.log(`file fetch ${appID} error`, err)
    resolve({
      fileResponseCode
    })
  })

  fileStream.on('data', chunk => {
    bufs.push(chunk)
  })

  fileStream.on('end', () => {
    yauzl.fromBuffer(Buffer.concat(bufs), { lazyEntries: true }, (err, zipfile) => {
      if (err) {
        throw err
      }

      zipfile.readEntry()

      zipfile.on('end', () => {
        fsp.writeFile(`${dir}/${FILE_META_FILENAME}`, JSON.stringify(meta))
          .then(() => {
            resolve({
              fileResponseCode,
              success: true
            })
          })
      })
      zipfile.on('entry', entry => {
        if (/\/$/.test(entry.fileName)) {
          zipfile.readEntry()
        } else {
          zipfile.openReadStream(entry, (error, readStream) => {
            if (error) {
              throw error
            }

            const transFilenameMatched = entry.fileName.match(TRANS_FILENAME_MATCH)
            if (transFilenameMatched) {
              const { innerAppID, timestamp } = transFilenameMatched.groups
              meta.timestamp[innerAppID] = parseInt(timestamp)
            }

            const filename = transFilenameMatched ? `${transFilenameMatched.groups.innerAppID}.json` : entry.fileName

            const writeStream = fs.createWriteStream(`${dir}/${filename}`)
            readStream.pipe(writeStream)

            Promise.all([
              new Promise(_resolve => {
                readStream.on('end', _resolve)
              }),
              new Promise(_resolve => {
                writeStream.on('close', _resolve)
              })
            ]).then(() => zipfile.readEntry())
          })
        }
      })
    })
  })

  const opt = {
    headers: {},
    timeout: FILE_TIMEOUT_MILLISECONDS
  }

  let httpClient = http
  if (/^https/.test(fileUrl)) {
    httpClient = https
    opt.rejectUnauthorized = false
  }

  const req = httpClient.get(fileUrl, opt, res => {
    fileResponseCode = res.statusCode
    if (res.statusCode !== 200) {
      fileStream.emit('error', new Error(`File[${fileUrl}] statusCode:${res.statusCode}`))
      return
    }

    res.on('data', (chunk) => {
      fileStream.write(chunk)
    }).on('end', () => {
      fileStream.end()
    })
  }).on('error', err => {
    fileResponseCode = 500
    fileStream.emit('error', err)
  })

  req.on('error', () => {
    req.abort()
  }).on('timeout', () => {
    req.abort()
  })
})
