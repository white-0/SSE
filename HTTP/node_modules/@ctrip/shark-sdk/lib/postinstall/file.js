'use strict'
const fs = require('fs')
const fsp = require('fs/promises')
const path = require('path')
const https = require('https')
const stream = require('stream')
const yauzl = require('yauzl')
const { FILE_TIMEOUT_MILLISECONDS, TRANS_FILENAME_MATCH, FILE_META_FILENAME } = require('../common/constants')

module.exports = (appID, url) => {
  const dir = path.resolve(__dirname, `../../file-cache/${appID}`)

  return fsp.mkdir(dir, { recursive: true }).then(() => new Promise(resolve => {
    const bufs = []
    const meta = {
      timestamp: {},
      ignited: false
    }

    const fileStream = new stream.Transform()
    fileStream._transform = function (data, encoding, callback) {
      callback(null, data)
    }

    fileStream.on('error', err => {
      console.log(`file fetch ${appID} error`, err)
      resolve()
    })

    fileStream.on('data', chunk => {
      bufs.push(chunk)
    })

    fileStream.on('end', () => {
      yauzl.fromBuffer(Buffer.concat(bufs), { autoClose: true, lazyEntries: true }, (err, zipfile) => {
        if (err) {
          throw err
        }

        zipfile.readEntry()

        zipfile.on('end', () => {
          fsp.writeFile(`${dir}/${FILE_META_FILENAME}`, JSON.stringify(meta))
            .then(() => {
              resolve()
            })
        })

        zipfile.on('entry', entry => {
          if (/\/$/.test(entry.fileName)) {
            zipfile.readEntry()
          } else {
            zipfile.openReadStream(entry, (error, readStream) => {
              if (error) {
                throw error
              }

              const transFilenameMatched = entry.fileName.match(TRANS_FILENAME_MATCH)
              if (transFilenameMatched) {
                const { innerAppID, timestamp } = transFilenameMatched.groups
                meta.timestamp[innerAppID] = parseInt(timestamp)
              }

              const filename = transFilenameMatched ? `${transFilenameMatched.groups.innerAppID}.json` : entry.fileName
              readStream.pipe(fs.createWriteStream(`${dir}/${filename}`))

              readStream.on('end', () => {
                zipfile.readEntry()
              })
            })
          }
        })
      })
    })

    const opt = {
      timeout: FILE_TIMEOUT_MILLISECONDS,
      rejectUnauthorized: false
    }

    const req = https.get(url, opt, res => {
      if (res.statusCode !== 200) {
        fileStream.emit('error', new Error(`File[${url}] statusCode:${res.statusCode}`))
        return
      }

      res.on('data', (chunk) => {
        fileStream.write(chunk)
      }).on('end', () => {
        fileStream.end()
      })
    }).on('error', err => {
      fileStream.emit('error', err)
    })

    req.on('error', () => {
      req.abort()
    }).on('timeout', () => {
      req.abort()
    })
  }))
}
