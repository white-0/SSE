'use strict'
const fs = require('fs')
const path = require('path')
const is = require('is-type-of')
const LogLevel = require('./log-level')
const foundation = require('../common/foundation')
const Logger = require('./logger')
const LOGGERS = Symbol('SHARK#LOGGERS')

class LogProvider extends Logger {
  constructor () {
    super()
    this[LOGGERS] = []
    this.inject()
  }

  inject () {
    fs.readdirSync(path.resolve(__dirname, 'impl'))
      .filter(file => /\.js$/.test(file))
      .map(file => require(path.resolve(__dirname, 'impl', file)))
      .forEach(logger => {
        if (!(logger instanceof Logger)) {
          return
        }
        if (logger.enabledEnv === '*' ||
          (is.isArray(logger.enabledEnv) &&
          logger.enabledEnv.indexOf(foundation.env) !== -1)) {
          this[LOGGERS].push(logger)
        }
      })
  }

  debug () {
    if (foundation.logLevel > LogLevel.DEBUG) {
      return
    }
    const args = Array.prototype.slice.call(arguments)
    this[LOGGERS].forEach(logger => logger.debug(args))
  }

  info () {
    if (foundation.logLevel > LogLevel.INFO) {
      return
    }
    const args = Array.prototype.slice.call(arguments)
    this[LOGGERS].forEach(logger => logger.info(args))
  }

  warning () {
    if (foundation.logLevel > LogLevel.WARNING) {
      return
    }
    const args = Array.prototype.slice.call(arguments)
    this[LOGGERS].forEach(logger => logger.warning(args))
  }

  error () {
    if (foundation.logLevel > LogLevel.ERROR) {
      return
    }
    const args = Array.prototype.slice.call(arguments)
    this[LOGGERS].forEach(logger => logger.error(args))
  }
}

module.exports = LogProvider
