"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const util_1 = require("util");
const node_vampire_http_1 = __importDefault(require("@ctrip/node-vampire-http"));
const node_vampire_util_1 = __importDefault(require("@ctrip/node-vampire-util"));
const node_vampire_cat_1 = __importDefault(require("@ctrip/node-vampire-cat"));
const node_vampire_appconfig_1 = __importDefault(require("@ctrip/node-vampire-appconfig"));
const node_vampire_clogging_1 = __importDefault(require("@ctrip/node-vampire-clogging"));
const checkFormat_1 = __importDefault(require("./checkFormat"));
const querystring_1 = require("querystring");
const node_vampire_metric_1 = __importDefault(require("@ctrip/node-vampire-metric"));
const qconfigFetchServer_1 = __importDefault(require("./qconfigFetchServer"));
const rc4_1 = require("./rc4");
let exceptionMetric = new node_vampire_metric_1.default({
    'name': 'qconfig.request.exception.count',
    'tags': {
        'configFile': 'configFile',
        'version': 'NV-' + require('../package.json').version,
        'errorCode': '',
        'node_qconfig': true
    }
});
exceptionMetric.start();
const CLOG_TITLE = 'qConfig_longPollCheckUpdate';
const CONTENT_ENCODING = 'qconfig-content-encoding';
const CONTENT_ENCODING_TYPE = 'RC4';
/*
* 请求qconfig服务端，支持DR
*/
class QconfigFetchConfigs {
    /**
     * 根据配置文件名获取最新的配置文件内容
     * @param {String} configName - 配置文件名
     * @param {boolean} isHttps - 是否https请求
     * @returns {ConfigData}
     * @throws {qconfigHTTPClient~ConfigNotFoundError}
     */
    loadTheLatestConfig(configName, isHttps, isKipWarning, serverIps) {
        if (!serverIps) {
            serverIps = isHttps ? node_vampire_util_1.default.copy(node_vampire_appconfig_1.default['qserver.https.urls']) : node_vampire_util_1.default.copy(node_vampire_appconfig_1.default['qserver.http.urls']) || [];
        }
        isHttps ? node_vampire_cat_1.default.event('qserver.https.urls', node_vampire_util_1.default.copy(node_vampire_appconfig_1.default['qserver.https.urls'])) : node_vampire_cat_1.default.event('qserver.http.urls', node_vampire_util_1.default.copy(node_vampire_appconfig_1.default['qserver.http.urls']));
        const serverIp = serverIps.shift();
        if (serverIp) {
            const _url = serverIp + '/client/forceloadv2';
            const config = checkFormat_1.default.checkFiles(configName);
            const qstring = (0, querystring_1.stringify)({
                group: config.appid,
                dataId: config.configName,
                version: '0',
                loadProfile: node_vampire_appconfig_1.default['qconfig.server.type'] + ':' + (node_vampire_appconfig_1.default['qconfig.subEnv'] || node_vampire_appconfig_1.default['qconfig.idc'])
            });
            node_vampire_cat_1.default.event('loadTheLatestConfig', qstring);
            return (0, node_vampire_http_1.default)(_url + '?' + qstring, {
                contentType: 'response',
                responseTimeout: node_vampire_appconfig_1.default['qConfig.RequestTimeout'] || 2000,
                headers: {
                    'qconfig-accept-encoding': CONTENT_ENCODING_TYPE,
                    token: node_vampire_appconfig_1.default['qconfig.server.token'],
                    profile: node_vampire_appconfig_1.default['qconfig.subEnv'] || node_vampire_appconfig_1.default['qconfig.idc'],
                    'client-herald-token': node_vampire_appconfig_1.default['heraldToken'],
                    c: 'node'
                },
                rejectUnauthorized: false
            }).then((res) => {
                const encoding = res.headers[CONTENT_ENCODING];
                let json = res.body.toString();
                if (res.statusCode && res.statusCode >= 200 && res.statusCode < 300) {
                    if (encoding && encoding.toLowerCase() === CONTENT_ENCODING_TYPE.toLowerCase()) {
                        return (0, rc4_1.decode)(json).then((datas) => {
                            json = datas;
                            return {
                                configName: configName,
                                configVersion: res.headers.version,
                                configContent: json,
                                configSource: res.headers.profile
                            };
                        }).catch((err) => {
                            throw err;
                        });
                    }
                    else {
                        return {
                            configName: configName,
                            configVersion: res.headers.version,
                            configContent: json,
                            configSource: res.headers.profile
                        };
                    }
                }
                else {
                    if (res.statusCode === 404) {
                        if (!isKipWarning) {
                            console.warn('\x1B[31m%s\x1B[0m', `warning:[node-vampire-qconfig] ${configName} doesn't exist,or file isn't public type.Please check it from http://qconfig.ctripcorp.com/webapp/page/index.html#/qconfig`);
                        }
                        // 如果客户端获取配置的时候，配置并没有发布，这个时候不抛出异常，还是继续长轮询服务端，这样配置发布后就可以立即获取到了
                        return {
                            configName: configName,
                            configVersion: -1,
                            configContent: null,
                            configSource: node_vampire_appconfig_1.default['qconfig.server.type'] + ':' + (node_vampire_appconfig_1.default['qconfig.subEnv'] || node_vampire_appconfig_1.default['qconfig.idc'])
                        };
                    }
                    exceptionMetric.add(1, {
                        'configFile': configName,
                        'errorCode': res.statusCode
                    });
                    throw new Error(`[node-vampire-qconfig] ${configName} invalid,statusCode:${res.statusCode},body:${json}`);
                }
            }).catch((err) => {
                if (err.code == 'ECONNREFUSED' || err.code == 'ECONNRESET' || err.code === 'ETIMEDOUT') {
                    return this.loadTheLatestConfig(configName, isHttps, isKipWarning, serverIps);
                }
                else {
                    throw err;
                }
            });
        }
        else {
            exceptionMetric.add(1, {
                'configFile': configName,
                'errorCode': 'None Available Server'
            });
            return Promise.reject('None Available Server, Servers:' + serverIps);
        }
    }
    /**
     * 记录配置文件
     * @param configLogTypeCode (1:pull success;2:pull error；3：parse remote error;4:use override;5:use remote file)
     * @param {object} configs 配置文件名，版本等
     */
    recordResult(datas, configLogTypeCode = 5, serverIps) {
        serverIps = serverIps ? serverIps : node_vampire_util_1.default.copy(node_vampire_appconfig_1.default['qserver.http.urls']) || [];
        const serverIp = serverIps.shift();
        if (serverIp) {
            const _url = serverIp + '/client/recordloadingv2';
            const config = checkFormat_1.default.checkFiles(datas.configName);
            return (0, node_vampire_http_1.default)(_url, {
                contentType: 'response',
                responseTimeout: 500,
                headers: {
                    'qconfig-accept-encoding': CONTENT_ENCODING_TYPE,
                    token: node_vampire_appconfig_1.default['qconfig.server.token'],
                    profile: node_vampire_appconfig_1.default['qconfig.subEnv'] || node_vampire_appconfig_1.default['qconfig.idc'],
                    c: 'node'
                }
            }, JSON.stringify({
                group: config.appid,
                dataId: config.configName,
                version: datas.configVersion,
                remarks: 'success',
                configLogTypeCode: configLogTypeCode
            })).then(() => {
                return;
            }).catch((err) => {
                if (err.code == 'ECONNREFUSED' || err.code == 'ECONNRESET' || err.code === 'ETIMEDOUT') {
                    return this.recordResult(datas, configLogTypeCode, serverIps);
                }
                else {
                    throw err;
                }
            });
        }
        else {
            return Promise.reject('None Available Server, Servers:' + serverIps);
        }
    }
    /**
     * 根据配置文件名长轮询获取更新配置
     * @param {object} configs 配置文件名，版本等
     * @returns {ConfigData}
     * @throws {qconfigHTTPClient~ConfigNotFoundError}
     */
    longPollCheckUpdate(configs, serverIps) {
        serverIps = serverIps ? serverIps : node_vampire_util_1.default.copy(node_vampire_appconfig_1.default['qserver.http.urls']) || [];
        node_vampire_cat_1.default.event('qserver.http.urls', node_vampire_util_1.default.copy(node_vampire_appconfig_1.default['qserver.http.urls']));
        const serverIp = serverIps.shift();
        // 同步java:在每次longPollCheckUpdate时异步拉一次ip 列表
        qconfigFetchServer_1.default.getInstance()._getServerList().catch((err) => {
            console.log(`[node-vampire-qconfig]-get Server Config Error：`, err);
        });
        if (serverIp) {
            const _url = serverIp + '/client/longPollingCheckupdatev2';
            const makeBody = function () {
                let requestData = '';
                for (const configName in configs) {
                    const config = checkFormat_1.default.checkFiles(configName);
                    requestData += (0, util_1.format)('%s,%s,%s,%s\n', config.appid, config.configName, configs[configName].configVersion, configs[configName].configSource);
                }
                node_vampire_cat_1.default.event('longPollCheckUpdate', requestData);
                return requestData;
            }.bind(this);
            return (0, node_vampire_http_1.default)(_url, {
                contentType: 'response',
                method: 'POST',
                responseTimeout: 60000,
                headers: {
                    'qconfig-accept-encoding': CONTENT_ENCODING_TYPE,
                    token: node_vampire_appconfig_1.default['qconfig.server.token'],
                    profile: node_vampire_appconfig_1.default['qconfig.subEnv'] || process.env.PAAS_APP_GROUPID || node_vampire_appconfig_1.default['qconfig.idc'] || '',
                    c: 'node'
                },
                unref: true
            }, makeBody()).then((res) => {
                if (res.statusCode === 304) { //未更新
                    return;
                }
                else if (res.statusCode && res.statusCode >= 200 && res.statusCode < 300) {
                    const updatedConfigs = [], rawUpdateInfo = res.body.toString();
                    const arr = rawUpdateInfo.split('\n');
                    let _Error = null;
                    arr.forEach((config) => {
                        if (!config) {
                            return;
                        }
                        const _configFile = config.split(',');
                        if (_configFile.length === 4) {
                            const configName = _configFile[0] + ':' + _configFile[1];
                            updatedConfigs.push({
                                configName: configName,
                                configVersion: _configFile[2],
                                configSource: _configFile[3]
                            });
                        }
                        else {
                            _Error = (0, util_1.format)('[node-vampire-qconfig] The response data(longPollCheckUpdate) is in a wrong format. The responseBody :%s', rawUpdateInfo);
                        }
                    });
                    if (!_Error) {
                        return updatedConfigs;
                    }
                    else {
                        node_vampire_clogging_1.default.custom({
                            type: 'warn',
                            title: CLOG_TITLE,
                            message: (0, util_1.format)('[node-vampire-qconfig] The response data(longPollCheckUpdate) is in a wrong format. The responseBody :%s', rawUpdateInfo),
                            addInfo: {}
                        });
                    }
                }
                else {
                    node_vampire_clogging_1.default.custom({
                        type: 'warn',
                        title: CLOG_TITLE,
                        message: (0, util_1.format)('[node-vampire-qconfig] The response statusCode(longPollingCheckupdatev2) is an exception. Response.statusCode :%s, response.body :%s, token :%s', res.statusCode, res.body.toString(), node_vampire_appconfig_1.default['qconfig.server.token']),
                        addInfo: {}
                    });
                }
            }).catch((err) => {
                if (err.code == 'ECONNREFUSED' || err.code == 'ECONNRESET' || err.code === 'ETIMEDOUT') {
                    return this.longPollCheckUpdate(configs, serverIps);
                }
                else {
                    throw err;
                }
            });
        }
        else {
            return Promise.reject('None Available Server, Servers:' + serverIps);
        }
    }
    /**
     * 获取具体某一版本配置文件的内容
     * @param {ConfigNameAndVersionAndSource} configData
     * @param {boolean} isHttps - 是否https请求
     * @returns {ConfigData}
     */
    getConfigByNameAndVersion(configs, isHttps, serverIps) {
        if (!serverIps) {
            serverIps = isHttps ? node_vampire_util_1.default.copy(node_vampire_appconfig_1.default['qserver.https.urls']) : node_vampire_util_1.default.copy(node_vampire_appconfig_1.default['qserver.http.urls']) || [];
        }
        const serverIp = serverIps.shift();
        if (serverIp) {
            const _url = serverIp + '/client/getconfigv2';
            const config = checkFormat_1.default.checkFiles(configs.configName);
            const _span = node_vampire_cat_1.default.span('getConfigByNameAndVersion', config.configName);
            const qstring = (0, querystring_1.stringify)({
                group: config.appid,
                dataId: config.configName,
                version: configs.configVersion,
                loadProfile: configs.configSource
            });
            return _span.run((done) => {
                node_vampire_cat_1.default.event('getConfigByNameAndVersion.url', _url);
                node_vampire_cat_1.default.event('getConfigByNameAndVersion', qstring);
                return (0, node_vampire_http_1.default)(_url + '?' + qstring, {
                    contentType: 'response',
                    responseTimeout: node_vampire_appconfig_1.default['qConfig.RequestTimeout'] || 2000,
                    headers: {
                        'qconfig-accept-encoding': CONTENT_ENCODING_TYPE,
                        token: node_vampire_appconfig_1.default['qconfig.server.token'],
                        'client-herald-token': node_vampire_appconfig_1.default['heraldToken'],
                        profile: node_vampire_appconfig_1.default['qconfig.subEnv'] || node_vampire_appconfig_1.default['qconfig.idc'],
                        c: 'node'
                    },
                    rejectUnauthorized: false,
                    unref: true
                }).then((res) => {
                    const encoding = res.headers[CONTENT_ENCODING];
                    let json = res.body.toString();
                    if (res.statusCode && res.statusCode >= 200 && res.statusCode < 300) {
                        if (encoding && encoding.toLowerCase() === CONTENT_ENCODING_TYPE.toLowerCase()) {
                            return (0, rc4_1.decode)(json).then((datas) => {
                                json = datas;
                                done();
                                return {
                                    configName: configs.configName,
                                    configVersion: configs.configVersion,
                                    configContent: json,
                                    configSource: configs.configSource
                                };
                            }).catch((err) => {
                                throw err;
                            });
                        }
                        else {
                            done();
                            return {
                                configName: configs.configName,
                                configVersion: configs.configVersion,
                                configContent: json,
                                configSource: configs.configSource
                            };
                        }
                    }
                    else {
                        done();
                        return Promise.reject(new Error((0, util_1.format)('[node-vampire-qconfig] The response data(getconfigv2) is in a wrong format. The responseBody :%s', json)));
                    }
                }).catch((err) => {
                    done();
                    if (err.code == 'ECONNREFUSED' || err.code == 'ECONNRESET' || err.code === 'ETIMEDOUT') {
                        return this.getConfigByNameAndVersion(configs, isHttps, serverIps);
                    }
                    else {
                        throw err;
                    }
                });
            });
        }
        else {
            return Promise.reject('None Available Server, Servers:' + serverIps);
        }
    }
}
exports.default = new QconfigFetchConfigs();
