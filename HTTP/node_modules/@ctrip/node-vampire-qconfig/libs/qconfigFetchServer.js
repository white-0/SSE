"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = __importDefault(require("fs"));
const write_file_atomic_1 = __importDefault(require("write-file-atomic"));
const path_1 = __importDefault(require("path"));
const node_vampire_http_1 = __importDefault(require("@ctrip/node-vampire-http"));
const node_vampire_foundation_framework_1 = __importDefault(require("@ctrip/node-vampire-foundation-framework"));
const node_vampire_util_1 = __importDefault(require("@ctrip/node-vampire-util"));
const node_vampire_appconfig_1 = __importDefault(require("@ctrip/node-vampire-appconfig"));
const node_vampire_cat_1 = __importDefault(require("@ctrip/node-vampire-cat"));
const IDC_ARR = ['cftrb', 'cftxy', 'fra-aws', 'sha-ali', 'sharb', 'shaxy', 'sin-aws'];
const insVar = process.env.instance_var || 'NODE_APP_INSTANCE';
let _qConfigFetchServer = null;
class QConfigFetchServer {
    constructor() {
        this.serverConfig = {};
        this._qconfigInit();
    }
    static getInstance() {
        if (!_qConfigFetchServer) {
            _qConfigFetchServer = new QConfigFetchServer();
        }
        return _qConfigFetchServer;
    }
    _qconfigInit() {
        this.qconfigInitFinish = require('../appConfig')
            .then((ret) => this.appConfig = ret)
            .then(() => node_vampire_foundation_framework_1.default.getServerProperties("*"))
            .then((serverProperties) => this._getServerToken(serverProperties))
            .then(() => this._getServerHost())
            .then(() => this._getServerList())
            .then(() => this._getEntrypointInterval())
            .catch((err) => {
            console.log(`[node-vampire-qconfig]-get Server Config Error：`, err);
            if (!this._Interval) {
                this._getEntrypointInterval();
            }
            //2024/1/5,不再抛出异常；如果强制点火的配置会在获取文件失败时抛出
            if (!node_vampire_appconfig_1.default['qconfig.server.token']) {
                this._getTokenInterval();
            }
            return this._getServerIpListByConf().catch((err) => {
                console.log('[@ctrip/node-vampire-qconfig] getServerIpListByConf error:', err);
            });
        });
    }
    // 相关文档：http://conf.ctripcorp.com/pages/viewpage.action?pageId=153243655
    _getServerToken(serverProperties) {
        this._serverProperties = serverProperties;
        const _path = path_1.default.resolve('/opt/data/' + this.appConfig.appId);
        const url = this.appConfig.qConfigAppCenterUrl + 'api/ctrip/app/register.json';
        return (0, node_vampire_http_1.default)(url, {
            contentType: 'json',
        }, JSON.stringify({
            'appId': this.appConfig.appId,
            'server.pid': process.pid,
            'server.type': this.appConfig.env,
            'server.subEnv': this.appConfig.subEnv || this.appConfig.idc,
            'server.room': this.appConfig.idc,
            'server.ip': node_vampire_util_1.default.getHostIp(),
            'server.hostname': node_vampire_util_1.default.getHostName(),
            'server.rawProperties': serverProperties
        })).then((json) => {
            if (json && json.status == 0) {
                node_vampire_appconfig_1.default['qconfig.server.token'] = json.data['server.token'];
                node_vampire_appconfig_1.default['qconfig.server.type'] = json.data['server.type'];
                let isMaster = parseInt(process.env[insVar], 10) || 0;
                node_vampire_cat_1.default.event('qconfig.token', node_vampire_appconfig_1.default['qconfig.server.token']);
                if (isMaster === 0) {
                    const ret = JSON.stringify({
                        'qconfig.server.token': json.data['server.token'],
                        'qconfig.server.type': json.data['server.type']
                    });
                    this._writeFile(_path, ret);
                }
            }
            else {
                throw new Error(json && json.message || 'Invalid QConfig Server Token Format');
            }
            return;
        }).catch((err) => {
            node_vampire_cat_1.default.event('register.err', err);
            return new Promise((resolve, reject) => {
                const qconfigToken = _path + '/qconfigToken.json';
                if (fs_1.default.existsSync(qconfigToken) === false) { // 文件不存在时, 不用走保底逻辑, 直接以 之前的 err 进行 reject
                    return reject(err);
                }
                fs_1.default.readFile(qconfigToken, (err, datas) => {
                    if (err) {
                        reject(err);
                    }
                    else {
                        const result = JSON.parse(datas.toString());
                        node_vampire_appconfig_1.default['qconfig.server.token'] = result['qconfig.server.token'];
                        node_vampire_appconfig_1.default['qconfig.server.type'] = result['qconfig.server.type'];
                        resolve();
                    }
                });
            });
        });
    }
    _getServerHost() {
        const url = this.appConfig.qConfigAppCenterUrl + 'api/globalEnv.json';
        return (0, node_vampire_http_1.default)(url, {
            contentType: 'json',
            headers: {
                'Q-Server-Token': node_vampire_appconfig_1.default['qconfig.server.token']
            }
        }).then((json) => {
            if (json && json.status == 0) {
                this.serverConfig.host = json.data['qconfig.server.host'];
                this.defaultServerList = json.data['qconfig.default.serverlist'];
                this.defaultServerHttpsList = json.data['qconfig.default.httpsserverlist'];
                node_vampire_cat_1.default.event('qconfig.getServerHost.defaultServerList', this.defaultServerList);
                if (this.serverConfig.host.endsWith('/')) {
                    this.serverConfig.host = this.serverConfig.host.slice(0, -1);
                }
            }
            else {
                return Promise.reject(new Error(json && json.message || 'Invalid QConfig Server Host Format'));
            }
            return;
        }).catch((err) => {
            throw err;
        });
    }
    _getEntrypointInterval() {
        this._Interval = setInterval(() => {
            this._getServerList().catch((err) => console.log(`[node-vampire-qconfig]-get Server Config Error：`, err));
        }, 120000).unref(); // 每隔2分钟拉取最新的 serverIP
    }
    _getTokenInterval() {
        this._TokenInterval = setInterval(() => {
            this._getServerToken(this._serverProperties).then(() => clearInterval(this._TokenInterval)).catch((err) => console.log(`[node-vampire-qconfig]-get Server Token Error：`, err));
        }, 120000).unref(); // 每隔2分钟拉取最新的 serverIP
    }
    _getServerList() {
        const url = 'http://' + this.serverConfig.host + '/entrypointv2';
        node_vampire_cat_1.default.event('qconfig.getServerList', url);
        return (0, node_vampire_http_1.default)(url, {
            contentType: 'response',
            headers: {
                token: node_vampire_appconfig_1.default['qconfig.server.token']
            }
        }).then((res) => {
            let text = res.body.toString();
            if (res.statusCode && res.statusCode >= 200 && res.statusCode < 300) {
                let ipList = text.trim().split(/\r?\n/g);
                if (ipList.length < 2) {
                    return Promise.reject(new Error('no qconfig server address find entrypoint2'));
                }
                if (ipList[0])
                    node_vampire_appconfig_1.default['qserver.http.urls'] = ipList[0].split(',').map((server) => 'http://' + server);
                if (ipList[1])
                    node_vampire_appconfig_1.default['qserver.https.urls'] = ipList[1].split(',').map((server) => 'https://' + server);
            }
            else {
                throw new Error('getServerList statusCode is: ' + res.statusCode);
            }
            return;
        }).catch((err) => {
            if (this.defaultServerList && this.defaultServerHttpsList) {
                node_vampire_appconfig_1.default['qserver.http.urls'] = this.defaultServerList.split(',').map((server) => 'http://' + server);
                node_vampire_appconfig_1.default['qserver.https.urls'] = this.defaultServerHttpsList.split(',').map((server) => 'https://' + server);
            }
            else {
                throw err;
            }
        });
    }
    _getServerIpListByConf() {
        let fileName = 'ctrip-default-';
        const _env = (this.appConfig.env || '').toLowerCase();
        const _idc = this.appConfig.idc ? this.appConfig.idc.toLowerCase() : '';
        if (_env.indexOf('pro') != -1) {
            fileName += 'pro' + (IDC_ARR.includes(_idc) ? '-' + _idc : '');
        }
        else {
            fileName += _env === 'uat' ? _env : 'fat';
        }
        const _path = path_1.default.resolve(__dirname, '../conf/' + fileName + '.conf');
        return new Promise((resolve) => {
            fs_1.default.readFile(_path, (err, _file) => {
                if (!err) {
                    const ret = _file.toString();
                    let lineList = ret.split(/(\n|\r\n)/);
                    let result = {};
                    for (let item of lineList) {
                        item = item.trim();
                        let index = item.indexOf('=');
                        if (index <= 0)
                            continue;
                        let key = item.substring(0, index);
                        let value = item.substring(index + 1);
                        result[key] = value;
                    }
                    if (!this.serverConfig.host) {
                        this.serverConfig.host = result['qconfig.server.host'];
                    }
                    node_vampire_appconfig_1.default['qserver.http.urls'] = result['qconfig.default.serverlist'].split(',').map((server) => 'http://' + server);
                    node_vampire_appconfig_1.default['qserver.https.urls'] = result['qconfig.default.httpsserverlist'].split(',').map((server) => 'https://' + server);
                }
                resolve();
            });
        });
    }
    _writeFile(_path, data) {
        const writeFile = (_data) => {
            (0, write_file_atomic_1.default)(_path + '/qconfigToken.json', _data, (err) => {
                if (node_vampire_appconfig_1.default.debug) {
                    console.log('[@ctrip/node-vampire-qconfig] save token:' + !err);
                }
            });
        };
        this._makeDir(_path, (err) => {
            if (!err) {
                writeFile(data);
            }
        });
    }
    _makeDir(dir, callback) {
        fs_1.default.stat(dir, (err, stats) => {
            if (stats && stats.isDirectory()) {
                callback();
            }
            else {
                this._makeDir(path_1.default.dirname(dir), () => {
                    fs_1.default.mkdir(dir, callback);
                });
            }
        });
    }
}
exports.default = QConfigFetchServer;
