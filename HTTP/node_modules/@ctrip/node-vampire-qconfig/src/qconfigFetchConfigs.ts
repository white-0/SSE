import { format } from 'util';
import request from '@ctrip/node-vampire-http';
import util from '@ctrip/node-vampire-util';
import cat from '@ctrip/node-vampire-cat';
import appConfig from '@ctrip/node-vampire-appconfig';
import clogging from '@ctrip/node-vampire-clogging';
import checkFormat from './checkFormat';
import { stringify } from 'querystring';
import MetricMonitor from '@ctrip/node-vampire-metric';
import qconfigFetchServer from './qconfigFetchServer';
import { decode } from './rc4';
let exceptionMetric = new MetricMonitor({
    'name': 'qconfig.request.exception.count',
    'tags': {
        'configFile': 'configFile',
        'version': 'NV-' + require('../package.json').version,
        'errorCode': '',
        'node_qconfig': true
    }
});
exceptionMetric.start();
interface Configs {
    configName: string,
    configVersion: string,
    configContent: string,
    configSource?: string
}

const CLOG_TITLE = 'qConfig_longPollCheckUpdate';
const CONTENT_ENCODING = 'qconfig-content-encoding';
const CONTENT_ENCODING_TYPE = 'RC4';

/*
* 请求qconfig服务端，支持DR
*/
class QconfigFetchConfigs {
    /**
     * 根据配置文件名获取最新的配置文件内容
     * @param {String} configName - 配置文件名
     * @param {boolean} isHttps - 是否https请求
     * @returns {ConfigData}
     * @throws {qconfigHTTPClient~ConfigNotFoundError}
     */
    loadTheLatestConfig(configName: string, isHttps?: boolean, isKipWarning?: boolean, serverIps?: []): Promise<Configs> {
        if (!serverIps) {
            serverIps = isHttps ? util.copy(appConfig['qserver.https.urls']) : util.copy(appConfig['qserver.http.urls']) || [];
        }
        isHttps ? cat.event('qserver.https.urls', util.copy(appConfig['qserver.https.urls'])) : cat.event('qserver.http.urls', util.copy(appConfig['qserver.http.urls']));
        const serverIp = serverIps.shift();
        if (serverIp) {
            const _url = serverIp + '/client/forceloadv2';
            const config = checkFormat.checkFiles(configName);
            const qstring = stringify({
                group: config.appid,
                dataId: config.configName,
                version: '0',
                loadProfile: appConfig['qconfig.server.type'] + ':' + (appConfig['qconfig.subEnv'] || appConfig['qconfig.idc'])
            });
            cat.event('loadTheLatestConfig', qstring);
            return request(_url + '?' + qstring, {
                contentType: 'response',
                responseTimeout: appConfig['qConfig.RequestTimeout'] || 2000,
                headers: {
                    'qconfig-accept-encoding': CONTENT_ENCODING_TYPE,
                    token: appConfig['qconfig.server.token'],
                    profile: appConfig['qconfig.subEnv'] || appConfig['qconfig.idc'],
                    'client-herald-token': appConfig['heraldToken'],
                    c: 'node'
                },
                rejectUnauthorized: false
            }).then((res) => {
                const encoding = res.headers[CONTENT_ENCODING];
                let json = res.body.toString();
                if (res.statusCode && res.statusCode >= 200 && res.statusCode < 300) {
                    if (encoding && encoding.toLowerCase() === CONTENT_ENCODING_TYPE.toLowerCase()) {
                        return decode(json).then((datas) => {
                            json = datas;
                            return {
                                configName: configName,
                                configVersion: res.headers.version,
                                configContent: json,
                                configSource: res.headers.profile
                            };
                        }).catch((err) => {
                            throw err;
                        });
                    } else {
                        return {
                            configName: configName,
                            configVersion: res.headers.version,
                            configContent: json,
                            configSource: res.headers.profile
                        };
                    }
                } else {
                    if (res.statusCode === 404) {
                        if (!isKipWarning) {
                            console.warn('\x1B[31m%s\x1B[0m', `warning:[node-vampire-qconfig] ${configName} doesn't exist,or file isn't public type.Please check it from http://qconfig.ctripcorp.com/webapp/page/index.html#/qconfig`);
                        }
                        // 如果客户端获取配置的时候，配置并没有发布，这个时候不抛出异常，还是继续长轮询服务端，这样配置发布后就可以立即获取到了
                        return {
                            configName: configName,
                            configVersion: -1,
                            configContent: null,
                            configSource: appConfig['qconfig.server.type'] + ':' + (appConfig['qconfig.subEnv'] || appConfig['qconfig.idc'])
                        };
                    }
                    exceptionMetric.add(1, {
                        'configFile': configName,
                        'errorCode': res.statusCode
                    })
                    throw new Error(`[node-vampire-qconfig] ${configName} invalid,statusCode:${res.statusCode},body:${json}`);
                }
            }).catch((err) => {
                if (err.code == 'ECONNREFUSED' || err.code == 'ECONNRESET' || err.code === 'ETIMEDOUT') {
                    return this.loadTheLatestConfig(configName, isHttps, isKipWarning, serverIps);
                } else {
                    throw err;
                }
            });
        } else {
            exceptionMetric.add(1, {
                'configFile': configName,
                'errorCode': 'None Available Server'
            });
            return Promise.reject('None Available Server, Servers:' + serverIps);
        }
    }

    /**
     * 记录配置文件
     * @param configLogTypeCode (1:pull success;2:pull error；3：parse remote error;4:use override;5:use remote file)
     * @param {object} configs 配置文件名，版本等
     */
    recordResult(datas: Configs, configLogTypeCode: number = 5, serverIps?: []): Promise<void> {
        serverIps = serverIps ? serverIps : util.copy(appConfig['qserver.http.urls']) || [];
        const serverIp = serverIps.shift();
        if (serverIp) {
            const _url = serverIp + '/client/recordloadingv2';
            const config = checkFormat.checkFiles(datas.configName);
            return request(_url, {
                contentType: 'response',
                responseTimeout: 500,
                headers: {
                    'qconfig-accept-encoding': CONTENT_ENCODING_TYPE,
                    token: appConfig['qconfig.server.token'],
                    profile: appConfig['qconfig.subEnv'] || appConfig['qconfig.idc'],
                    c: 'node'
                }
            }, JSON.stringify({
                group: config.appid,
                dataId: config.configName,
                version: datas.configVersion,
                remarks: 'success',
                configLogTypeCode: configLogTypeCode
            })).then(() => {
                return;
            }).catch((err) => {
                if (err.code == 'ECONNREFUSED' || err.code == 'ECONNRESET' || err.code === 'ETIMEDOUT') {
                    return this.recordResult(datas, configLogTypeCode, serverIps);
                } else {
                    throw err;
                }
            })
        } else {
            return Promise.reject('None Available Server, Servers:' + serverIps);
        }
    }

    /**
     * 根据配置文件名长轮询获取更新配置
     * @param {object} configs 配置文件名，版本等
     * @returns {ConfigData}
     * @throws {qconfigHTTPClient~ConfigNotFoundError}
     */
    longPollCheckUpdate(configs: object, serverIps?: []): Promise<object> {
        serverIps = serverIps ? serverIps : util.copy(appConfig['qserver.http.urls']) || [];
        cat.event('qserver.http.urls', util.copy(appConfig['qserver.http.urls']));
        const serverIp = serverIps.shift();
        // 同步java:在每次longPollCheckUpdate时异步拉一次ip 列表
        qconfigFetchServer.getInstance()._getServerList().catch((err) => {
            console.log(`[node-vampire-qconfig]-get Server Config Error：`, err);
        });
        if (serverIp) {
            const _url = serverIp + '/client/longPollingCheckupdatev2';
            const makeBody = function () {
                let requestData: string = '';
                for (const configName in configs) {
                    const config = checkFormat.checkFiles(configName);
                    requestData += format('%s,%s,%s,%s\n', config.appid, config.configName, configs[configName].configVersion, configs[configName].configSource);
                }
                cat.event('longPollCheckUpdate', requestData);
                return requestData;
            }.bind(this);
            return request(_url, {
                contentType: 'response',
                method: 'POST',
                responseTimeout: 60000,
                headers: {
                    'qconfig-accept-encoding': CONTENT_ENCODING_TYPE,
                    token: appConfig['qconfig.server.token'],
                    profile: appConfig['qconfig.subEnv'] || process.env.PAAS_APP_GROUPID || appConfig['qconfig.idc'] || '',
                    c: 'node'
                },
                unref: true
            }, makeBody()).then((res) => {
                if (res.statusCode === 304) { //未更新
                    return;
                } else if (res.statusCode && res.statusCode >= 200 && res.statusCode < 300) {
                    const updatedConfigs: Array<object> = [], rawUpdateInfo: string = res.body.toString();
                    const arr = rawUpdateInfo.split('\n');
                    let _Error = null;
                    arr.forEach((config) => {
                        if (!config) {
                            return;
                        }
                        const _configFile: Array<String> = config.split(',');

                        if (_configFile.length === 4) {
                            const configName = _configFile[0] + ':' + _configFile[1];
                            updatedConfigs.push({
                                configName: configName,
                                configVersion: _configFile[2],
                                configSource: _configFile[3]
                            });
                        } else {
                            _Error = format('[node-vampire-qconfig] The response data(longPollCheckUpdate) is in a wrong format. The responseBody :%s', rawUpdateInfo);
                        }
                    });
                    if (!_Error) {
                        return updatedConfigs;
                    } else {
                        clogging.custom({
                            type: 'warn',
                            title: CLOG_TITLE,
                            message: format('[node-vampire-qconfig] The response data(longPollCheckUpdate) is in a wrong format. The responseBody :%s', rawUpdateInfo),
                            addInfo: {}
                        })
                    }
                } else {
                    clogging.custom({
                        type: 'warn',
                        title: CLOG_TITLE,
                        message: format('[node-vampire-qconfig] The response statusCode(longPollingCheckupdatev2) is an exception. Response.statusCode :%s, response.body :%s, token :%s', res.statusCode, res.body.toString(), appConfig['qconfig.server.token']),
                        addInfo: {}
                    })
                }
            }).catch((err) => {
                if (err.code == 'ECONNREFUSED' || err.code == 'ECONNRESET' || err.code === 'ETIMEDOUT') {
                    return this.longPollCheckUpdate(configs, serverIps);
                } else {
                    throw err;
                }
            })
        } else {
            return Promise.reject('None Available Server, Servers:' + serverIps);
        }
    }

    /**
     * 获取具体某一版本配置文件的内容
     * @param {ConfigNameAndVersionAndSource} configData
     * @param {boolean} isHttps - 是否https请求
     * @returns {ConfigData}
     */
    getConfigByNameAndVersion(configs: Configs, isHttps: boolean, serverIps?: []): Promise<Configs> {
        if (!serverIps) {
            serverIps = isHttps ? util.copy(appConfig['qserver.https.urls']) : util.copy(appConfig['qserver.http.urls']) || [];
        }
        const serverIp = serverIps.shift();
        if (serverIp) {
            const _url = serverIp + '/client/getconfigv2';
            const config = checkFormat.checkFiles(configs.configName);
            const _span = cat.span('getConfigByNameAndVersion', config.configName);
            const qstring = stringify({
                group: config.appid,
                dataId: config.configName,
                version: configs.configVersion,
                loadProfile: configs.configSource
            });
            return _span.run((done) => {
                cat.event('getConfigByNameAndVersion.url', _url);
                cat.event('getConfigByNameAndVersion', qstring);
                return request(_url + '?' + qstring, {
                    contentType: 'response',
                    responseTimeout: appConfig['qConfig.RequestTimeout'] || 2000,
                    headers: {
                        'qconfig-accept-encoding': CONTENT_ENCODING_TYPE,
                        token: appConfig['qconfig.server.token'],
                        'client-herald-token': appConfig['heraldToken'],
                        profile: appConfig['qconfig.subEnv'] || appConfig['qconfig.idc'],
                        c: 'node'
                    },
                    rejectUnauthorized: false,
                    unref: true
                }).then((res) => {
                    const encoding = res.headers[CONTENT_ENCODING];
                    let json = res.body.toString();
                    if (res.statusCode && res.statusCode >= 200 && res.statusCode < 300) {
                        if (encoding && encoding.toLowerCase() === CONTENT_ENCODING_TYPE.toLowerCase()) {
                            return decode(json).then((datas) => {
                                json = datas;
                                done();
                                return {
                                    configName: configs.configName,
                                    configVersion: configs.configVersion,
                                    configContent: json,
                                    configSource: configs.configSource
                                };
                            }).catch((err) => {
                                throw err;
                            });
                        } else {
                            done();
                            return {
                                configName: configs.configName,
                                configVersion: configs.configVersion,
                                configContent: json,
                                configSource: configs.configSource
                            };
                        }
                    } else {
                        done();
                        return Promise.reject(new Error(format('[node-vampire-qconfig] The response data(getconfigv2) is in a wrong format. The responseBody :%s', json)));
                    }
                }).catch((err) => {
                    done();
                    if (err.code == 'ECONNREFUSED' || err.code == 'ECONNRESET' || err.code === 'ETIMEDOUT') {
                        return this.getConfigByNameAndVersion(configs, isHttps, serverIps);
                    } else {
                        throw err;
                    }
                });
            });
        } else {
            return Promise.reject('None Available Server, Servers:' + serverIps);
        }
    }
}

export default new QconfigFetchConfigs();
