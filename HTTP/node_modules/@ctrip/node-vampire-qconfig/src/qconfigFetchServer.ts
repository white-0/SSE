import fs from 'fs';
import fsAtomic from 'write-file-atomic';
import path from 'path';
import request from '@ctrip/node-vampire-http';
import foundationFramework from '@ctrip/node-vampire-foundation-framework';
import util from '@ctrip/node-vampire-util';
import appConfig from '@ctrip/node-vampire-appconfig';
import cat from '@ctrip/node-vampire-cat';
const IDC_ARR = ['cftrb', 'cftxy', 'fra-aws', 'sha-ali', 'sharb', 'shaxy', 'sin-aws'];
const insVar = process.env.instance_var || 'NODE_APP_INSTANCE';
let _qConfigFetchServer = null;
interface ServerConfigInterface {
    token?: string,
    type?: string,
    host?: string,
    servers?: string
}

class QConfigFetchServer {
    private appConfig: {
        appId: string,
        env: string,
        idc: string,
        qConfigAppCenterUrl?: string,
        subEnv?: string,
    };
    public serverConfig = {} as ServerConfigInterface;
    public defaultServerList: string;
    public defaultServerHttpsList: string;
    public qconfigInitFinish: Promise<void>;
    public _Interval: any;
    private _TokenInterval: any;
    private _serverProperties: any;

    constructor() {
        this._qconfigInit()
    }
    static getInstance() {
        if (!_qConfigFetchServer) {
            _qConfigFetchServer = new QConfigFetchServer();
        }
        return _qConfigFetchServer;
    }
    _qconfigInit(): void {
        this.qconfigInitFinish = require('../appConfig')
            .then((ret) => this.appConfig = ret)
            .then(() => foundationFramework.getServerProperties("*"))
            .then((serverProperties) => this._getServerToken(serverProperties))
            .then(() => this._getServerHost())
            .then(() => this._getServerList())
            .then(() => this._getEntrypointInterval())
            .catch((err) => {
                console.log(`[node-vampire-qconfig]-get Server Config Error：`, err);
                if (!this._Interval) {
                    this._getEntrypointInterval();
                }
                //2024/1/5,不再抛出异常；如果强制点火的配置会在获取文件失败时抛出
                if (!appConfig['qconfig.server.token']) {
                    this._getTokenInterval();
                }
                return this._getServerIpListByConf().catch((err) => {
                    console.log('[@ctrip/node-vampire-qconfig] getServerIpListByConf error:', err);
                });
            });
    }

    // 相关文档：http://conf.ctripcorp.com/pages/viewpage.action?pageId=153243655
    _getServerToken(serverProperties: any): Promise<void> {
        this._serverProperties = serverProperties;
        const _path = path.resolve('/opt/data/' + this.appConfig.appId);
        const url = this.appConfig.qConfigAppCenterUrl + 'api/ctrip/app/register.json';
        return request(url, {
            contentType: 'json',
        }, JSON.stringify({
            'appId': this.appConfig.appId,
            'server.pid': process.pid,
            'server.type': this.appConfig.env,
            'server.subEnv': this.appConfig.subEnv || this.appConfig.idc,
            'server.room': this.appConfig.idc,
            'server.ip': util.getHostIp(),
            'server.hostname': util.getHostName(),
            'server.rawProperties': serverProperties
        })).then((json) => {
            if (json && json.status == 0) {
                appConfig['qconfig.server.token'] = json.data['server.token'];
                appConfig['qconfig.server.type'] = json.data['server.type'];
                let isMaster = parseInt(process.env[insVar], 10) || 0;
                cat.event('qconfig.token', appConfig['qconfig.server.token']);
                if (isMaster === 0) {
                    const ret = JSON.stringify({
                        'qconfig.server.token': json.data['server.token'],
                        'qconfig.server.type': json.data['server.type']
                    })
                    this._writeFile(_path, ret);
                }
            } else {
                throw new Error(json && json.message || 'Invalid QConfig Server Token Format');
            }
            return;
        }).catch((err) => {
            cat.event('register.err', err);
            return new Promise((resolve, reject) => {
                const qconfigToken = _path + '/qconfigToken.json';
                if (fs.existsSync(qconfigToken) === false) { // 文件不存在时, 不用走保底逻辑, 直接以 之前的 err 进行 reject
                    return reject(err);
                }
                fs.readFile(qconfigToken, (err, datas) => {
                    if (err) {
                        reject(err);
                    } else {
                        const result = JSON.parse(datas.toString());
                        appConfig['qconfig.server.token'] = result['qconfig.server.token'];
                        appConfig['qconfig.server.type'] = result['qconfig.server.type'];
                        resolve();
                    }
                });
            });
        });
    }

    _getServerHost() {
        const url = this.appConfig.qConfigAppCenterUrl + 'api/globalEnv.json';
        return request(url, {
            contentType: 'json',
            headers: {
                'Q-Server-Token': appConfig['qconfig.server.token']
            }
        }).then((json) => {
            if (json && json.status == 0) {
                this.serverConfig.host = json.data['qconfig.server.host'];
                this.defaultServerList = json.data['qconfig.default.serverlist'];
                this.defaultServerHttpsList = json.data['qconfig.default.httpsserverlist'];
                cat.event('qconfig.getServerHost.defaultServerList', this.defaultServerList);
                if (this.serverConfig.host.endsWith('/')) {
                    this.serverConfig.host = this.serverConfig.host.slice(0, -1);
                }
            } else {
                return Promise.reject(new Error(json && json.message || 'Invalid QConfig Server Host Format'));
            }
            return;
        }).catch((err) => {
            throw err;
        });
    }

    _getEntrypointInterval(): void {
        this._Interval = setInterval(() => {
            this._getServerList().catch((err) => console.log(`[node-vampire-qconfig]-get Server Config Error：`, err));
        }, 120000).unref();  // 每隔2分钟拉取最新的 serverIP
    }

    private _getTokenInterval(): void {
        this._TokenInterval = setInterval(() => {
            this._getServerToken(this._serverProperties).then(() => clearInterval(this._TokenInterval)).catch((err) => console.log(`[node-vampire-qconfig]-get Server Token Error：`, err));
        }, 120000).unref();  // 每隔2分钟拉取最新的 serverIP
    }

    _getServerList(): Promise<any> {
        const url = 'http://' + this.serverConfig.host + '/entrypointv2';
        cat.event('qconfig.getServerList', url);
        return request(url, {
            contentType: 'response',
            headers: {
                token: appConfig['qconfig.server.token']
            }
        }).then((res) => {
            let text = res.body.toString();
            if (res.statusCode && res.statusCode >= 200 && res.statusCode < 300) {
                let ipList = text.trim().split(/\r?\n/g);
                if (ipList.length < 2) {
                    return Promise.reject(new Error('no qconfig server address find entrypoint2'));
                }

                if (ipList[0]) appConfig['qserver.http.urls'] = ipList[0].split(',').map((server) => 'http://' + server);
                if (ipList[1]) appConfig['qserver.https.urls'] = ipList[1].split(',').map((server) => 'https://' + server);
            } else {
                throw new Error('getServerList statusCode is: ' + res.statusCode);
            }
            return;
        }).catch((err) => {
            if (this.defaultServerList && this.defaultServerHttpsList) {
                appConfig['qserver.http.urls'] = this.defaultServerList.split(',').map((server) => 'http://' + server);
                appConfig['qserver.https.urls'] = this.defaultServerHttpsList.split(',').map((server) => 'https://' + server);
            } else {
                throw err;
            }
        })
    }

    _getServerIpListByConf(): Promise<void> {
        let fileName = 'ctrip-default-';
        const _env = (this.appConfig.env || '').toLowerCase();
        const _idc = this.appConfig.idc ? this.appConfig.idc.toLowerCase() : '';
        if (_env.indexOf('pro') != -1) {
            fileName += 'pro' + (IDC_ARR.includes(_idc) ? '-' + _idc : '');
        } else {
            fileName += _env === 'uat' ? _env : 'fat';
        }
        const _path = path.resolve(__dirname, '../conf/' + fileName + '.conf');
        return new Promise((resolve) => {
            fs.readFile(_path, (err, _file) => {
                if (!err) {
                    const ret = _file.toString();
                    let lineList = ret.split(/(\n|\r\n)/);
                    let result = {};
                    for (let item of lineList) {
                        item = item.trim();
                        let index = item.indexOf('=');
                        if (index <= 0) continue;
                        let key = item.substring(0, index);
                        let value = item.substring(index + 1);
                        result[key] = value;
                    }
                    if (!this.serverConfig.host) {
                        this.serverConfig.host = result['qconfig.server.host'];
                    }
                    appConfig['qserver.http.urls'] = result['qconfig.default.serverlist'].split(',').map((server) => 'http://' + server);
                    appConfig['qserver.https.urls'] = result['qconfig.default.httpsserverlist'].split(',').map((server) => 'https://' + server);
                }
                resolve();
            });
        });
    }

    _writeFile(_path, data): void {
        const writeFile = (_data) => {
            fsAtomic(_path + '/qconfigToken.json', _data, (err) => {
                if (appConfig.debug) {
                    console.log('[@ctrip/node-vampire-qconfig] save token:' + !err)
                }
            });
        }
        this._makeDir(_path, (err) => {
            if (!err) {
                writeFile(data);
            }
        });
    }

    _makeDir(dir, callback): void {
        fs.stat(dir, (err, stats) => {
            if (stats && stats.isDirectory()) {
                callback();
            } else {
                this._makeDir(path.dirname(dir), () => {
                    fs.mkdir(dir, callback)
                });
            }
        })
    }
}

export default QConfigFetchServer;
