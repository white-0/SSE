import { simpleLogger, CtripIgnitePlugin } from '@ctrip/node-vampire-vi-ignite';
import cat from '@ctrip/node-vampire-cat';
import qconfigFetchServer from './qconfigFetchServer';
import checkFormat from './checkFormat';
import qconfigFetchConfigs from './qconfigFetchConfigs';
import qconfigObject from './qconfigObject';
import cache from '@ctrip/node-vampire-cache';
import appConfig from '@ctrip/node-vampire-appconfig';
import MetricMonitor from './metricMonitor';
import Locker from '@ctrip/node-vampire-locker';
import clogging from '@ctrip/node-vampire-clogging';
import util from '@ctrip/node-vampire-util';
const _cache = cache.Cache;

const cacheName = 'node-vampire-qconfig-' + appConfig['AppID'];
const lockerName = 'qconfigFile-' + appConfig['AppID'];
// 目前服务端限制：文件大小不超过 512k
const store = new _cache(cacheName, 10 * 1024 * 1024, cache.SIZE_1K);
const storeHttps = new _cache(cacheName + '-https', 1024 * 1024, cache.SIZE_1K);
const locker = new Locker(lockerName);
interface Configs {
    configName: string,
    configVersion: string | number,
    configContent: string,
    configSource?: string
}
interface options { fileName: string, defaultConfig?: string, isHttps?: boolean, skipParsing?: boolean, isKipWarning?: boolean, isIgnite?: boolean }

class QConfig {
    private _configStore: object = {};
    private startSubscribe: boolean = false;
    private _qconfigFetchServer = null;
    private _qconfigMetric = null;
    private _fetchFiles = {};

    // 2021/6/22 支持在应用启动阶段初始化
    init() {
        const qconfigFiles = appConfig['qconfig'];
        if (util.type(qconfigFiles) != 'array' || qconfigFiles.length == 0) {
            return Promise.resolve();
        }
        const _promise = [];
        for (const item of qconfigFiles) {
            const _qconfig = this.getConfig({ fileName: item, isKipWarning: true, isIgnite: true });
            if (!_qconfig) {
                throw new Error(`[@ctrip/node-vampire-qconfig] ${item} initialization failed`);
            }
            _promise.push(_qconfig.get().then(() => {
                return;
            }).catch((err) => {
                throw err;
            }));
        }
        return Promise.all(_promise).then(() => {
            console.log('[@ctrip/node-vampire-qconfig] qconfig init success');
            return;
        }).catch((err) => {
            throw err;
        })
    }
    /*
    * 获取配置文件内容：返回值有 get / getPromise 方法:get() 获取内存或 defaultConfig;getPromise() 异步获取远端配置
    */
    getConfig(opts: string | options, defaultConfig?: string, isHttps?: boolean, skipParsing?: boolean, isKipWarning?: boolean) {
        let fileName = null, isIgnite = false;
        if (typeof opts === 'object') {
            defaultConfig = opts.defaultConfig;
            isHttps = opts.isHttps;
            skipParsing = opts.skipParsing;
            isKipWarning = opts.isKipWarning;
            fileName = opts.fileName;
            isIgnite = opts.isIgnite || false;
        } else {
            fileName = opts;
        }
        if (fileName.indexOf(':') < 0) {
            fileName = appConfig['AppID'] + ':' + fileName;
        }
        const span = cat.span('node.vampire.qconfig.getConfig', fileName);
        return span.run((done) => {
            try {
                if (!this._qconfigMetric) {
                    this._qconfigMetric = new MetricMonitor();
                }
                checkFormat.checkFiles(fileName);
                this._qconfigMetric.CtriputilCountQconfig(1, appConfig['AppID']);
                if (!this._qconfigFetchServer) {
                    this._qconfigFetchServer = qconfigFetchServer.getInstance();
                }
                if (!this._configStore[fileName]) {
                    isHttps && (storeHttps[fileName] = true);
                    //******************** 1.该配置文件首次拉取 *******************************
                    //**** 1.取defaultConfig
                    this._configStore[fileName] = new qconfigObject(fileName, defaultConfig, skipParsing);
                    this._configStore[fileName]._resetData();
                    //**** 2.开启fetch
                    this._configStore[fileName]._Promise = this._fetchConfig(fileName, isKipWarning, isIgnite);
                }
                done();
                return this._configStore[fileName];
            } catch (err) {
                console.log('qconfig.getConfig.err', err);
                cat.error(err);
                done();
                return null;
            }
        })
    }


    /*
    * 1.拉取最新配置->2.recordResult->3.更新缓存->4.开启长轮询
    * store['qconfigFileArr'] {Array} 存储所有文件名
    * store[data.configName] {object} 文件名-->内容，版本等
    * */
    _fetchConfig(fileName: string, isKipWarning: boolean, isIgnite: boolean): Promise<Configs> {
        return this._qconfigFetchServer.qconfigInitFinish.then(() =>
            qconfigFetchConfigs.loadTheLatestConfig(fileName, storeHttps[fileName], isKipWarning)
        ).then((latest) => {
            if (latest.configVersion > 0) {
                return qconfigFetchConfigs.recordResult(latest, 1).then(() => latest);
            } else {
                return latest;
            }
        }).then((data) => {
            return this._fetchDataDal(data);
        }).catch((err) => {
            //throw err;
            console.log('[node-vampire-qconfig] fetConfigsByName Error: ', err)
            cat.event('Node.Qconfig.requestFailure', err.message);
            clogging.custom({
                type: 'warn',
                title: 'qconfig_fetConfigsByName',
                message: err,
                addInfo: {}
            });

            if (store['qconfigFile.detail'] && store['qconfigFile.detail'][fileName]) {
                return this._fetchDataDal(store['qconfigFile.detail'][fileName]);
            } else {
                // 如果是点火状态，抛出异常
                if (isIgnite) {
                    throw err;
                }
                // 如果不需要点火，设置默认的配置，这样可以在longpolling的时候拉取到最新的配置
                !this._fetchFiles[fileName] && this._fetchDataDal({
                    configName: fileName,
                    configVersion: -1,
                    configContent: null,
                    configSource: appConfig['qconfig.server.type'] + ':' + (appConfig['qconfig.subEnv'] || appConfig['qconfig.idc'])
                });
                return err;
            }
        });
    }

    _fetchDataDal(data: Configs): string {
        //*********** 更新qconfigObjects 数据 *************************
        this._fetchFiles[data.configName] = data;
        if (!this._configStore[data.configName]) {
            this._configStore[data.configName] = new qconfigObject(data.configName, data.configContent);
        } else if (data.configContent) {
            this._configStore[data.configName]._originalData = data.configContent;
            this._configStore[data.configName]._resetData();
        }
        //*********** 2.开启长轮询，只开启一次 *************************
        if (!this.startSubscribe) {
            this.startSubscribe = true;
            this._startSubscribe();
            this._sendChangeData();
        }
        return data.configContent;
    }

    /*
    * 长轮询,拉取最新配置.超时时间：60s.一个进程中只开启一次
    * @params timeout {number} 间隔时间
     */
    _startSubscribe(timeout?: number): void {
        locker.run((done): void => {
            timeout = timeout || 500;
            const that = this;
            that._getFiles();
            cat.event('qconfig.Subscribe.process', "" + process.pid);
            setTimeout(function () {
                const files = store["qconfigFile.detail"] ? store["qconfigFile.detail"] : {};
                qconfigFetchConfigs.longPollCheckUpdate(files).then((updatedConfigs) => {
                    if (!updatedConfigs) {
                        done();
                        that._startSubscribe();
                        return;
                    }
                    const _promise = [], confileArr = {};

                    //************************* 发现版本更新时，1.拉取最新版本文件；2.记录recordResult; 3.更新内存 ********************************
                    for (let item = 0; item < (<Array<object>>updatedConfigs).length; item++) {
                        const _isHttpsGetConfigs = updatedConfigs[item].configName && storeHttps[updatedConfigs[item].configName] ? storeHttps[updatedConfigs[item].configName] : false;
                        if (_isHttpsGetConfigs != null && _isHttpsGetConfigs != undefined) {
                            _promise.push(qconfigFetchConfigs.getConfigByNameAndVersion(updatedConfigs[item], _isHttpsGetConfigs).then((configFile) => {
                                confileArr[configFile.configName] = configFile;
                                return configFile;
                            }).then((configFile) => {
                                // 2.recordResult
                                return qconfigFetchConfigs.recordResult(configFile, 5);
                            }).catch((err) => {
                                cat.error(err, `getConfigByNameAndVersion ${JSON.stringify(updatedConfigs[item])}`);
                            }))
                        }
                    }
                    return Promise.all(_promise).then(() => {
                        //******************************3. 更新内存 ****************************
                        that._saveFiles(confileArr);
                        done();
                        that._startSubscribe();
                    });
                }).catch(() => {
                    done();
                    that._startSubscribe(10000);
                });
            }, timeout).unref();
        })
    }

    _getFiles(): void {
        if (!store['qconfigFile.detail']) {
            store['qconfigFile.detail'] = this._fetchFiles;
        } else {
            const fileDetailsArr: object = store['qconfigFile.detail'];
            for (const item in this._fetchFiles) {
                !fileDetailsArr[item] && (fileDetailsArr[item] = this._fetchFiles[item]);
            }
            store['qconfigFile.detail'] = fileDetailsArr;
        }
    }

    _saveFiles(confileArr: object): void {
        const fileDetailsArr: object = store['qconfigFile.detail'];
        for (const item in confileArr) {
            fileDetailsArr[item] = confileArr[item];
        }
        store['qconfigFile.detail'] = fileDetailsArr;
    }

    _sendChangeData(): void {
        setInterval(() => {
            const data = store['qconfigFile.detail'];
            if (data) {
                for (const item in data) {
                    const fileDetail = data[item];
                    if (this._fetchFiles[item] && this._fetchFiles[item].configVersion != fileDetail.configVersion) {
                        this._fetchFiles[item] = fileDetail;
                        this._configStore[fileDetail.configName] && this._configStore[fileDetail.configName]._handleChange(fileDetail.configContent);
                    }
                }
            }
        }, 2000).unref();
    }
}

const _qconfig = new QConfig();

//qconfig点火
CtripIgnitePlugin.register({
    igniteName: '@ctrip/node-vampire-qconfig',
    igniteType: 'sdk',
    /**
     * 组件或应用的帮助页面链接，帮助页面里最好包含联系人和基本介绍以及如何利用点火日志排错的信息
     * @return 组件或应用的帮助wiki链接
     */
    helpUrl: (): string => {
        return 'nodejsts@ctrip.com';
    },
    /**
   *可以将组件或应用的初始化动作放在里面，初始化中有致命问题时，可返回false。返回false会导致点火失败，点火失败的应用不会被拉入集群
   * @return true时，初始化成功。false时，初始化失败，导致点火失败。
   */
    warmUp: (): Promise<boolean> => {
        return _qconfig.init().then(() => {
            simpleLogger.info('qconfig init success');
            return Promise.resolve(true);
        }).catch(() => {
            return Promise.resolve(false);
        })
    },
    /**
    * 对组件或应用极为重要的一些配置（比如组件或应用的初始化参数：url,timeout等）
    * @return 包含重要配置的map
    */
    coreConfigs: (): object => {
        return {};
    },
    /**
     * 用来执行组件或应用的自检操作
     * @return true时，自检成功。false时，自检失败，导致点火失败。
     */
    selfCheck: (): Promise<boolean> => {
        return Promise.resolve(true);
    }
})

export = _qconfig;
