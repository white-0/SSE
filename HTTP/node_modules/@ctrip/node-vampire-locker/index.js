const os = require('os');
const crypto = require("crypto");

let LockerAddon;
let prebuildPkg;
try {
  prebuildPkg = '@ctrip/node-vampire-locker-prebuild-' + os.platform() + '-' + os.arch();
  LockerAddon = require(prebuildPkg);
} catch (e) {
  LockerAddon = require(require.resolve('./build/locker.node'));
}

const { lockSyncAndRun, lockAsyncAndRun } = LockerAddon;

function md5(str) {
  let hash = crypto.createHash("md5");
  return hash.update(str).digest("hex");
}

let lockMap = {};

class Locker {
  constructor(name) {
    if (!name) {
      throw new Error("Invalid Locker Name");
    }
    this._name = name;
    this._md5 = md5(name).slice(0, 16);
    this._locked = false;
    this._runQueue = [];
    if (Object.prototype.hasOwnProperty.call(lockMap, this._md5)) {
      return lockMap[this._md5];
    }
    lockMap[this._md5] = this;
  }
  run(callback) {
    if (this._locked) {
      this._runQueue.push(callback);
      return;
    }
    this._locked = true;
    lockAsyncAndRun(this._md5, (done) => {
      let doneWrapper = () => {
        done();
        this._locked = false;
        if (this._runQueue.length) {
          this.run(this._runQueue.shift());
        }
      };
      if (callback) {
        callback(doneWrapper);
      } else {
        doneWrapper();
      }
    });
  }
  lockSync() {
    if (this._locked) {
      throw new Error("Lock Conflict");
    }
    this._locked = true;
    lockSyncAndRun(this._md5, (done) => {
      this._unlockSync = () => {
        done();
        delete this._unlockSync;
        this._locked = false;
      };
    });
  }
  unlockSync() {
    if (!this._locked || !this._unlockSync) {
      throw new Error("Unlock Conflict");
    }
    this._unlockSync();
  }
}

module.exports = Locker;
