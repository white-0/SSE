const os = require('os');
const childProcess = require('child_process');
const spawn = childProcess.spawn;
const exec = childProcess.exec;
const spawnSync = childProcess.spawnSync;
const fs = require('fs');

const util = require('@ctrip/node-vampire-util');
let isLinux = os.platform() == 'linux';
let isDocker = os.platform() == 'linux' && process.env['CDOS_CPUS'];

let lastCpuStatus = getCpuStatus();
let lastDockerCpuStatus = {
    hostTicks: 0,
    dockerTicks: 0
};

if (isDocker) {
    getDockerCpuStatus(function (dockerCpuStatus) {
        lastDockerCpuStatus = dockerCpuStatus;
    });
}

let hostCpuTickUnit = (function () {
    let ret = 100;
    try {
        ret = parseInt(spawnSync('/usr/bin/getconf', ['CLK_TCK']).stdout.toString().trim(), 10) || 100;
    } catch (e) {
        // empty
    }
    return ret;
})();

let hostCpuCoreCount = lastCpuStatus.count;
let dockerCpuCoreCount = parseInt(process.env['CDOS_CPUS'] || '', 10) || 0;

let netStatusRe = {
    'Incoming-Packets-Discarded': /(\d+) incoming packets discarded/,
    'Outgoing-Packets-Dropped': /(\d+) outgoing packets dropped/,
    'Dropped-Because-Of-Missing-Route': /(\d+) dropped because of missing route/,
    'Failed-Connection-Attempts': /(\d+) failed connection attempts/,
    'Connection-Resets-Received': /(\d+) connection resets received/,
    'Segments-Retransmited': /(\d+) segments retransmited/,
    'Bad-Segments-Received': /(\d+) bad segments received/,
    'Resets-Sent': /(\d+) resets sent/,
    'Resets-Received-For-Embryonic-SYN_RECV-Sockets': /(\d+) resets received for embryonic SYN_RECV sockets/,
    'TCPLostRetransmit': /TCPLostRetransmit: (\d+)/,
    'Fast-Retransmits': /(\d+) fast retransmits/,
    'Forward-Retransmits': /(\d+) forward retransmits/,
    'SACK-Retransmits-Failed': /(\d+) SACK retransmits failed/,
    'Connections-Reset-Due-To-Unexpected-Data': /(\d+) connections reset due to unexpected data/,
    'Connections-Reset-Due-To-Early-User-Close': /(\d+) connections reset due to early user close/,
    'Connections-Aborted-Due-To-Timeout': /(\d+) connections aborted due to timeout/,
};

let lastNetStatus = (function () {
    let ret = {};
    util.enum(netStatusRe, function (key) {
        ret[key] = 0;
    });
    return ret;
})();

if (isLinux) {
    getNetStatus(function (netStatus) {
        lastNetStatus = netStatus;
    });
}

function getCpuStatus() {
    let cpus = os.cpus();
    let ret = {
        count: cpus.length,
        all: 0,
        used: 0
    };
    cpus.forEach(function (cpu) {
        let t = cpu.times.user + cpu.times.nice + cpu.times.sys + cpu.times.irq;
        ret.used += t;
        ret.all += t + cpu.times.idle;
    });
    return ret;
}

function getCpuInfo(callback) {
    let cpuStatus = getCpuStatus();
    let ret = {
        count: cpuStatus.count,
        load: os.loadavg()[0],
        usage: 0
    };
    ret.usage = (cpuStatus.used - lastCpuStatus.used) / (cpuStatus.all - lastCpuStatus.all);
    lastCpuStatus = cpuStatus;
    callback && process.nextTick(callback, ret);
}

function getDockerCpuStatus(callback) {
    let ret = {
        hostTicks: 0,
        dockerTicks: 0,
        throttledCount: 0,
        throttledTime: 0
    };
    let p1 = new Promise(function (resolve, reject) {
        fs.readFile('/proc/stat', function (err, data) {
            if (err) {
                reject();
            } else {
                let line = data.toString().match(/^.+/)[0];
                let ticks = 0;
                line.match(/\d+/g).forEach(function (val) {
                    ticks += parseInt(val, 10);
                });
                ret.hostTicks = Math.floor(ticks / hostCpuTickUnit * 1e9); // nanoseconds
                resolve();
            }
        });
    });
    let p2 = new Promise(function (resolve, reject) {
        fs.readFile('/sys/fs/cgroup/cpu/cpuacct.usage', function (err, data) {
            if (err) {
                reject();
            } else {
                ret.dockerTicks = parseInt(data.toString().trim(), 10);
                resolve();
            }
        });
    });
    let p3 = new Promise(function (resolve, reject) {
        fs.readFile('/sys/fs/cgroup/cpu/cpu.stat', function (err, data) {
            if (err) {
                reject();
            } else {
                let txt = data.toString().trim();
                let arr1 = txt.match(/^nr_throttled (\d+)/m);
                if (arr1) {
                    ret.throttledCount = parseInt(arr1[1], 10);
                }
                let arr2 = txt.match(/^throttled_time (\d+)/m);
                if (arr2) {
                    ret.throttledTime = parseInt(arr2[1], 10);
                }
                resolve();
            }
        });
    });
    let wrapCallback = function () {
        callback && callback(ret);
    };
    Promise.all([p1, p2, p3]).then(wrapCallback).catch(wrapCallback);
}

function getDockerCpuInfo(callback) {
    getCpuInfo(function (cpu) {
        let ret = {
            count: cpu.count,
            load: cpu.load,
            usage: cpu.usage,
            dockerCount: dockerCpuCoreCount,
            dockerUsage: 0,
            dockerThrottledCount: 0,
            dockerThrottledTime: 0
        };
        getDockerCpuStatus(function (dockerCpuStatus) {
            let hostTickDelta = dockerCpuStatus.hostTicks - lastDockerCpuStatus.hostTicks;
            let dockerTickDelta = dockerCpuStatus.dockerTicks - lastDockerCpuStatus.dockerTicks;
            ret.dockerUsage = dockerTickDelta / (hostTickDelta / hostCpuCoreCount * dockerCpuCoreCount);
            ret.dockerThrottledCount = dockerCpuStatus.throttledCount - lastDockerCpuStatus.throttledCount;
            ret.dockerThrottledTime = dockerCpuStatus.throttledTime - lastDockerCpuStatus.throttledTime;
            lastDockerCpuStatus = dockerCpuStatus;
            callback && callback(ret);
        });
    });
}

function getMemoryInfo(callback) {
    let memory = process.memoryUsage();
    let freeMem = os.freemem();
    let ret = {
        total: os.totalmem(),
        free: freeMem,
        avalible: freeMem,
        rss: memory.rss,
        heapTotal: memory.heapTotal,
        heapUsed: memory.heapUsed,
        external: memory.external
    };

    let wrapCallback = function () {
        callback && callback(ret);
    };

    if (isLinux) {
        new Promise(function (resolve, reject) {
            fs.readFile('/proc/meminfo', function (err, data) {
                if (err) {
                    reject();
                } else {
                    let txt = data.toString().trim();
                    let arr1 = txt.match(/^MemTotal:\s*(\d+)/m);
                    if (arr1) {
                        ret.total = parseInt(arr1[1], 10) * 1024;
                    }
                    let arr2 = txt.match(/^MemFree:\s*(\d+)/m);
                    if (arr2) {
                        ret.free = parseInt(arr2[1], 10) * 1024;
                    }
                    let arr3 = txt.match(/^MemAvailable:\s*(\d+)/m);
                    if (arr3) {
                        ret.avalible = parseInt(arr3[1], 10) * 1024;
                    }
                    resolve();
                }
            });
        }).then(wrapCallback).catch(wrapCallback);
    } else {
        process.nextTick(wrapCallback);
    }
}

function getFileDescriptorStatus(callback) {
    let ret = {
        open: 0,
        max: 0,
        avalible: 0
    };
    let wrapCallback = function () {
        callback && callback(ret);
    };
    new Promise(function (resolve, reject) {
        fs.readFile('/proc/sys/fs/file-nr', function (err, data) {
            if (err) {
                reject();
            } else {
                let arr = data.toString().trim().match(/\d+/g);
                if (arr) {
                    ret.open = parseInt(arr[0], 10) + parseInt(arr[1], 10);
                    ret.max = parseInt(arr[2], 10);
                    ret.avalible = ret.max - ret.open;
                    resolve();
                } else {
                    reject();
                }
                resolve();
            }
        });
    }).then(wrapCallback).catch(wrapCallback);
}

function getNetStatus(callback) {
    let ret = {};
    util.enum(netStatusRe, function (key) {
        ret[key] = 0;
    });

    let hasRunCallback = false;
    let wrapCallback = function () {
        if (!hasRunCallback) {
            hasRunCallback = true;
            callback && callback(ret);
        }
    };

    let proc = spawn('netstat', ['-s']);
    let buff = [];
    proc.on('error', wrapCallback);
    proc.stdout.on('data', function (chunk) {
        buff.push(chunk);
    });
    proc.on('exit', function () {
        let txt = Buffer.concat(buff).toString().trim();
        util.enum(netStatusRe, function (key, re) {
            let arr = txt.match(re);
            if (arr) {
                ret[key] = parseInt(arr[1], 10);
            }
        });
        wrapCallback();
    });
}

function getNetInfo(callback) {
    let ret = {
        'SYN_RECV': 0,
        'ESTABLISHED': 0,
        'TIME_WAIT': 0
    };

    function ssMap(status) {
        if (status == 'ESTAB') {
            status = 'ESTABLISHED';
        } else {
            status = status.replace(/-/g, '_');
        }
        return status;
    }
    let wrapCallback = function () {
        callback && callback(ret);
    };
    let p1 = new Promise(function (resolve) {
        getNetStatus(function (netStatus) {
            util.enum(netStatusRe, function (key) {
                ret[key] = Math.max(0, (netStatus[key] - lastNetStatus[key]) || 0);
            });
            lastNetStatus = netStatus;
            resolve();
        });
    });
    let p2 = new Promise(function (resolve) {
        let proc = exec('ss -tan | awk \'NR>1 {++S[$1]} END {for (a in S) print a, S[a]}\'', {
            encoding: 'buffer'
        });
        let buff = [];
        proc.on('error', resolve);
        proc.stdout.on('data', function (chunk) {
            buff.push(chunk);
        });
        proc.on('exit', function () {
            let txt = Buffer.concat(buff).toString().trim();
            txt.replace(/^([\w-]+)\s(\d+)$/gm, function (a, b, c) {
                ret[ssMap(b)] = parseInt(c, 10);
            });
            resolve();
        });
    });
    Promise.all([p1, p2]).then(wrapCallback).catch(wrapCallback);
}


function createVersionString(versions) {
    return util.objectToArray(versions, function (key, value) {
        return key + '@' + value;
    }).join(', ');
}

module.exports = {
    getDockerCpuInfo,
    getCpuInfo,
    getMemoryInfo,
    getFileDescriptorStatus,
    getNetInfo,
    createVersionString,
    netStatusRe
};