const os = require("os");
const path = require("path");
const fs = require("fs");
const crypto = require("crypto");
const exec = require("child_process").exec;
const int64Buffer = require("./libs/int64Buffer.js");
let util = {};
const entry = (require.main && require.main.filename) ||
      (process.argv[1] && path.resolve(process.cwd(), process.argv[1])) ||
      null;

util.hasOwn = function (obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key);
};

util.hasOwnProperty = util.hasOwn;

util.uid = function () {
  return "uid_" + new Date().getTime() + (Math.random() * 1e10).toFixed(0);
};

util.type = function (obj) {
  return Object.prototype.toString.call(obj).slice(8, -1).toLowerCase();
};

util.copy = function (obj) {
  let ret;
  if (obj === void 0 || obj === null) {
    ret = obj;
  } else {
    switch (util.type(obj)) {
      case "object":
        ret = {};
        for (let key in obj) {
          if (util.hasOwn(obj, key)) {
            ret[key] = util.copy(obj[key]);
          }
        }
        break;
      case "array":
        ret = obj.map(util.copy);
        break;
      case "date":
        ret = new Date(+obj);
        break;
      default:
        ret = obj;
        break;
    }
  }
  return ret;
};

let hostIp = null;

util.getHostIp = function () {
  if (!hostIp) {
    hostIp = process.env["CDOS_POD_IP"] || process.env["ip"];
  }
  if (!hostIp) {
    let ipA = "",
      ipB = "";
    let inf = os.networkInterfaces();
    infLoops: for (let name in inf) {
      if (util.hasOwn(inf, name)) {
        let arr = inf[name];
        for (let i = 0; i < arr.length; i++) {
          if (arr[i].family == "IPv4" && arr[i].internal == false) {
            if (
              /^(10|172\.(1[6789]|2\d|3[01])|192\.168)\./.test(arr[i].address)
            ) {
              ipA = arr[i].address;
              break infLoops;
            }
            if (!ipB) {
              ipB = arr[i].address;
            }
          }
        }
      }
    }
    hostIp = ipA || ipB || "127.0.0.1";
  }
  return hostIp;
};

let hostName = null;

util.getHostName = function () {
  if (!hostName) {
    hostName = os.hostname();
  }
  return hostName;
};

util.getHostAddress = util.getHostIp;

function getWindowsDiskInfo(callback) {
  let child = exec(
    'PowerShell -Command "gwmi win32_LogicalDisk -filter DriveType=3"',
    function (err, stdout) {
      if (err) {
        callback(err, null);
      } else {
        let ret = [];
        let re =
          /\nDeviceID\s*:\s*(.*?)\r?\nDriveType\s*:\s*(.*?)\r?\nProviderName\s*:\s*(.*?)\r?\nFreeSpace\s*:\s*(.*?)\r?\nSize\s*:\s*(.*?)\r?\nVolumeName\s*:\s*(.*?)\r?\n/g;
        stdout.replace(
          re,
          function (
            _,
            Caption,
            DriveType,
            ProviderName,
            FreeSpace,
            Size,
            VolumeName
          ) {
            let info = {
              path: Caption,
              fileSystem: "",
              freeSpace: parseInt(FreeSpace, 10),
              size: parseInt(Size, 10),
              name: VolumeName,
            };
            ret.push(info);
          }
        );
        callback(null, ret);
      }
    }
  );
  child.stdin.end();
}

let dfDefs = {
  "Mounted on": {
    name: "path",
    type: "string",
    filter: function (path) {
      return path.replace(/\/?$/, "/");
    },
  },
  Type: {
    name: "fileSystem",
    type: "string",
    filter: function (item) {
      return item.toLowerCase();
    },
  },
  Available: {
    name: "freeSpace",
    type: "int",
  },
  "1-blocks": {
    name: "size",
    type: "int",
  },
  Filesystem: {
    name: "name",
    type: "string",
  },
};

function getLinuxDiskInfo(callback) {

  exec("df -B 1 -T -P", function (err, stdout) {
    if (err) {
      callback(err, null);
    } else {
      let lines = stdout.split("\n");
      let cols = lines.shift().split(/\s+(?=[A-Z\d]|$)/);
      let ret = [];
      lines.forEach(function (line) {
        line = line.trim();
        if (line) {
          let info = {};
          line.split(/\s+/).forEach(function (val, i) {
            let def = dfDefs[cols[i]];
            if (def) {
              if (def.type == "int") {
                val = parseInt(val, 10);
              }
              if (def.filter) {
                val = def.filter(val);
              }
              info[def.name] = val;
            }
          });
          if (info.path && info.size) {
            ret.push(info);
          }
        }
      });
      callback(null, ret);
    }
  });
}

util.getDiskInfo =
  os.platform().startsWith("win") ? getWindowsDiskInfo : getLinuxDiskInfo;

util.getMicroSeconds = function () {
  let t = process.hrtime();
  return parseInt((t[0] * 1e9 + t[1]) / 1e3, 10);
};

util.getNanoSeconds = function () {
  let t = process.hrtime();
  return t[0] * 1e9 + t[1];
};

util.sleep = function (s) {
  let e = +new Date() + s * 1000;
  while (+new Date() <= e);
};

util.usleep = function (s) {
  let e = +new Date() + s / 1000;
  while (+new Date() <= e);
};

util.upperCaseFirstChar = function (str) {
  return str.slice(0, 1).toUpperCase() + str.slice(1);
};

util.repeat = function (str, times) {
  let arr = [];
  arr[times] = "";
  return arr.join(str);
};

util.fillZero = function (num, len) {
  return (util.repeat("0", len) + num).slice(-Math.max(len, ("" + num).length));
};

util.isInt = function (num) {
  return Number.isInteger(num);
};

let escapeChars = {
  "\r": "\\r",
  "\n": "\\n",
  "\t": "\\t",
};

util.escapeString = function (str) {
  return str.replace(/\\/g, "\\\\").replace(/[\t\r\n]/g, function (a) {
    return escapeChars[a];
  });
};

util.formatReString = function (str) {
  return str
    .replace(/([.\\/+*?[\]{}()^$|])/g, "\\$1")
    .replace(/[\r\t\n]/g, function (a) {
      return escapeChars[a];
    });
};

function DtFormater(dateTime) {
  this.dateTime = dateTime;
  this._y = null;
  this._M = null;
  this._d = null;
  this._h = null;
  this._m = null;
  this._s = null;
  this._S = null;
}

DtFormater.prototype.y = function () {
  return this._y === null ? (this._y = this.dateTime.getFullYear()) : this._y;
};

DtFormater.prototype.M = function () {
  return this._M === null ? (this._M = this.dateTime.getMonth() + 1) : this._M;
};

DtFormater.prototype.d = function () {
  return this._d === null ? (this._d = this.dateTime.getDate()) : this._d;
};

DtFormater.prototype.h = function () {
  return this._h === null ? (this._h = this.dateTime.getHours()) : this._h;
};

DtFormater.prototype.m = function () {
  return this._m === null ? (this._m = this.dateTime.getMinutes()) : this._m;
};

DtFormater.prototype.s = function () {
  return this._s === null ? (this._s = this.dateTime.getSeconds()) : this._s;
};

DtFormater.prototype.S = function () {
  return this._S === null ?
    (this._S = this.dateTime.getMilliseconds()) :
    this._S;
};

util.formatDateTime = function (dateTime, format) {
  dateTime = new Date(dateTime);
  if (isNaN(dateTime)) {
    dateTime = new Date();
  }
  if (!format) {
    format = "yyyy-MM-dd hh:mm:ss";
  }

  let df = new DtFormater(dateTime);

  return format.replace(/y{2,}|M+|d+|h+|m+|s+|S+/g, function (a) {
    let t = "" + df[a[0]]();
    let n = a.length - t.length;
    if (n > 0) {
      t = util.repeat("0", n) + t;
    } else {
      t = t.slice(-a.length);
    }
    return t;
  });
};

util.stringify = function (val) {
  switch (util.type(val)) {
    case "string":
      break;
    case "number":
      val = val.toString();
      break;
    case "date":
      val = isNaN(val) ? "" : util.formatDateTime(val);
      break;
    default:
      val = (function () {
        let ret;
        try {
          ret = JSON.stringify(val);
          if (util.type(ret) != "string") {
            ret = Object.prototype.toString.call(val);
          }
        } catch (e) {
          ret = "[ERROR: JSON ENCODE FAILED]";
        }
        return ret;
      })();
      break;
  }
  return val;
};

util.extendMap = function (obj) {
  let args = Array.prototype.slice.call(arguments, 1);
  for (let i = 0; i < args.length; i++) {
    for (let key in args[i]) {
      if (util.hasOwn(args[i], key)) {
        obj[key] = util.stringify(args[i][key]);
      }
    }
  }
  return obj;
};

util.md5 = function (str) {
  let md5sum = crypto.createHash("md5");
  md5sum.update(str);
  return md5sum.digest("hex");
};

util.md5Int = function (str) {
  let md5sum = crypto.createHash("md5");
  md5sum.update(str);
  let bytes = md5sum.digest();
  let buff = bytes.slice(0, 4);
  return buff.readIntLE(0, buff.length);
};

util.md5UnsignedInt = function (str) {
  let md5sum = crypto.createHash("md5");
  md5sum.update(str);
  let bytes = md5sum.digest();
  let buff = bytes.slice(0, 4);
  return buff.readUIntLE(0, buff.length);
};

util.binarySearch = function (arr, val, start, end) {
  start = start || 0;
  end = end || arr.length;
  let mid = start + Math.floor((end - start) / 2);
  let midVal = arr[mid];

  let ret = -1;

  if (midVal === val) {
    ret = mid;
  } else if (midVal < val) {
    if (mid + 1 < end) {
      ret = util.binarySearch(arr, val, mid, end);
    } else {
      ret = -(mid + 1) - 1;
    }
  } else if (midVal > val) {
    if (mid > start) {
      ret = util.binarySearch(arr, val, start, mid);
    } else {
      ret = -mid - 1;
    }
  }
  return ret;
};

util.intToBuff = function (num, len) {
  let ret = null;
  if (len <= 6) {
    ret = Buffer.alloc(len);
    ret.writeIntBE(num, 0, len);
  } else if (len == 8) {
    ret = new int64Buffer.Int64BE(num).toBuffer();
  } else {
    throw new Error("Invalid Length");
  }
  return ret;
};

util.uIntToBuff = function (num, len) {
  let ret = null;
  if (len <= 6) {
    ret = Buffer.alloc(len);
    ret.writeUIntBE(num, 0, len);
  } else if (len == 8) {
    ret = new int64Buffer.Uint64BE(num).toBuffer();
  } else {
    throw new Error("Invalid Length");
  }
  return ret;
};

util.doubleToBuff = function (num) {
  let ret = Buffer.alloc(8);
  ret.writeDoubleBE(num, 0);
  return ret;
};

util.varint = function (num) {
  let bytes = [];
  while (num > 127) {
    let t = num % 128;
    bytes.push(t + 0x80);
    num = Math.floor(num / 128);
  }
  bytes.push(num);
  return Buffer.from(bytes);
};

util.stringBuilder = function (lines, spliter) {
  let arr = [];
  for (let i = 0; i < lines.length; i++) {
    let line = lines[i];
    if (line !== null) {
      if (util.type(line) == "array") {
        arr.push(util.stringBuilder(line, spliter));
      } else {
        arr.push(line);
      }
    }
  }
  return arr.join(spliter || "\r\n");
};

util.enum = function (obj, callback) {
  let idx = 0;
  for (let key in obj) {
    if (util.hasOwn(obj, key)) {
      callback(key, obj[key], idx);
      idx++;
    }
  }
};

util.objectToArray = function (obj, callback) {
  if (util.type(callback) == "number") {
    let k = callback;
    callback = function () {
      return arguments[k];
    };
  }
  let ret = [];
  let idx = 0;
  for (let key in obj) {
    if (util.hasOwn(obj, key)) {
      ret.push(callback(key, obj[key], idx));
      idx++;
    }
  }
  return ret;
};

util.getStack = function getStack(constructorOpt) {
  let ret = {};
  Error.captureStackTrace(ret, constructorOpt || getStack);
  return ret.stack;
};

util.getModuleVersion = function (name) {
  let ret = null;
  let json = null;
  try {
    json = require(name + "/package.json");
    ret = json.version || "0.0.0";
  } catch (e) {
    // empty
  }
  return ret;
};

util.makeDir = function (top, callback) {
  fs.mkdir(top, function (err) {
    if (err) {
      if (err.code == "EEXIST") {
        callback();
      } else {
        let parent = path.dirname(top);
        util.makeDir(parent, function (err) {
          if (err) {
            callback(err);
          } else {
            fs.mkdir(top, function (err) {
              if (err) {
                callback(err);
              } else {
                callback();
              }
            });
          }
        });
      }
    } else {
      callback();
    }
  });
};

util.readServerProperties = function (callback) {
  let path_url = "";
  if (os.platform() == "linux") {
    path_url = "/opt/settings/server.properties";
  } else {
    path_url = path.join(
      path.dirname(entry),
      "server.properties"
    );
  }
  fs.readFile(path_url, function (err, data) {
    if (err) {
      callback(os.platform + " Invalid File: server.properties", null);
    } else {
      let results = {};
      data.toString().replace(/^(.*?)=(.*?)$/gm, function (_, key, value) {
        results[key] = value;
      });
      callback(null, results);
    }
  });
};

util.getProperties = function (callback) {
  util.readServerProperties((err, ret) => {
    callback && callback(err ? {} : ret);
  });
};

util.storagePath = function () {
  return os.platform() == "linux" ?
    `/opt/data/${process.env.PAAS_APP_APPID}/` :
    path.dirname(entry);
};

util.deepFreeze = function (o) {
  Object.freeze(o);

  Object.getOwnPropertyNames(o).forEach(function (prop) {
    if (
      Object.prototype.hasOwnProperty.call(o, prop) &&
      o[prop] !== null &&
      (typeof o[prop] === "object" || typeof o[prop] === "function") &&
      !Object.isFrozen(o[prop])
    ) {
      util.deepFreeze(o[prop]);
    }
  });

  return o;
};

module.exports = util;